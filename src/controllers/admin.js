/**
 * Admin controller - Admin tools and file uploads
 */

import { json } from '../utils/response.js';
import { CORS } from '../config/cors.js';
import { VERSION } from '../config/constants.js';
import { getMimeTypeFromFilename, resolveContentType } from '../utils/upload-helper.js';
import { normalizeArchiveMetaValue } from '../utils/formatting.js';

// Reliable Cobalt Instances List (Fallback Pool) for Auto-Healing YouTube Downloader
const FALLBACK_INSTANCES = [
  'https://api.cobalt.tools',      // Official
  'https://cobalt.sipnet.net',     // Community 1
  'https://cobalt.slpy.one',       // Community 2
  'https://api.wuk.sh'             // Community 3
];

// Flag to track if version purge check was done
let purgeVersionChecked = false;

/**
 * Verify Cloudflare Turnstile captcha token
 * Returns true if valid, false otherwise
 */
async function verifyTurnstileToken(env, token, remoteIp) {
  if (!token) {
    console.log('Turnstile token missing');
    return false;
  }

  const secretKey = env.TURNSTILE_SECRET_KEY;
  if (!secretKey) {
    console.log('Turnstile secret key not configured');
    // For development/testing, allow bypass if no secret configured
    // In production, this should always be configured
    return env.NODE_ENV === 'development' || env.ENVIRONMENT === 'development';
  }

  try {
    const verifyUrl = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';
    const response = await fetch(verifyUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        secret: secretKey,
        token: token,
        remoteip: remoteIp
      })
    });

    const result = await response.json();

    if (result.success) {
      console.log('Turnstile verification successful');
      return true;
    } else {
      console.log('Turnstile verification failed:', result.error_codes);
      return false;
    }
  } catch (e) {
    console.error('Turnstile verification error:', e);
    return false;
  }
}

/**
 * Validate upload request with Turnstile captcha
 * Returns null if valid, or error Response if invalid
 */
async function validateUploadRequest(env, req, url) {
  // Check for bypass token (admin uploads)
  const bypassToken = url.searchParams.get('adminToken');
  if (bypassToken && env.ADMIN_SESSION_SECRET) {
    // Verify admin session
    try {
      const [tsStr, sig] = bypassToken.split('.');
      if (tsStr && sig) {
        const ts = Number(tsStr);
        const ageSec = Math.floor((Date.now() - ts) / 1000);
        if (ageSec >= 0 && ageSec < 3600) { // 1 hour max age
          const enc = new TextEncoder();
          const key = await crypto.subtle.importKey(
            'raw',
            enc.encode(env.ADMIN_SESSION_SECRET),
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
          );
          const sigBytes = await crypto.subtle.sign('HMAC', key, enc.encode(tsStr));
          const expectedSig = btoa(String.fromCharCode(...new Uint8Array(sigBytes)))
            .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
          if (expectedSig === sig) {
            return null; // Valid admin bypass
          }
        }
      }
    } catch (e) {
      console.log('Admin bypass verification failed:', e.message);
    }
  }

  // Check for valid checkout session (user with pending order can upload)
  const sessionId = url.searchParams.get('sessionId');
  if (sessionId) {
    // Check for whitelisted frontend-generated temporary session patterns
    // These are generated by frontend scripts and don't need captcha
    const isWhitelistedPattern = (
      // instant-upload.js: upload_1731234567_abc123def
      sessionId.startsWith('upload_') ||
      // product-form.js: 1731234567 (timestamp only)
      /^\d{10,14}$/.test(sessionId) ||
      // dashboard-settings.js: branding-1731234567
      sessionId.startsWith('branding-') ||
      // Admin temporary uploads
      sessionId.startsWith('admin-') ||
      // Chat widget temporary sessions
      sessionId.startsWith('chat_') ||
      // Generic temporary sessions
      sessionId.startsWith('temp_')
    );

    if (isWhitelistedPattern) {
      console.log('Upload allowed: whitelisted frontend session pattern:', sessionId.substring(0, 20) + '...');
      return null; // Whitelisted pattern, no captcha needed
    }

    // Check if session exists in database
    try {
      const session = await env.DB.prepare(
        'SELECT id, status FROM checkout_sessions WHERE checkout_id = ?'
      ).bind(sessionId).first();
      if (session && (session.status === 'pending' || session.status === 'completed')) {
        return null; // Valid checkout session exists
      }
    } catch (e) {
      console.log('Session validation failed:', e.message);
    }
  }

  // Check Turnstile token
  const turnstileToken = url.searchParams.get('cf-turnstile-response') ||
    req.headers.get('X-Turnstile-Token') ||
    url.searchParams.get('turnstile_token');

  // If no token provided, check if Turnstile is disabled for uploads
  if (!turnstileToken) {
    // Allow uploads without captcha if no secret key is configured
    const secretKey = env.TURNSTILE_SECRET_KEY;
    if (!secretKey) {
      console.log('No Turnstile secret key configured, allowing upload without captcha');
      return null; // No captcha required if no secret key
    }
    console.log('Upload rejected: No Turnstile token provided');
    return json({
      error: 'Captcha validation failed. Please refresh and try again.',
      code: 'CAPTCHA_REQUIRED'
    }, 403);
  }

  // Verify Turnstile token
  const clientIp = req.headers.get('CF-Connecting-IP') || 'unknown';
  const isValid = await verifyTurnstileToken(env, turnstileToken, clientIp);

  if (!isValid) {
    console.log('Upload rejected: Invalid Turnstile captcha');
    return json({
      error: 'Captcha validation failed. Please refresh and try again.',
      code: 'CAPTCHA_INVALID'
    }, 403);
  }

  return null; // Valid
}

/**
 * Get debug info
 */
export function getDebugInfo(env) {
  return json({
    status: 'running',
    bindings: {
      DB: !!env.DB,
      R2_BUCKET: !!env.R2_BUCKET,
      PRODUCT_MEDIA: !!env.PRODUCT_MEDIA,
      ASSETS: !!env.ASSETS
    },
    version: VERSION,
    timestamp: new Date().toISOString()
  });
}

/**
 * Get Archive.org credentials for direct browser upload
 * Zero CPU - just returns credentials, browser uploads directly
 */
export function getArchiveCredentials(env) {
  if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {
    return json({ error: 'Archive.org credentials not configured' }, 500);
  }

  return json({
    success: true,
    accessKey: env.ARCHIVE_ACCESS_KEY,
    secretKey: env.ARCHIVE_SECRET_KEY
  });
}

/**
 * Purge Cloudflare cache manually
 */
export async function purgeCache(env) {
  const zoneId = env.CF_ZONE_ID;
  const token = env.CF_API_TOKEN;
  if (!zoneId || !token) {
    return json({ error: 'CF_ZONE_ID or CF_API_TOKEN not configured' }, 500);
  }
  try {
    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;
    const cfResp = await fetch(purgeUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ purge_everything: true })
    });
    const result = await cfResp.json();
    return json(result, cfResp.ok ? 200 : 500);
  } catch (e) {
    return json({ error: e.message }, 500);
  }
}

/**
 * Auto-purge cache on version change
 */
export async function maybePurgeCache(env, initDB) {
  if (!env || !env.DB || !env.CF_ZONE_ID || !env.CF_API_TOKEN) return;
  if (purgeVersionChecked) return;
  
  try {
    await initDB(env);
    
    let row = null;
    try {
      row = await env.DB.prepare('SELECT value FROM settings WHERE key = ?').bind('last_purge_version').first();
    } catch (_) {}
    
    const lastVersion = row && row.value ? row.value.toString() : null;
    const currentVersion = VERSION.toString();
    
    if (lastVersion === currentVersion) {
      purgeVersionChecked = true;
      return;
    }
    
    const zoneId = env.CF_ZONE_ID;
    const token = env.CF_API_TOKEN;
    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;
    
    await fetch(purgeUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ purge_everything: true })
    });
    
    await env.DB.prepare(
      'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)'
    ).bind('last_purge_version', currentVersion).run();
    
    purgeVersionChecked = true;
  } catch (e) {
    console.error('maybePurgeCache error:', e);
  }
}

/**
 * Get Whop settings
 */
export async function getWhopSettings(env) {
  const row = await env.DB.prepare('SELECT value FROM settings WHERE key = ?').bind('whop').first();
  if (row && row.value) {
    try {
      const settings = JSON.parse(row.value);
      return json({ settings });
    } catch (e) {
      return json({ settings: {} });
    }
  }
  return json({ settings: {} });
}

/**
 * Save Whop settings
 */
export async function saveWhopSettings(env, body) {
  const value = JSON.stringify(body);
  await env.DB.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)').bind('whop', value).run();
  return json({ success: true });
}

/**
 * Upload temp file to R2
 * SECURITY: Requires Turnstile captcha validation or admin session
 */
export async function uploadTempFile(env, req, url) {
  try {
    if (!env.R2_BUCKET) {
      console.error('R2_BUCKET not configured');
      return json({ error: 'R2 storage not configured' }, 500);
    }

    // Validate upload request (Turnstile captcha or admin session)
    const validationError = await validateUploadRequest(env, req, url);
    if (validationError) {
      return validationError;
    }

    const sessionId = url.searchParams.get('sessionId');
    const filename = url.searchParams.get('filename');

    if (!sessionId || !filename) {
      console.error('Missing sessionId or filename');
      return json({ error: 'sessionId and filename required' }, 400);
    }

    console.log('Uploading file:', filename, 'for session:', sessionId);

    // Get content length for size validation (before reading body)
    const contentLength = req.headers.get('content-length');
    const fileSize = contentLength ? parseInt(contentLength, 10) : null;

    // Validate file size early (before loading into memory)
    const isVideo = filename.toLowerCase().match(/\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);
    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;
    const maxSizeLabel = isVideo ? '500MB' : '10MB';

    if (fileSize !== null && fileSize > maxSize) {
      console.error('File too large:', fileSize, 'bytes (max', maxSizeLabel, ')');
      return json({
        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? 'videos' : 'files'}.`,
        fileSize: fileSize,
        maxSize: maxSize,
        fileType: isVideo ? 'video' : 'file'
      }, 400);
    }

    // For small files, use arrayBuffer (faster for small uploads)
    // For large files (>50MB), stream directly to avoid memory issues
    const SIZE_THRESHOLD = 50 * 1024 * 1024; // 50MB

    let fileData;
    let actualSize;

    if (fileSize !== null && fileSize > SIZE_THRESHOLD) {
      // Large file: stream directly to R2 (no memory buffering)
      console.log('Large file detected, streaming directly to R2...');
      fileData = req.body;
      actualSize = fileSize;
    } else {
      // Small file: load into memory (faster for small files)
      const buf = await req.arrayBuffer();
      actualSize = buf.byteLength;

      // Double-check size after loading
      if (actualSize > maxSize) {
        console.error('File too large:', actualSize, 'bytes (max', maxSizeLabel, ')');
        return json({
          error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? 'videos' : 'files'}.`,
          fileSize: actualSize,
          maxSize: maxSize,
          fileType: isVideo ? 'video' : 'file'
        }, 400);
      }

      if (!buf || actualSize === 0) {
        console.error('Empty file buffer');
        return json({ error: 'Empty file - please select a valid file' }, 400);
      }

      fileData = buf;
      console.log('File size:', (actualSize / 1024 / 1024).toFixed(2), 'MB');
    }

    const key = `temp/${sessionId}/${filename}`;

    await env.R2_BUCKET.put(key, fileData, {
      httpMetadata: { contentType: req.headers.get('content-type') || 'application/octet-stream' }
    });

    console.log('File uploaded successfully:', key);

    return json({ success: true, tempUrl: `r2://${key}` });
  } catch (err) {
    console.error('Upload error:', err);
    return json({
      error: 'Upload failed: ' + err.message,
      details: err.stack
    }, 500);
  }
}

/**
 * Get file from R2
 */
export async function getR2File(env, key) {
  if (!env.R2_BUCKET) return json({ error: 'R2 not configured' }, 500);
  
  if (!key) return json({ error: 'key required' }, 400);
  
  const obj = await env.R2_BUCKET.get(key);
  if (!obj) return json({ error: 'File not found' }, 404);
  
  return new Response(obj.body, {
    headers: {
      'Content-Type': obj.httpMetadata?.contentType || 'application/octet-stream',
      'Cache-Control': 'public, max-age=3600'
    }
  });
}

/**
 * Upload customer file directly to Archive.org (NO R2 middleman)
 * Files are uploaded straight to Archive.org as public files
 */
export async function uploadCustomerFile(env, req, url) {
  try {
    if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {
      console.error('Archive.org credentials not configured');
      return json({ error: 'Archive.org credentials not configured' }, 500);
    }

    const itemId = (url.searchParams.get('itemId') || '').replace(/[^a-zA-Z0-9_.-]/g, '-');
    const filename = (url.searchParams.get('filename') || '').replace(/[^a-zA-Z0-9_.-]/g, '-');
    const originalFilename = url.searchParams.get('originalFilename');

    if (!itemId || !filename) {
      console.error('Missing itemId or filename');
      return json({ error: 'itemId and filename required' }, 400);
    }

    console.log('Starting direct Archive.org upload:', filename, 'Item:', itemId);

    // Get content length for size validation (before reading body)
    const contentLength = req.headers.get('content-length');
    const fileSize = contentLength ? parseInt(contentLength, 10) : null;

    // Validate file size early (before loading into memory)
    const videoExtensions = /\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;
    const isVideo = videoExtensions.test(filename);
    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;
    const maxSizeLabel = isVideo ? '500MB' : '10MB';

    if (fileSize !== null && fileSize > maxSize) {
      console.error('File too large:', fileSize, 'bytes (max', maxSizeLabel, ')');
      return json({
        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? 'videos' : 'files'}.`,
        fileSize: fileSize,
        maxSize: maxSize,
        fileType: isVideo ? 'video' : 'file'
      }, 400);
    }

    // Detect content type
    const contentType = resolveContentType(filename, req.headers.get('content-type'));
    const isVideoUpload = contentType.startsWith('video/');

    // Get order details for metadata
    const orderIdFromQuery = url.searchParams.get('orderId');
    let resolvedOrderId = orderIdFromQuery;
    if (!resolvedOrderId) {
      const match = itemId.match(/^delivery_(.+?)_\d+$/);
      if (match) {
        resolvedOrderId = match[1];
      }
    }

    let archiveDescription = '';
    if (resolvedOrderId) {
      try {
        const orderRow = await env.DB.prepare(
          'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?'
        ).bind(resolvedOrderId).first();

        if (orderRow) {
          const productTitle = orderRow.product_title || '';
          const productDescription = orderRow.product_description || '';
          archiveDescription = productDescription
            ? (productTitle ? `${productTitle} - ${productDescription}` : productDescription)
            : `Order #${orderRow.order_id} - ${productTitle || 'Video Delivery'}`;
        } else {
          archiveDescription = `Order #${resolvedOrderId} video delivery`;
        }
      } catch (dbErr) {
        console.warn('Could not fetch order details:', dbErr);
        archiveDescription = `Order #${resolvedOrderId} video delivery`;
      }
    } else {
      archiveDescription = `${isVideoUpload ? 'Video' : 'File'} uploaded via order delivery system`;
    }

    // Prepare Archive.org headers
    const archiveHeaders = {
      Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,
      'Content-Type': contentType,
      'x-archive-auto-make-bucket': '1',
      'x-archive-meta-mediatype': isVideoUpload ? 'movies' : 'data',
      'x-archive-meta-collection': isVideoUpload ? 'opensource_movies' : 'opensource',
      'x-archive-meta-title': normalizeArchiveMetaValue(originalFilename || filename),
      'x-archive-meta-description': normalizeArchiveMetaValue(archiveDescription),
      'x-archive-meta-subject': 'video; delivery',
      'x-archive-meta-language': 'eng'
    };

    // Upload directly to Archive.org (NO R2 stage)
    console.log('Uploading directly to Archive.org...');
    const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;

    // For large files, stream directly; otherwise buffer
    let uploadBody;
    if (fileSize !== null && fileSize > 50 * 1024 * 1024) {
      // Large file: stream directly
      uploadBody = req.body;
    } else {
      // Small file: load into memory
      uploadBody = await req.arrayBuffer();
    }

    let archiveResp;
    try {
      archiveResp = await fetch(archiveUrl, {
        method: 'PUT',
        headers: archiveHeaders,
        body: uploadBody
      });

      if (!archiveResp.ok) {
        const errorText = await archiveResp.text().catch(() => 'Unknown error');
        console.error('Archive.org upload failed:', archiveResp.status, errorText);
        return json({
          error: 'Archive.org upload failed',
          status: archiveResp.status,
          details: errorText,
          stage: 'archive-upload'
        }, 502);
      }
      console.log('Archive.org upload successful, status:', archiveResp.status);
    } catch (archiveErr) {
      console.error('Archive.org upload network error:', archiveErr);
      return json({
        error: 'Failed to connect to Archive.org: ' + archiveErr.message,
        stage: 'archive-connect',
        details: archiveErr.message
      }, 502);
    }

    // Return Archive.org URLs
    const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;
    const embedUrl = `https://archive.org/details/${itemId}`;

    console.log('Upload complete - direct Archive.org upload successful');
    return json({
      success: true,
      url: downloadUrl,
      embedUrl: embedUrl,
      itemId: itemId,
      filename: filename,
      archiveVerified: true,
      isVideo: isVideoUpload
    });

  } catch (err) {
    console.error('Customer file upload error:', err);
    return json({
      error: 'Upload failed: ' + err.message,
      details: err.stack,
      stage: 'unknown'
    }, 500);
  }
}

/**
 * Upload file directly to Archive.org (NO R2, NO encryption)
 * Files are uploaded straight to Archive.org as public files
 */
export async function uploadEncryptedFile(env, req, url) {
  if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {
    console.error('Archive.org credentials not configured');
    return json({ error: 'Archive.org credentials not configured' }, 500);
  }

  const orderId = url.searchParams.get('orderId');
  const itemId = url.searchParams.get('itemId');
  const filename = url.searchParams.get('filename');

  if (!orderId || !itemId || !filename) {
    return json({ error: 'orderId, itemId and filename required' }, 400);
  }

  // Sanitize filename
  const sanitizedFilename = filename.replace(/[^a-zA-Z0-9_.-]/g, '-');

  // Construct Archive.org item ID: order_{orderId}_{itemId}
  const archiveItemId = `order_${orderId}_${itemId}`.replace(/[^a-zA-Z0-9_-]/g, '-');

  console.log('Uploading directly to Archive.org:', sanitizedFilename, 'Item:', archiveItemId);

  // Get content length for size validation
  const contentLength = req.headers.get('content-length');
  const fileSize = contentLength ? parseInt(contentLength, 10) : null;
  const maxSize = 500 * 1024 * 1024; // 500MB max

  if (fileSize !== null && fileSize > maxSize) {
    return json({ error: 'File too large. Maximum size is 500MB.' }, 400);
  }

  // Detect content type
  const contentType = resolveContentType(sanitizedFilename, req.headers.get('content-type'));
  const isVideoUpload = contentType.startsWith('video/');

  // Prepare Archive.org headers
  const archiveHeaders = {
    Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,
    'Content-Type': contentType,
    'x-archive-auto-make-bucket': '1',
    'x-archive-meta-mediatype': isVideoUpload ? 'movies' : 'data',
    'x-archive-meta-collection': 'opensource',
    'x-archive-meta-title': normalizeArchiveMetaValue(sanitizedFilename),
    'x-archive-meta-description': normalizeArchiveMetaValue(`Order #${orderId} - ${itemId}`),
    'x-archive-meta-subject': 'order; delivery',
    'x-archive-meta-language': 'eng'
  };

  // Upload directly to Archive.org
  const archiveUrl = `https://s3.us.archive.org/${archiveItemId}/${sanitizedFilename}`;

  // For large files, stream directly; otherwise buffer
  let uploadBody;
  if (fileSize !== null && fileSize > 50 * 1024 * 1024) {
    // Large file: stream directly (memory efficient)
    uploadBody = req.body;
  } else {
    // Small file: load into memory
    uploadBody = await req.arrayBuffer();
  }

  let archiveResp;
  try {
    archiveResp = await fetch(archiveUrl, {
      method: 'PUT',
      headers: archiveHeaders,
      body: uploadBody
    });

    if (!archiveResp.ok) {
      const errorText = await archiveResp.text().catch(() => 'Unknown error');
      console.error('Archive.org upload failed:', archiveResp.status, errorText);
      return json({
        error: 'Archive.org upload failed',
        status: archiveResp.status,
        details: errorText,
        stage: 'archive-upload'
      }, 502);
    }
    console.log('Archive.org upload successful, status:', archiveResp.status);
  } catch (archiveErr) {
    console.error('Archive.org upload network error:', archiveErr);
    return json({
      error: 'Failed to connect to Archive.org: ' + archiveErr.message,
      stage: 'archive-connect',
      details: archiveErr.message
    }, 502);
  }

  // Return Archive.org URLs
  const downloadUrl = `https://archive.org/download/${archiveItemId}/${sanitizedFilename}`;
  const embedUrl = `https://archive.org/details/${archiveItemId}`;

  console.log('Upload complete - direct Archive.org upload successful');
  return json({
    success: true,
    url: downloadUrl,
    embedUrl: embedUrl,
    itemId: archiveItemId,
    filename: sanitizedFilename,
    archiveVerified: true,
    isVideo: isVideoUpload
  });
}

/**
 * Resolve video URL to direct download link using Auto-Healing Cobalt API
 * Automatically rotates through fallback instances if primary fails
 */
async function resolveVideoUrl(env, url) {
  if (!url) return url;

  const lowerUrl = url.toLowerCase();

  // Check if this is a platform that needs resolution
  const needsResolution = (
    lowerUrl.includes('youtube.com') ||
    lowerUrl.includes('youtu.be') ||
    lowerUrl.includes('vimeo.com')
  );

  if (!needsResolution) {
    return url;
  }

  console.log('Resolving video URL:', url);

  // 1. Get current saved URL (or default)
  let currentApiUrl = 'https://api.cobalt.tools';
  try {
    const setting = await env.DB.prepare("SELECT value FROM settings WHERE key = 'cobalt_url'").first();
    if (setting?.value) currentApiUrl = setting.value;
  } catch (e) {
    console.log('Could not fetch cobalt_url setting, using default');
  }

  // Prepare list: Current Preferred + Fallbacks (removing duplicates)
  const candidates = [currentApiUrl, ...FALLBACK_INSTANCES.filter(u => u !== currentApiUrl)];

  // 2. Try instances one by one with Auto-Failover
  for (const apiUrl of candidates) {
    try {
      console.log(`Trying YouTube API: ${apiUrl}`);
      const apiRes = await fetch(`${apiUrl}/api/json`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0 (compatible; WishVideo/1.0)'
        },
        body: JSON.stringify({ url: url })
      });

      const data = await apiRes.json();

      // Success condition - any status with a valid url
      if (data.url || data.status === 'success' || data.status === 'stream') {
        const resolvedUrl = data.url;

        // If we had to switch to a fallback, save it as the new default (Self-Healing)
        if (apiUrl !== currentApiUrl) {
          console.log(`Updating default API to working instance: ${apiUrl}`);
          try {
            await env.DB.prepare("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)")
              .bind('cobalt_url', apiUrl)
              .run();
          } catch (dbErr) {
            console.error('Failed to update API setting:', dbErr);
          }
        }

        console.log('Cobalt resolved to:', resolvedUrl);
        return resolvedUrl;
      }

      // Check for error status
      if (data.status === 'error' || data.status === 'fail') {
        console.warn(`API Error (${apiUrl}):`, data.text || data.error || 'Unknown error');
      }
    } catch (e) {
      console.warn(`API Failed (${apiUrl}):`, e.message);
      // Continue to next candidate
    }
  }

  console.error('All Cobalt instances failed');
  return url; // Return original if all fail
}

/**
 * Handle secure download with force download headers
 * Supports YouTube/Vimeo via Cobalt API resolution
 */
export async function handleSecureDownload(env, orderId, baseUrl) {
  const order = await env.DB.prepare(
    'SELECT archive_url, delivered_video_url FROM orders WHERE order_id = ?'
  ).bind(orderId).first();

  let sourceUrl = (order?.delivered_video_url || order?.archive_url || '').toString().trim();

  if (!sourceUrl) {
    return new Response('Download link not found', { status: 404 });
  }

  console.log('Processing download for:', orderId, 'Source:', sourceUrl.substring(0, 80) + '...');

  // Resolve YouTube/Vimeo URLs to direct download links (using configurable API)
  const resolvedUrl = await resolveVideoUrl(env, sourceUrl);

  // If URL was resolved to a direct link, download it
  if (resolvedUrl !== sourceUrl) {
    console.log('Downloading from resolved URL:', resolvedUrl.substring(0, 80) + '...');
    sourceUrl = resolvedUrl;
  }

  // Fetch the file
  let fileResp;
  try {
    fileResp = await fetch(sourceUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
  } catch (e) {
    console.error('Fetch error:', e.message);
    return new Response('Failed to fetch file: ' + e.message, { status: 502 });
  }

  // If fetch failed, try redirecting to source
  if (!fileResp.ok) {
    console.log('Proxy failed (' + fileResp.status + '), redirecting to source...');
    return Response.redirect(sourceUrl, 302);
  }

  // Determine filename from URL
  const urlObj = new URL(sourceUrl, baseUrl);
  let filename = urlObj.pathname.split('/').pop() || 'video.mp4';

  // Clean filename - remove special chars, decode URI
  try {
    filename = decodeURIComponent(filename);
  } catch (_) {}
  filename = filename.replace(/[^a-zA-Z0-9._-]/g, '_');

  // Ensure file has extension
  if (!filename.includes('.')) {
    const ext = getExtensionFromContentType(fileResp.headers.get('content-type') || '');
    filename += ext;
  }

  // Get content type
  let contentType = fileResp.headers.get('content-type') || '';
  contentType = contentType.split(';')[0].trim() || getMimeTypeFromFilename(filename) || 'application/octet-stream';

  // Build response headers for force download
  const headers = new Headers({ ...CORS });

  // Handle range requests for large video files (seek support)
  const contentLength = fileResp.headers.get('content-length');
  const hasBody = fileResp.body;

  if (hasBody) {
    headers.set('Content-Type', contentType);
    headers.set('Content-Disposition', `attachment; filename="${filename}"`);
    headers.set('Content-Length', contentLength || '');
    headers.set('Accept-Ranges', 'bytes');
    headers.set('Cache-Control', 'private, no-cache, no-store, must-revalidate');
    headers.set('Pragma', 'no-cache');
    headers.set('Expires', '0');

    // Stream the response body
    return new Response(fileResp.body, {
      status: 206, // Partial Content for range support
      statusText: 'Partial Content',
      headers
    });
  }

  // Fallback for responses without body
  return Response.redirect(sourceUrl, 302);
}

/**
 * Get file extension from content type
 */
function getExtensionFromContentType(contentType) {
  const mimeToExt = {
    'video/mp4': '.mp4',
    'video/webm': '.webm',
    'video/quicktime': '.mov',
    'video/x-msvideo': '.avi',
    'video/x-matroska': '.mkv',
    'audio/mpeg': '.mp3',
    'audio/wav': '.wav',
    'audio/ogg': '.ogg',
    'image/jpeg': '.jpg',
    'image/png': '.png',
    'image/gif': '.gif',
    'image/webp': '.webp',
    'application/pdf': '.pdf',
    'application/zip': '.zip'
  };
  return mimeToExt[contentType] || '.mp4';
}

// In-memory branding cache
let brandingCache = null;
let brandingCacheTime = 0;
const BRANDING_CACHE_TTL = 300000; // 5 minutes

/**
 * Get site branding settings (logo, favicon)
 * OPTIMIZED: In-memory caching to reduce DB queries
 */
export async function getBrandingSettings(env) {
  const now = Date.now();
  
  // Return cached data if still valid
  if (brandingCache && (now - brandingCacheTime) < BRANDING_CACHE_TTL) {
    return json({ success: true, branding: brandingCache });
  }
  
  try {
    const row = await env.DB.prepare('SELECT value FROM settings WHERE key = ?').bind('site_branding').first();
    if (row?.value) {
      brandingCache = JSON.parse(row.value);
      brandingCacheTime = now;
      return json({ success: true, branding: brandingCache });
    }
    brandingCache = { logo_url: '', favicon_url: '' };
    brandingCacheTime = now;
    return json({ success: true, branding: brandingCache });
  } catch (e) {
    console.error('Get branding error:', e);
    return json({ success: true, branding: { logo_url: '', favicon_url: '' } });
  }
}

/**
 * Save site branding settings
 */
export async function saveBrandingSettings(env, body) {
  try {
    const branding = {
      logo_url: (body.logo_url || '').trim(),
      favicon_url: (body.favicon_url || '').trim(),
      updated_at: Date.now()
    };
    
    await env.DB.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)')
      .bind('site_branding', JSON.stringify(branding))
      .run();
    
    // Invalidate cache
    brandingCache = branding;
    brandingCacheTime = Date.now();
    
    return json({ success: true });
  } catch (e) {
    console.error('Save branding error:', e);
    return json({ error: e.message }, 500);
  }
}

// ========== COBALT API SETTINGS ==========

const cobaltCache = {};
const COBALT_CACHE_TTL = 60000; // 1 minute cache

/**
 * Get Cobalt API URL setting
 */
export async function getCobaltSettings(env) {
  const now = Date.now();

  // Return cached data if still valid
  if (cobaltCache.value && (now - cobaltCache.time) < COBALT_CACHE_TTL) {
    return json({ success: true, settings: { cobalt_url: cobaltCache.value } });
  }

  try {
    const row = await env.DB.prepare('SELECT value FROM settings WHERE key = ?').bind('cobalt_url').first();
    const value = row?.value || 'https://api.cobalt.tools';
    cobaltCache.value = value;
    cobaltCache.time = now;
    return json({ success: true, settings: { cobalt_url: value } });
  } catch (e) {
    console.error('Get cobalt settings error:', e);
    return json({ success: true, settings: { cobalt_url: 'https://api.cobalt.tools' } });
  }
}

/**
 * Save Cobalt API URL setting
 */
export async function saveCobaltSettings(env, body) {
  try {
    const value = (body.cobalt_url || 'https://api.cobalt.tools').trim();

    await env.DB.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)')
      .bind('cobalt_url', value)
      .run();

    // Update cache
    cobaltCache.value = value;
    cobaltCache.time = Date.now();

    return json({ success: true });
  } catch (e) {
    console.error('Save cobalt settings error:', e);
    return json({ error: e.message }, 500);
  }
}
