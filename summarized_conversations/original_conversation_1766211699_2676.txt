{'role': 'user', 'content': 'Act as a Senior Cloudflare Workers Architect. I need you to refactor my monolithic `worker.js` file into a professional, modular file structure using ES Modules.\r\n\r\n**ðŸš¨ STRICT RULES (DO NOT IGNORE):**\r\n1. **NO LOGIC LOSS:** Every single API endpoint, helper function, database query, and cron job trigger MUST be preserved. Do not summarize or skip "less important" parts.\r\n2. **ENV BINDINGS:** Ensure that the `env` object (containing `DB`, `R2_BUCKET`, `ASSETS`, `API_KEYS`) is correctly passed to all new modules/controllers.\r\n3. **ERROR HANDLING:** Maintain all try-catch blocks and error responses exactly as they are.\r\n4. **STATIC ASSETS:** The logic for serving static assets (`env.ASSETS.fetch`) and server-side schema injection MUST remain in the main entry point.\r\n\r\n**ðŸ“‚ Required Folder Structure:**\r\nPlease split the code into the following structure inside a `src/` folder:\r\n- `src/index.js` (Main entry point, router logic, `fetch` handler, and `scheduled` handler)\r\n- `src/utils/response.js` (CORS headers, `json()` helper, standard responses)\r\n- `src/utils/helpers.js` (Slugify, escapeHtml, mimeTypes, etc.)\r\n- `src/db/init.js` (Database initialization `initDB` and schema creation)\r\n- `src/controllers/products.js` (Product related APIs)\r\n- `src/controllers/orders.js` (Order creation, updates, delivery)\r\n- `src/controllers/reviews.js` (Reviews fetching and posting)\r\n- `src/controllers/chat.js` (Chat widget APIs)\r\n- `src/controllers/upload.js` (R2 and Archive.org upload logic)\r\n- `src/controllers/whop.js` (Whop integration and webhooks)\r\n- `src/controllers/admin.js` (Admin dashboard specific APIs like export/import)\r\n- `src/controllers/pages.js` (Page builder APIs)\r\n\r\n**ðŸ§ª PRE-OUTPUT TESTING REQUIREMENT:**\r\nBefore generating the code, perform a "Mental Sandbox Test":\r\n1. Trace the execution flow for a complex endpoint like `/api/order/create`.\r\n2. Verify that `env.DB` is accessible in the `orders.js` controller.\r\n3. Verify that helper functions like `slugifyStr` are correctly imported where needed.\r\n4. If you find any missing dependency or broken import during this mental test, FIX IT before outputting the code.\r\n\r\n**Output:**\r\nProvide the full, ready-to-copy code for each file and the updated `wrangler.toml` file configuration.\r\n\n\n[Uploaded File: /workspace/wishesu-price-from-checkoutbtn-fixed.zip]\n'}
{'role': 'assistant', 'content': "\nI'll help you refactor your monolithic Cloudflare Workers file into a professional modular structure. Let me first examine your current `worker.js` file to understand all the functionality that needs to be preserved.\n\n<function_calls>\n<execute-command>\ncd /workspace && unzip wishesu-price-from-checkoutbtn-fixed.zip\n</execute-command>\n</function_calls>"}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "Archive:  wishesu-price-from-checkoutbtn-fixed.zip\\\\n  inflating: wishesu-main/README.md  \\\\n  inflating: wishesu-main/package-lock.json  \\\\n  inflating: wishesu-main/package.json  \\\\n  inflating: wishesu-main/server.log  \\\\n  inflating: wishesu-main/wrangler.toml  \\\\n  inflating: wishesu-main/wrangler.toml.example  \\\\n  inflating: wishesu-main/worker.js  \\\\n  inflating: wishesu-main/public/buyer-order.html  \\\\n  inflating: wishesu-main/public/favicon.ico  \\\\n  inflating: wishesu-main/public/index.html  \\\\n  inflating: wishesu-main/public/order-detail.html  \\\\n  inflating: wishesu-main/public/order-success.html  \\\\n  inflating: wishesu-main/public/page-builder.html  \\\\n  inflating: wishesu-main/public/products-grid.html  \\\\n  inflating: wishesu-main/public/robots.txt  \\\\n  inflating: wishesu-main/public/success.html  \\\\n  inflating: wishesu-main/public/_product_template.tpl  \\\\n  inflating: wishesu-main/public/admin/dashboard.html  \\\\n  inflating: wishesu-main/public/admin/index.html  \\\\n  inflating: wishesu-main/public/admin/landing-builder.html  \\\\n  inflating: wishesu-main/public/admin/migrate-reviews.html  \\\\n  inflating: wishesu-main/public/admin/product-form.html  \\\\n  inflating: wishesu-main/public/css/admin-nav.css  \\\\n  inflating: wishesu-main/public/css/style.css  \\\\n  inflating: wishesu-main/public/css/whop.css  \\\\n  inflating: wishesu-main/public/js/api.js  \\\\n  inflating: wishesu-main/public/js/buyer-order.js  \\\\n  inflating: wishesu-main/public/js/chat-widget.js  \\\\n  inflating: wishesu-main/public/js/instant-upload.js  \\\\n  inflating: wishesu-main/public/js/order-detail.js  \\\\n  inflating: wishesu-main/public/js/page-list-widget.js  \\\\n  inflating: wishesu-main/public/js/product-addons.js  \\\\n  inflating: wishesu-main/public/js/product-cards.js  \\\\n  inflating: wishesu-main/public/js/product-form.js  \\\\n  inflating: wishesu-main/public/js/product-seo.js  \\\\n  inflating: wishesu-main/public/js/product.js  \\\\n  inflating: wishesu-main/public/js/products.js  \\\\n  inflating: wishesu-main/public/js/review-utils.js  \\\\n  inflating: wishesu-main/public/js/reviews-widget.js  \\\\n  inflating: wishesu-main/public/js/shared-timer-utils.js  \\\\n  inflating: wishesu-main/public/js/universal-player.js  \\\\n  inflating: wishesu-main/public/js/zero-refresh-countdown.js  \\\\n  inflating: wishesu-main/public/js/addons/builder.js  \\\\n  inflating: wishesu-main/public/js/addons/config.js  \\\\n  inflating: wishesu-main/public/js/addons/data.js  \\\\n  inflating: wishesu-main/public/js/addons/fields.js  \\\\n  inflating: wishesu-main/public/js/addons/utils.js  \\\\n  inflating: wishesu-main/public/js/admin/admin-orders.js  \\\\n  inflating: wishesu-main/public/js/admin/dashboard.js  \\\\n  inflating: wishesu-main/public/js/admin/orders.js  \\\\n  inflating: wishesu-main/public/js/admin/reviews.js  \\\\n  inflating: wishesu-main/public/js/admin/whop-settings.js  \\\\n  inflating: wishesu-main/public/js/product/addon-ui.js  \\\\n  inflating: wishesu-main/public/js/product/checkout.js  \\\\n  inflating: wishesu-main/public/js/product/layout-extra.js  \\\\n  inflating: wishesu-main/public/js/product/layout-main.js  \\\\n  inflating: wishesu-main/public/js/product/main.js  \\\\n  inflating: wishesu-main/public/js/product/seo-utils.js  \\\\n  inflating: wishesu-main/public/js/whop/checkout.js  \\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me examine the main `worker.js` file to understand the current structure:\n\n<function_calls>\n<see-excel file_path="wishesu-main/worker.js">\n</see-excel>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <see-excel> ToolResult(success=False, output="Unsupported or unknown excel file format for: \'wishesu-main/worker.js\'.") </see-excel> </tool_result>'}
{'role': 'assistant', 'content': '\nLet me read the worker.js file as a text file:\n\n<function_calls>\n<execute-command>\ncat wishesu-main/worker.js\n</execute-command>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "/**\\\\n * Complete Cloudflare Worker - All Features\\\\n * Version: Fixed with Number() conversions\\\\n */\\\\n\\\\n// The CORS and cache configuration for all API responses.\\\\nconst CORS = {\\\\n  \\\'Access-Control-Allow-Origin\\\': \\\'*\\\',\\\\n  \\\'Access-Control-Allow-Methods\\\': \\\'GET, POST, PUT, DELETE, OPTIONS\\\',\\\\n  \\\'Access-Control-Allow-Headers\\\': \\\'Content-Type\\\',\\\\n  \\\'Cache-Control\\\': \\\'no-store, no-cache, must-revalidate\\\',\\\\n  \\\'Pragma\\\': \\\'no-cache\\\'\\\\n};\\\\n\\\\n// A build/version identifier that can be set at publish time via environment\\\\n// variables.  If none is provided Wrangler will default to the current\\\\n// timestamp.  This value is returned via the `/api/debug` endpoint and\\\\n// embedded in a custom header on all static asset responses.  Use this\\\\n// identifier to verify that new versions of your worker and static assets\\\\n// are being served.  You can set VERSION in wrangler.toml under [vars].\\\\nconst VERSION = globalThis.VERSION || \\\\"15\\\\";\\\\n\\\\nfunction json(data, status = 200) {\\\\n  return new Response(JSON.stringify(data), {\\\\n    status,\\\\n    headers: { ...CORS, \\\'Content-Type\\\': \\\'application/json\\\' }\\\\n  });\\\\n}\\\\n\\\\n\\\\nfunction escapeHtml(input) {\\\\n  return String(input ?? \\\'\\\')\\\\n    .replaceAll(\\\'&\\\', \\\'&amp;\\\')\\\\n    .replaceAll(\\\'<\\\', \\\'&lt;\\\')\\\\n    .replaceAll(\\\'>\\\', \\\'&gt;\\\')\\\\n    .replaceAll(\\\'\\\\"\\\', \\\'&quot;\\\')\\\\n    .replaceAll(\\\\"\\\'\\\\", \\\'&#39;\\\');\\\\n}\\\\n\\\\nfunction normalizeQuickAction(text) {\\\\n  return String(text || \\\'\\\')\\\\n    .trim()\\\\n    .replace(/\\\\\\\\s+/g, \\\' \\\')\\\\n    .toLowerCase();\\\\n}\\\\n\\\\nasync function enforceUserRateLimit(env, sessionId) {\\\\n  const row = await env.DB.prepare(\\\\n    `SELECT strftime(\\\'%s\\\', created_at) AS ts\\\\n     FROM chat_messages\\\\n     WHERE session_id = ? AND role = \\\'user\\\'\\\\n     ORDER BY id DESC\\\\n     LIMIT 1`\\\\n  ).bind(sessionId).first();\\\\n\\\\n  if (!row?.ts) return;\\\\n\\\\n  const lastTs = Number(row.ts) || 0;\\\\n  const nowTs = Math.floor(Date.now() / 1000);\\\\n\\\\n  if (nowTs - lastTs < 1) {\\\\n    const err = new Error(\\\'Rate limited\\\');\\\\n    err.status = 429;\\\\n    throw err;\\\\n  }\\\\n}\\\\n\\\\nasync function getLatestOrderForEmail(env, email) {\\\\n  const candidates = await env.DB.prepare(\\\\n    `SELECT order_id, status, archive_url, encrypted_data, created_at\\\\n     FROM orders\\\\n     ORDER BY datetime(created_at) DESC\\\\n     LIMIT 80`\\\\n  ).all();\\\\n\\\\n  const list = candidates?.results || [];\\\\n  const target = String(email || \\\'\\\').trim().toLowerCase();\\\\n  if (!target) return null;\\\\n\\\\n  for (const o of list) {\\\\n    try {\\\\n      if (!o.encrypted_data) continue;\\\\n      const data = JSON.parse(o.encrypted_data);\\\\n      const e = String(data.email || \\\'\\\').trim().toLowerCase();\\\\n      if (e && e === target) {\\\\n        return {\\\\n          order_id: o.order_id,\\\\n          status: o.status,\\\\n          trackLink: `/buyer-order.html?id=${encodeURIComponent(o.order_id)}`\\\\n        };\\\\n      }\\\\n    } catch {}\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\\n\\\\nfunction getMimeTypeFromFilename(filename) {\\\\n  const ext = (filename || \\\'\\\').split(\\\'.\\\').pop()?.toLowerCase();\\\\n  switch (ext) {\\\\n    case \\\'mp4\\\':\\\\n      return \\\'video/mp4\\\';\\\\n    case \\\'webm\\\':\\\\n      return \\\'video/webm\\\';\\\\n    case \\\'mov\\\':\\\\n      return \\\'video/quicktime\\\';\\\\n    case \\\'m4v\\\':\\\\n      return \\\'video/x-m4v\\\';\\\\n    case \\\'mkv\\\':\\\\n      return \\\'video/x-matroska\\\';\\\\n    case \\\'avi\\\':\\\\n      return \\\'video/x-msvideo\\\';\\\\n    case \\\'wmv\\\':\\\\n      return \\\'video/x-ms-wmv\\\';\\\\n    case \\\'flv\\\':\\\\n      return \\\'video/x-flv\\\';\\\\n    case \\\'jpg\\\':\\\\n    case \\\'jpeg\\\':\\\\n      return \\\'image/jpeg\\\';\\\\n    case \\\'png\\\':\\\\n      return \\\'image/png\\\';\\\\n    case \\\'gif\\\':\\\\n      return \\\'image/gif\\\';\\\\n    case \\\'webp\\\':\\\\n      return \\\'image/webp\\\';\\\\n    case \\\'svg\\\':\\\\n      return \\\'image/svg+xml\\\';\\\\n    case \\\'pdf\\\':\\\\n      return \\\'application/pdf\\\';\\\\n    case \\\'zip\\\':\\\\n      return \\\'application/zip\\\';\\\\n    default:\\\\n      return \\\'\\\';\\\\n  }\\\\n}\\\\n\\\\nfunction resolveContentType(req, filename) {\\\\n  const headerContentType = (req.headers.get(\\\'content-type\\\') || \\\'\\\').split(\\\';\\\')[0].trim().toLowerCase();\\\\n  if (headerContentType && headerContentType !== \\\'application/octet-stream\\\') {\\\\n    return headerContentType;\\\\n  }\\\\n  return getMimeTypeFromFilename(filename) || headerContentType || \\\'application/octet-stream\\\';\\\\n}\\\\n\\\\nfunction normalizeArchiveMetaValue(value) {\\\\n  return (value || \\\'\\\').toString().replace(/[\\\\\\\\r\\\\\\\\n\\\\\\\\t]+/g, \\\' \\\').trim();\\\\n}\\\\n\\\\n// ========================================\\\\n// SLUG + CANONICAL PRODUCT URL HELPERS\\\\n// ========================================\\\\nfunction slugifyStr(input) {\\\\n  return String(input || \\\'\\\')\\\\n    .toLowerCase()\\\\n    .trim()\\\\n    .replace(/[\\\'\\\\"`]/g, \\\'\\\')\\\\n    .replace(/[^a-z0-9]+/g, \\\'-\\\')\\\\n    .replace(/^-+|-+$/g, \\\'\\\')\\\\n    .replace(/-+/g, \\\'-\\\');\\\\n}\\\\n\\\\nfunction canonicalProductPath(product) {\\\\n  const id = product && product.id != null ? String(product.id) : \\\'\\\';\\\\n  const slug = (product && product.slug) ? String(product.slug) : slugifyStr(product && product.title ? product.title : \\\'product\\\');\\\\n  return `/product-${id}/${encodeURIComponent(slug)}`;\\\\n}\\\\n\\\\n// ========================================\\\\n// SERVER-SIDE SCHEMA GENERATION FOR SEO\\\\n// ========================================\\\\n// These functions generate JSON-LD structured data server-side to prevent\\\\n// duplicate schema issues and improve SEO performance. Schemas are injected\\\\n// directly into HTML before it\\\'s sent to the client.\\\\n\\\\n/**\\\\n * Helper function to generate Offer object for Product schemas\\\\n * @param {Object} product - Product data\\\\n * @param {string} baseUrl - Site base URL\\\\n * @returns {Object} Offer schema\\\\n */\\\\nfunction generateOfferObject(product, baseUrl) {\\\\n  const price = parseFloat(product.sale_price || product.normal_price || 0);\\\\n  const date = new Date();\\\\n  date.setFullYear(date.getFullYear() + 1);\\\\n  const priceValidUntil = date.toISOString().split(\\\'T\\\')[0];\\\\n  \\\\n  // Check if product is digital (instant_delivery = 1 means digital/no shipping)\\\\n  const isDigital = product.instant_delivery === 1;\\\\n\\\\n  const offer = {\\\\n    \\\\"@type\\\\": \\\\"Offer\\\\",\\\\n    \\\\"url\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n    \\\\"priceCurrency\\\\": \\\\"USD\\\\",\\\\n    \\\\"price\\\\": price.toString(),\\\\n    \\\\"availability\\\\": \\\\"https://schema.org/InStock\\\\",\\\\n    \\\\"itemCondition\\\\": \\\\"https://schema.org/NewCondition\\\\",\\\\n    \\\\"priceValidUntil\\\\": priceValidUntil,\\\\n    \\\\"seller\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Organization\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\"\\\\n    }\\\\n  };\\\\n\\\\n  // Only add shipping details for physical products (non-digital)\\\\n  if (!isDigital) {\\\\n    offer.shippingDetails = {\\\\n      \\\\"@type\\\\": \\\\"OfferShippingDetails\\\\",\\\\n      \\\\"shippingDestination\\\\": [\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"US\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"GB\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"CA\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"AU\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"DE\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"FR\\\\"\\\\n        }\\\\n      ],\\\\n      \\\\"shippingRate\\\\": {\\\\n        \\\\"@type\\\\": \\\\"MonetaryAmount\\\\",\\\\n        \\\\"currency\\\\": \\\\"USD\\\\",\\\\n        \\\\"value\\\\": \\\\"0\\\\"\\\\n      },\\\\n      \\\\"deliveryTime\\\\": {\\\\n        \\\\"@type\\\\": \\\\"ShippingDeliveryTime\\\\",\\\\n        \\\\"handlingTime\\\\": {\\\\n          \\\\"@type\\\\": \\\\"QuantitativeValue\\\\",\\\\n          \\\\"minValue\\\\": 0,\\\\n          \\\\"maxValue\\\\": 1,\\\\n          \\\\"unitCode\\\\": \\\\"DAY\\\\"\\\\n        },\\\\n        \\\\"transitTime\\\\": {\\\\n          \\\\"@type\\\\": \\\\"QuantitativeValue\\\\",\\\\n          \\\\"minValue\\\\": 1,\\\\n          \\\\"maxValue\\\\": 3,\\\\n          \\\\"unitCode\\\\": \\\\"DAY\\\\"\\\\n        }\\\\n      }\\\\n    };\\\\n    \\\\n    offer.hasMerchantReturnPolicy = {\\\\n      \\\\"@type\\\\": \\\\"MerchantReturnPolicy\\\\",\\\\n      \\\\"applicableCountry\\\\": \\\\"US\\\\",\\\\n      \\\\"returnPolicyCategory\\\\": \\\\"MerchantReturnNotPermitted\\\\",\\\\n      \\\\"merchantReturnDays\\\\": 0\\\\n    };\\\\n  }\\\\n\\\\n  return offer;\\\\n}\\\\n\\\\n/**\\\\n * Generate Product schema for individual product pages\\\\n * @param {Object} product - Product data from database\\\\n * @param {string} baseUrl - Site base URL\\\\n * @param {Array} reviews - Individual reviews for this product\\\\n * @returns {string} JSON-LD schema as string\\\\n */\\\\nfunction generateProductSchema(product, baseUrl, reviews = []) {\\\\n  const sku = product.slug ? `WV-${product.id}-${product.slug.toUpperCase().replace(/-/g, \\\'\\\')}` : `WV-${product.id}`;\\\\n\\\\n  const schema = {\\\\n    \\\\"@context\\\\": \\\\"https://schema.org/\\\\",\\\\n    \\\\"@type\\\\": \\\\"Product\\\\",\\\\n    \\\\"@id\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n    \\\\"name\\\\": product.title,\\\\n    \\\\"description\\\\": product.seo_description || product.description || product.title,\\\\n    \\\\"sku\\\\": sku,\\\\n    \\\\"mpn\\\\": sku,\\\\n    \\\\"image\\\\": product.thumbnail_url ? [product.thumbnail_url] : [],\\\\n    \\\\"brand\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Brand\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\",\\\\n      \\\\"logo\\\\": `${baseUrl}/favicon.ico`\\\\n    },\\\\n    \\\\"manufacturer\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Organization\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\",\\\\n      \\\\"url\\\\": baseUrl\\\\n    },\\\\n    \\\\"category\\\\": \\\\"Digital Goods > Personalized Videos\\\\",\\\\n    \\\\"offers\\\\": generateOfferObject(product, baseUrl)\\\\n  };\\\\n\\\\n   // Add aggregateRating (always present, even with 0 reviews for better Rich Results)\\\\n   schema.aggregateRating = {\\\\n     \\\\"@type\\\\": \\\\"AggregateRating\\\\",\\\\n     \\\\"ratingValue\\\\": parseFloat(product.rating_average) || 5.0,\\\\n     \\\\"reviewCount\\\\": Math.max(1, parseInt(product.review_count) || 1),\\\\n     \\\\"bestRating\\\\": 5,\\\\n     \\\\"worstRating\\\\": 1\\\\n   };\\\\n\\\\n   // Add individual reviews (first 5 for Rich Results)\\\\n   if (reviews && reviews.length > 0) {\\\\n     const limitedReviews = reviews.slice(0, 5);\\\\n     schema.review = limitedReviews.map(review => ({\\\\n      \\\\"@type\\\\": \\\\"Review\\\\",\\\\n      \\\\"reviewRating\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Rating\\\\",\\\\n        \\\\"ratingValue\\\\": review.rating,\\\\n        \\\\"bestRating\\\\": 5,\\\\n        \\\\"worstRating\\\\": 1\\\\n      },\\\\n      \\\\"author\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Person\\\\",\\\\n        \\\\"name\\\\": review.author_name || \\\\"Customer\\\\"\\\\n      },\\\\n      \\\\"reviewBody\\\\": review.comment || \\\\"\\\\",\\\\n      \\\\"datePublished\\\\": review.created_at ? new Date(review.created_at).toISOString().split(\\\'T\\\')[0] : new Date().toISOString().split(\\\'T\\\')[0]\\\\n    }));\\\\n  }\\\\n\\\\n  return JSON.stringify(schema);\\\\n}\\\\n\\\\n/**\\\\n * Generate ItemList schema for product collection pages\\\\n * @param {Array} products - Array of product data\\\\n * @param {string} baseUrl - Site base URL\\\\n * @returns {string} JSON-LD schema as string\\\\n */\\\\nfunction generateCollectionSchema(products, baseUrl) {\\\\n  if (!products || products.length === 0) {\\\\n    return \\\'{}\\\';\\\\n  }\\\\n\\\\n  const itemListElement = products.map((product, index) => {\\\\n    const item = {\\\\n      \\\\"@type\\\\": \\\\"ListItem\\\\",\\\\n      \\\\"position\\\\": index + 1,\\\\n      \\\\"url\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n      \\\\"item\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Product\\\\",\\\\n        \\\\"@id\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n        \\\\"name\\\\": product.title,\\\\n        \\\\"description\\\\": product.description || product.title,\\\\n        \\\\"image\\\\": product.thumbnail_url || `${baseUrl}/placeholder.jpg`,\\\\n        \\\\"brand\\\\": {\\\\n          \\\\"@type\\\\": \\\\"Brand\\\\",\\\\n          \\\\"name\\\\": \\\\"WishVideo\\\\"\\\\n        },\\\\n        \\\\"offers\\\\": generateOfferObject(product, baseUrl)\\\\n      }\\\\n    };\\\\n\\\\n    // Add aggregateRating (always present for better Rich Results)\\\\n    item.item.aggregateRating = {\\\\n      \\\\"@type\\\\": \\\\"AggregateRating\\\\",\\\\n      \\\\"ratingValue\\\\": parseFloat(product.rating_average) || 5.0,\\\\n      \\\\"reviewCount\\\\": Math.max(1, parseInt(product.review_count) || 1),\\\\n      \\\\"bestRating\\\\": 5,\\\\n      \\\\"worstRating\\\\": 1\\\\n    };\\\\n\\\\n    return item;\\\\n  });\\\\n\\\\n  const schema = {\\\\n    \\\\"@context\\\\": \\\\"https://schema.org/\\\\",\\\\n    \\\\"@type\\\\": \\\\"ItemList\\\\",\\\\n    \\\\"itemListElement\\\\": itemListElement\\\\n  };\\\\n\\\\n  return JSON.stringify(schema);\\\\n}\\\\n\\\\n/**\\\\n * Inject schema into HTML by replacing placeholder\\\\n * @param {string} html - Original HTML content\\\\n * @param {string} schemaId - ID of schema tag (product-schema or collection-schema)\\\\n * @param {string} schemaJson - JSON-LD schema string\\\\n * @returns {string} Modified HTML with schema injected\\\\n */\\\\nfunction injectSchemaIntoHTML(html, schemaId, schemaJson) {\\\\n  // Replace empty schema placeholder with actual data\\\\n  const placeholder = `<script type=\\\\"application/ld+json\\\\" id=\\\\"${schemaId}\\\\">{}</script>`;\\\\n  const replacement = `<script type=\\\\"application/ld+json\\\\" id=\\\\"${schemaId}\\\\">${schemaJson}</script>`;\\\\n  return html.replace(placeholder, replacement);\\\\n}\\\\n\\\\nlet dbReady = false;\\\\n\\\\n// Internal flag used to ensure the automatic cache purge check only runs\\\\n// once per worker instance.  Without this, every request would attempt to\\\\n// read from the database to determine if a purge is needed, which can\\\\n// unnecessarily slow down static asset delivery.  Once `maybePurgeCache`\\\\n// runs for the first time, this flag is set to true and subsequent calls\\\\n// will immediately return.\\\\nlet purgeVersionChecked = false;\\\\n\\\\nasync function initDB(env) {\\\\n  if (dbReady || !env.DB) return;\\\\n  \\\\n  try {\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS products (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        title TEXT, slug TEXT, description TEXT,\\\\n        normal_price REAL, sale_price REAL,\\\\n        instant_delivery INTEGER DEFAULT 0,\\\\n        normal_delivery_text TEXT,\\\\n        thumbnail_url TEXT, video_url TEXT,\\\\n        gallery_images TEXT,\\\\n        addons_json TEXT,\\\\n        seo_title TEXT, seo_description TEXT, seo_keywords TEXT, seo_canonical TEXT,\\\\n        whop_plan TEXT, whop_price_map TEXT,\\\\n        whop_product_id TEXT,\\\\n        status TEXT DEFAULT \\\'active\\\',\\\\n        sort_order INTEGER DEFAULT 0\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add gallery_images column to existing products table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT gallery_images FROM products LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding gallery_images column to products table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE products ADD COLUMN gallery_images TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS orders (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        order_id TEXT UNIQUE, product_id INTEGER,\\\\n        encrypted_data TEXT, iv TEXT,\\\\n        archive_url TEXT, archive_data TEXT,\\\\n        status TEXT DEFAULT \\\'pending\\\',\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT,\\\\n        delivered_video_metadata TEXT,\\\\n        portfolio_enabled INTEGER DEFAULT 1,\\\\n        delivered_at DATETIME,\\\\n        delivery_time_minutes INTEGER DEFAULT 60,\\\\n        revision_count INTEGER DEFAULT 0,\\\\n        revision_requested INTEGER DEFAULT 0\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add delivered_video_metadata column to existing orders table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT delivered_video_metadata FROM orders LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding delivered_video_metadata column to orders table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE orders ADD COLUMN delivered_video_metadata TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS reviews (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        product_id INTEGER, author_name TEXT, rating INTEGER, comment TEXT,\\\\n        status TEXT DEFAULT \\\'approved\\\',\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        order_id TEXT, show_on_product INTEGER DEFAULT 1,\\\\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT\\\\n      )\\\\n    `).run();\\\\n    \\\\n    // Auto-migration: Add delivery columns if missing\\\\n    try {\\\\n      const tableInfo = await env.DB.prepare(`PRAGMA table_info(reviews)`).all();\\\\n      const columns = tableInfo.results.map(col => col.name);\\\\n      if (!columns.includes(\\\'delivered_video_url\\\')) {\\\\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_video_url TEXT`).run();\\\\n      }\\\\n      if (!columns.includes(\\\'delivered_thumbnail_url\\\')) {\\\\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_thumbnail_url TEXT`).run();\\\\n      }\\\\n    } catch (e) { /* ignore */ }\\\\n\\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT)`).run();\\\\n    \\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS pages (\\\\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n      slug TEXT UNIQUE, title TEXT, content TEXT,\\\\n      meta_description TEXT, status TEXT DEFAULT \\\'published\\\',\\\\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\\\\n    )`).run();\\\\n\\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS checkout_sessions (\\\\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n      checkout_id TEXT UNIQUE,\\\\n      product_id INTEGER,\\\\n      plan_id TEXT,\\\\n      expires_at DATETIME,\\\\n      status TEXT DEFAULT \\\'pending\\\',\\\\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n      completed_at DATETIME\\\\n    )`).run();\\\\n\\\\n    \\\\n    // Chat tables\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS chat_sessions (\\\\n        id TEXT PRIMARY KEY,\\\\n        name TEXT NOT NULL,\\\\n        email TEXT NOT NULL,\\\\n        blocked INTEGER DEFAULT 0,\\\\n        last_message_content TEXT,\\\\n        last_message_at DATETIME,\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add blocked column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT blocked FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding blocked column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN blocked INTEGER DEFAULT 0\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n    // Add last_message_content column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT last_message_content FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding last_message_content column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN last_message_content TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    // Add last_message_at column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT last_message_at FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding last_message_at column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN last_message_at DATETIME\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS chat_messages (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        session_id TEXT NOT NULL,\\\\n        role TEXT NOT NULL,\\\\n        content TEXT NOT NULL,\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        FOREIGN KEY (session_id) REFERENCES chat_sessions(id)\\\\n      )\\\\n    `).run();\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id_id\\\\n      ON chat_messages(session_id, id)\\\\n    `).run();\\\\n\\\\ndbReady = true;\\\\n  } catch (e) {\\\\n    console.error(\\\'DB init error:\\\', e);\\\\n  }\\\\n}\\\\n\\\\n/*\\\\n * Automatically purge Cloudflare\\\'s edge cache when a new version of the\\\\n * worker is deployed.  On the first request of a new deployment, this\\\\n * function checks a value in the settings table (`last_purge_version`). If\\\\n * it differs from the current VERSION, the worker will call the Cloudflare\\\\n * API to purge all cached assets for the configured zone.  This ensures\\\\n * that outdated static assets are never served from the edge when a new\\\\n * version is published.  To enable this feature, define `CF_ZONE_ID` and\\\\n * `CF_API_TOKEN` in your wrangler.toml or via secrets.  The purge will\\\\n * silently skip if those variables are missing.\\\\n */\\\\nasync function maybePurgeCache(env) {\\\\n  // Only purge if we have the necessary bindings and tokens\\\\n  if (!env || !env.DB || !env.CF_ZONE_ID || !env.CF_API_TOKEN) return;\\\\n  // If we\\\'ve already performed this check during the lifetime of this\\\\n  // worker instance, skip further processing to avoid repeated DB calls.\\\\n  if (purgeVersionChecked) return;\\\\n  try {\\\\n    // Ensure the database schema exists\\\\n    await initDB(env);\\\\n    // Fetch the last version that triggered a purge\\\\n    let row = null;\\\\n    try {\\\\n      row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'last_purge_version\\\').first();\\\\n    } catch (_) {\\\\n      // Table might not exist; ignore\\\\n    }\\\\n    const lastVersion = row && row.value ? row.value.toString() : null;\\\\n    const currentVersion = VERSION.toString();\\\\n    if (lastVersion === currentVersion) {\\\\n      // Mark that we\\\'ve checked this version; no need to re-check on future requests\\\\n      purgeVersionChecked = true;\\\\n      return; // Already purged for this version\\\\n    }\\\\n    // Call Cloudflare API to purge everything\\\\n    const zoneId = env.CF_ZONE_ID;\\\\n    const token = env.CF_API_TOKEN;\\\\n    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\\\\n    const response = await fetch(purgeUrl, {\\\\n      method: \\\'POST\\\',\\\\n      headers: {\\\\n        \\\'Authorization\\\': `Bearer ${token}`,\\\\n        \\\'Content-Type\\\': \\\'application/json\\\'\\\\n      },\\\\n      body: JSON.stringify({ purge_everything: true })\\\\n    });\\\\n    // Even if the purge fails, we update the version to avoid repeated attempts\\\\n    await env.DB.prepare(\\\\n      \\\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\\\'\\\\n    ).bind(\\\'last_purge_version\\\', currentVersion).run();\\\\n    // Set the flag to avoid repeated attempts in this instance\\\\n    purgeVersionChecked = true;\\\\n    if (!response.ok) {\\\\n      const text = await response.text();\\\\n      console.warn(\\\'Cache purge request failed:\\\', text);\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'maybePurgeCache error:\\\', e);\\\\n  }\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Whop API key.\\\\n * First checks database settings (from admin panel), then falls back to env variable.\\\\n * This allows users to configure API key via admin UI.\\\\n */\\\\nasync function getWhopApiKey(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.api_key) {\\\\n          return settings.api_key;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'Error reading API key from database:\\\', e);\\\\n  }\\\\n  // Fallback to environment variable\\\\n  return env.WHOP_API_KEY || null;\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Whop webhook secret.\\\\n * First checks database settings, then falls back to env variable.\\\\n */\\\\nasync function getWhopWebhookSecret(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.webhook_secret) {\\\\n          return settings.webhook_secret;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'Error reading webhook secret from database:\\\', e);\\\\n  }\\\\n  // Fallback to environment variable\\\\n  return env.WHOP_WEBHOOK_SECRET || null;\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Google Apps Script URL for email webhooks.\\\\n * Retrieves from database settings.\\\\n */\\\\nasync function getGoogleScriptUrl(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.google_webapp_url) {\\\\n          return settings.google_webapp_url;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.warn(\\\'Error reading Google Script URL from database:\\\', e);\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\\nexport default {\\\\n  async fetch(req, env) {\\\\n    const url = new URL(req.url);\\\\n    // Normalize the request path.  Collapse multiple consecutive slashes\\\\n    // into a single slash (e.g. //api/debug -> /api/debug) to avoid\\\\n    // accidental 404s or redirect loops when users include double\\\\n    // slashes in the URL.\\\\u3010979016842149196\\\\u2020L0-L1\\\\u3011\\\\n    let path = url.pathname.replace(/\\\\\\\\/+/g, \\\'/\\\');\\\\n    if (!path.startsWith(\\\'/\\\')) {\\\\n      path = \\\'/\\\' + path;\\\\n    }\\\\n    const method = req.method;\\\\n\\\\n    // Before processing any request, trigger a cache purge if this is the\\\\n    // first request on a new version.  The purge will run only once per\\\\n    // deployment and only if the necessary environment variables are set.\\\\n    // Only run cache purge checks for admin surfaces or webhook calls (avoid DB hits for every customer page view)\\\\n    const shouldPurgeCache = path.startsWith(\\\'/admin/\\\') || path.startsWith(\\\'/api/admin/\\\') || path.startsWith(\\\'/api/whop/webhook\\\');\\\\n    if (shouldPurgeCache) {\\\\n      await maybePurgeCache(env);\\\\n    }\\\\n\\\\n    if (method === \\\'OPTIONS\\\') {\\\\n      return new Response(null, { headers: CORS });\\\\n    }\\\\n\\\\n    try {\\\\n      if (path === \\\'/api/health\\\') {\\\\n        return json({ ok: true, time: Date.now() });\\\\n      }\\\\n\\\\n      // Server time endpoint for accurate countdown calculations\\\\n      if (path === \\\'/api/time\\\') {\\\\n        return json({ serverTime: Date.now() });\\\\n      }\\\\n\\\\n      // Private asset: never serve the raw product template directly\\\\n      if ((method === \\\'GET\\\' || method === \\\'HEAD\\\') && (path === \\\'/_product_template.tpl\\\' || path === \\\'/_product_template\\\' || path === \\\'/_product_template.html\\\')) {\\\\n        return new Response(\\\'Not found\\\', { status: 404 });\\\\n      }\\\\n\\\\n\\\\n\\\\n      // ------------------------------\\\\n      // Canonical product URLs\\\\n      // ------------------------------\\\\n      // We keep supporting legacy /product?id=123 but we canonicalize to:\\\\n      //   /product-123/<slug>\\\\n      // We also support old pretty URLs /product/<slug> by redirecting to the\\\\n      // canonical form to ensure the product page always has the numeric ID.\\\\n      if ((method === \\\'GET\\\' || method === \\\'HEAD\\\') && (path === \\\'/product\\\' || path.startsWith(\\\'/product/\\\'))) {\\\\n        if (!env.DB) {\\\\n          // If DB is not configured, fall through to assets (will likely 404).\\\\n        } else {\\\\n          await initDB(env);\\\\n\\\\n          // Block direct access to the private template asset from the public internet.\\\\n          if (path === \\\'/_product_template.tpl\\\') {\\\\n            return new Response(\\\'Not found\\\', { status: 404 });\\\\n          }\\\\n\\\\n          // Legacy: /product?id=123  ->  /product-123/<slug>\\\\n          const legacyId = (path === \\\'/product\\\') ? url.searchParams.get(\\\'id\\\') : null;\\\\n          if (legacyId) {\\\\n            const p = await env.DB.prepare(\\\'SELECT id, title, slug FROM products WHERE id = ? LIMIT 1\\\').bind(Number(legacyId)).first();\\\\n            if (p) {\\\\n              const slug = p.slug ? String(p.slug) : slugifyStr(p.title);\\\\n              // Backfill slug if missing\\\\n              if (!p.slug) {\\\\n                try {\\\\n                  await env.DB.prepare(\\\'UPDATE products SET slug = ? WHERE id = ?\\\').bind(slug, Number(p.id)).run();\\\\n                } catch (e) {}\\\\n              }\\\\n              const canonical = `/product-${p.id}/${encodeURIComponent(slug)}`;\\\\n              return Response.redirect(`${url.origin}${canonical}`, 301);\\\\n            }\\\\n          }\\\\n\\\\n          // Old pretty: /product/<slug>  ->  /product-<id>/<slug>\\\\n          if (path.startsWith(\\\'/product/\\\') && path.length > \\\'/product/\\\'.length) {\\\\n            const slugIn = decodeURIComponent(path.slice(\\\'/product/\\\'.length));\\\\n            const row = await env.DB.prepare(\\\'SELECT id, title, slug FROM products WHERE slug = ? LIMIT 1\\\').bind(slugIn).first();\\\\n            if (row) {\\\\n              const canonicalSlug = row.slug ? String(row.slug) : slugifyStr(row.title);\\\\n              if (!row.slug) {\\\\n                try {\\\\n                  await env.DB.prepare(\\\'UPDATE products SET slug = ? WHERE id = ?\\\').bind(canonicalSlug, Number(row.id)).run();\\\\n                } catch (e) {}\\\\n              }\\\\n              const canonical = `/product-${row.id}/${encodeURIComponent(canonicalSlug)}`;\\\\n              return Response.redirect(`${url.origin}${canonical}`, 301);\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      // ------------------------------\\\\n      // Chat APIs (Customer + Admin)\\\\n      // ------------------------------\\\\n      if (path === \\\'/api/chat/start\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const nameIn = String(body.name || \\\'\\\').trim();\\\\n        const emailIn = String(body.email || \\\'\\\').trim();\\\\n\\\\n        if (!nameIn || !emailIn) return json({ error: \\\'Name and email are required\\\' }, 400);\\\\n\\\\n        // Basic normalization\\\\n        const email = emailIn.toLowerCase();\\\\n        const name = nameIn;\\\\n\\\\n        // One email = one session (reuse + cleanup)\\\\n        const canonical = await env.DB.prepare(\\\\n          `SELECT id, name, created_at\\\\n           FROM chat_sessions\\\\n           WHERE lower(email) = lower(?)\\\\n           ORDER BY datetime(created_at) ASC\\\\n           LIMIT 1`\\\\n        ).bind(email).first();\\\\n\\\\n        if (canonical?.id) {\\\\n          const canonicalId = String(canonical.id);\\\\n\\\\n          // Update name if it changed (optional but keeps admin tidy)\\\\n          if (name && canonical.name !== name) {\\\\n            await env.DB.prepare(\\\\n              `UPDATE chat_sessions SET name = ? WHERE id = ?`\\\\n            ).bind(name, canonicalId).run();\\\\n          }\\\\n\\\\n          // Migrate any stray sessions/messages for this email into the canonical session\\\\n          const others = await env.DB.prepare(\\\\n            `SELECT id FROM chat_sessions\\\\n             WHERE lower(email) = lower(?) AND id != ?`\\\\n          ).bind(email, canonicalId).all();\\\\n\\\\n          const otherIds = (others?.results || []).map(r => String(r.id));\\\\n          for (const sid of otherIds) {\\\\n            await env.DB.prepare(\\\\n              `UPDATE chat_messages SET session_id = ? WHERE session_id = ?`\\\\n            ).bind(canonicalId, sid).run();\\\\n\\\\n            await env.DB.prepare(\\\\n              `DELETE FROM chat_sessions WHERE id = ?`\\\\n            ).bind(sid).run();\\\\n          }\\\\n\\\\n          return json({ sessionId: canonicalId, reused: true });\\\\n        }\\\\n\\\\n        // Create new session\\\\n        const sessionId = crypto.randomUUID();\\\\n\\\\n        await env.DB.prepare(\\\\n          `INSERT INTO chat_sessions (id, name, email) VALUES (?, ?, ?)`\\\\n        ).bind(sessionId, escapeHtml(name), escapeHtml(email)).run();\\\\n\\\\n        return json({ sessionId, reused: false });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/chat/sync\\\' && method === \\\'GET\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        const sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n        const sinceIdRaw = url.searchParams.get(\\\'sinceId\\\') || \\\'0\\\';\\\\n        const sinceId = Number(sinceIdRaw) || 0;\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        const rows = await env.DB.prepare(\\\\n          `SELECT id, role, content, created_at\\\\n           FROM chat_messages\\\\n           WHERE session_id = ? AND id > ?\\\\n           ORDER BY id ASC\\\\n           LIMIT 100`\\\\n        ).bind(sessionId, sinceId).all();\\\\n\\\\n        const messages = rows?.results || [];\\\\n        const lastId = messages.length ? messages[messages.length - 1].id : sinceId;\\\\n\\\\n        return json({ messages, lastId });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/chat/send\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        const roleRaw = String(body.role || \\\'user\\\').trim().toLowerCase();\\\\n\\\\n        // accept content or message\\\\n        const rawContent = String(body.content ?? body.message ?? \\\'\\\');\\\\n\\\\n        const role = [\\\'user\\\', \\\'admin\\\', \\\'system\\\'].includes(roleRaw) ? roleRaw : \\\'user\\\';\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        // Strict blocking: do not allow blocked sessions to send customer messages\\\\n        const sess = await env.DB.prepare(\\\\n          `SELECT blocked FROM chat_sessions WHERE id = ?`\\\\n        ).bind(sessionId).first();\\\\n\\\\n        if (role === \\\'user\\\' && Number(sess?.blocked || 0) === 1) {\\\\n          return json({ success: false, error: \\\\"You have been blocked by support.\\\\" }, 403);\\\\n        }\\\\n\\\\n        const trimmed = rawContent.trim();\\\\n        if (!trimmed) return json({ error: \\\'content is required\\\' }, 400);\\\\n\\\\n        // 500 char limit (backend)\\\\n        if (trimmed.length > 500) return json({ error: \\\'Message too long (max 500 characters)\\\' }, 400);\\\\n\\\\n        // Rate limit customers only (1 msg/sec)\\\\n        try {\\\\n          if (role === \\\'user\\\') await enforceUserRateLimit(env, sessionId);\\\\n        } catch (e) {\\\\n          if (e?.status === 429) return json({ error: \\\'Too many messages. Please wait a moment.\\\' }, 429);\\\\n          throw e;\\\\n        }\\\\n\\\\n        // Determine if this is the user\\\'s first message BEFORE inserting\\\\n        let isFirstUserMessage = false;\\\\n        if (role === \\\'user\\\') {\\\\n          const countRow = await env.DB.prepare(\\\\n            `SELECT COUNT(*) as c\\\\n             FROM chat_messages\\\\n             WHERE session_id = ? AND role = \\\'user\\\'`\\\\n          ).bind(sessionId).first();\\\\n          isFirstUserMessage = Number(countRow?.c || 0) === 0;\\\\n        }\\\\n\\\\n        // XSS protection: escape before storing\\\\n        const safeContent = escapeHtml(trimmed);\\\\n\\\\n        const insertRes = await env.DB.prepare(\\\\n          `INSERT INTO chat_messages (session_id, role, content) VALUES (?, ?, ?)`\\\\n        ).bind(sessionId, role, safeContent).run();\\\\n\\\\n        // Update denormalized last-message fields for fast admin listing\\\\n        try {\\\\n          await env.DB.prepare(\\\\n            `UPDATE chat_sessions\\\\n             SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n             WHERE id = ?`\\\\n          ).bind(safeContent, sessionId).run();\\\\n        } catch (e) {\\\\n          console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n        }\\\\n\\\\n        // Trigger email alert webhook on first customer message\\\\n        if (isFirstUserMessage) {\\\\n          try {\\\\n            const setting = await env.DB.prepare(\\\\n              `SELECT value FROM settings WHERE key = ?`\\\\n            ).bind(\\\'GOOGLE_SCRIPT_URL\\\').first();\\\\n\\\\n            const scriptUrl = String(setting?.value || \\\'\\\').trim();\\\\n\\\\n            if (scriptUrl) {\\\\n              const session = await env.DB.prepare(\\\\n                `SELECT id, name, email, created_at FROM chat_sessions WHERE id = ?`\\\\n              ).bind(sessionId).first();\\\\n\\\\n              await fetch(scriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'first_customer_message\\\',\\\\n                  sessionId,\\\\n                  name: session?.name || null,\\\\n                  email: session?.email || null,\\\\n                  created_at: session?.created_at || null,\\\\n                  message: trimmed\\\\n                })\\\\n              });\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(\\\'Chat webhook trigger failed:\\\', e);\\\\n          }\\\\n        }\\\\n\\\\n        // ------------------------------\\\\n        // Smart Quick Action Auto-Replies\\\\n        // ------------------------------\\\\n        if (role === \\\'user\\\') {\\\\n          const normalized = normalizeQuickAction(trimmed);\\\\n          const session = await env.DB.prepare(\\\\n            `SELECT email FROM chat_sessions WHERE id = ?`\\\\n          ).bind(sessionId).first();\\\\n\\\\n          const email = String(session?.email || \\\'\\\').trim();\\\\n          const origin = new URL(req.url).origin;\\\\n\\\\n          // \\\\"My Order Status\\\\"\\\\n          if (normalized === \\\'my order status\\\') {\\\\n            let replyText = \\\\"We couldn\\\'t find any recent orders for this email.\\\\";\\\\n\\\\n            if (email) {\\\\n              const lastOrder = await getLatestOrderForEmail(env, email);\\\\n              if (lastOrder) {\\\\n                const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\\\\n                replyText = `Your last order #${lastOrder.order_id} is currently ${lastOrder.status || \\\'unknown\\\'}. Track it here: ${link}`;\\\\n              }\\\\n            }\\\\n\\\\n            const safeReply = escapeHtml(replyText);\\\\n            await env.DB.prepare(\\\\n              `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \\\'system\\\', ?)`\\\\n            ).bind(sessionId, safeReply).run();\\\\n\\\\n            // Update denormalized last-message fields\\\\n            try {\\\\n              await env.DB.prepare(\\\\n                `UPDATE chat_sessions\\\\n                 SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n                 WHERE id = ?`\\\\n              ).bind(safeReply, sessionId).run();\\\\n            } catch (e) {\\\\n              console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n            }\\\\n          }\\\\n\\\\n          // \\\\"Check Delivery Status\\\\"\\\\n          if (normalized === \\\'check delivery status\\\') {\\\\n            let replyText = \\\\"No recent orders found for this email.\\\\";\\\\n\\\\n            if (email) {\\\\n              const lastOrder = await getLatestOrderForEmail(env, email);\\\\n              if (lastOrder) {\\\\n                const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\\\\n                replyText = `Your last order is ${lastOrder.status || \\\'unknown\\\'}. View details here: ${link}`;\\\\n              }\\\\n            }\\\\n\\\\n            const safeReply = escapeHtml(replyText);\\\\n            await env.DB.prepare(\\\\n              `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \\\'system\\\', ?)`\\\\n            ).bind(sessionId, safeReply).run();\\\\n\\\\n            // Update denormalized last-message fields\\\\n            try {\\\\n              await env.DB.prepare(\\\\n                `UPDATE chat_sessions\\\\n                 SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n                 WHERE id = ?`\\\\n              ).bind(safeReply, sessionId).run();\\\\n            } catch (e) {\\\\n              console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n            }\\\\n          }\\\\n        }\\\\n\\\\n        return json({ success: true, messageId: insertRes?.meta?.last_row_id || null });\\\\n      }\\\\n\\\\n      // ----- ADMIN CHAT API -----\\\\n      // ----- ADMIN CHAT API -----\\\\n      if (path === \\\'/api/admin/chats/block\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        const blocked = body.blocked === true || body.blocked === 1 || body.blocked === \\\'true\\\';\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        await env.DB.prepare(\\\\n          `UPDATE chat_sessions SET blocked = ? WHERE id = ?`\\\\n        ).bind(blocked ? 1 : 0, sessionId).run();\\\\n\\\\n        return json({ success: true, blocked: blocked ? 1 : 0 });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/admin/chats/delete\\\' && method === \\\'DELETE\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n        if (!sessionId) {\\\\n          let body;\\\\n          try { body = await req.json(); } catch { body = {}; }\\\\n          sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        } else {\\\\n          sessionId = String(sessionId).trim();\\\\n        }\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        // Delete messages first, then session\\\\n        await env.DB.prepare(`DELETE FROM chat_messages WHERE session_id = ?`).bind(sessionId).run();\\\\n        await env.DB.prepare(`DELETE FROM chat_sessions WHERE id = ?`).bind(sessionId).run();\\\\n\\\\n        return json({ success: true });\\\\n      }\\\\n\\\\nif (path === \\\'/api/admin/chats/sessions\\\' && method === \\\'GET\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        // One row per email (canonical session = oldest created_at for that email)\\\\n        // Denormalized fields on chat_sessions let us avoid heavy subqueries.\\\\n        const rows = await env.DB.prepare(\\\\n          `SELECT\\\\n             s.id,\\\\n             s.name,\\\\n             s.email,\\\\n             s.blocked,\\\\n             s.last_message_at,\\\\n             s.last_message_content AS last_message,\\\\n             s.created_at\\\\n           FROM chat_sessions s\\\\n           JOIN (\\\\n             SELECT lower(email) AS em, MIN(datetime(created_at)) AS min_created\\\\n             FROM chat_sessions\\\\n             GROUP BY lower(email)\\\\n           ) x\\\\n             ON lower(s.email) = x.em AND datetime(s.created_at) = x.min_created\\\\n           ORDER BY COALESCE(s.last_message_at, s.created_at) DESC\\\\n           LIMIT 200`\\\\n        ).all();\\\\n\\\\n        return json({ sessions: rows?.results || [] });\\\\n      }\\\\n\\\\n\\\\n      if (path === \\\'/api/debug\\\') {\\\\n        return json({\\\\n          status: \\\'running\\\',\\\\n          bindings: {\\\\n            DB: !!env.DB,\\\\n            R2_BUCKET: !!env.R2_BUCKET,\\\\n            PRODUCT_MEDIA: !!env.PRODUCT_MEDIA,\\\\n            ASSETS: !!env.ASSETS\\\\n          },\\\\n          // Include the current version and a timestamp to assist with\\\\n          // debugging deployments.  The version is injected at build time\\\\n          // through the VERSION constant defined above.\\\\n          version: VERSION,\\\\n          timestamp: new Date().toISOString()\\\\n        });\\\\n      }\\\\n\\\\n      if (path.startsWith(\\\'/api/\\\')) {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        // ----- CACHE PURGE -----\\\\n        // Endpoint to purge Cloudflare cache via API.  Requires CF_ZONE_ID and CF_API_TOKEN\\\\n        // environment variables to be configured in wrangler.toml or via secrets.  The\\\\n        // route expects a POST request and will call the Cloudflare API to purge\\\\n        // everything for the configured zone.  This allows the admin UI to force\\\\n        // invalidation of stale static assets on demand.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/purge-cache\\\') {\\\\n          const zoneId = env.CF_ZONE_ID;\\\\n          const token = env.CF_API_TOKEN;\\\\n          if (!zoneId || !token) {\\\\n            return json({ error: \\\'CF_ZONE_ID or CF_API_TOKEN not configured\\\' }, 500);\\\\n          }\\\\n          try {\\\\n            const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\\\\n            const cfResp = await fetch(purgeUrl, {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${token}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify({ purge_everything: true })\\\\n            });\\\\n            const result = await cfResp.json();\\\\n            return json(result, cfResp.ok ? 200 : 500);\\\\n          } catch (e) {\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- PRODUCTS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text FROM products WHERE status = ? ORDER BY sort_order ASC, id DESC\\\'\\\\n          ).bind(\\\'active\\\').all();\\\\n          \\\\n          // Fetch review statistics for each product\\\\n          const products = r.results || [];\\\\n          const productsWithReviews = await Promise.all(products.map(async (product) => {\\\\n            const stats = await env.DB.prepare(\\\\n              \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n            ).bind(product.id, \\\'approved\\\').first();\\\\n            \\\\n            return {\\\\n              ...product,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 0\\\\n            };\\\\n          }));\\\\n          \\\\n          return json({ products: productsWithReviews });\\\\n        }\\\\n\\\\n        // ----- WHOP CHECKOUT -----\\\\n        // Create temporary Whop checkout session for a product\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/create-checkout\\\') {\\\\n          const body = await req.json();\\\\n          const { product_id } = body;\\\\n          \\\\n          if (!product_id) {\\\\n            return json({ error: \\\'Product ID required\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Get product details\\\\n          const product = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(product_id)).first();\\\\n          if (!product) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n\\\\n          // Get global Whop settings for fallback\\\\n          let globalSettings = {};\\\\n          try {\\\\n            const settingsRow = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n            if (settingsRow && settingsRow.value) {\\\\n              globalSettings = JSON.parse(settingsRow.value);\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(\\\'Failed to load global settings:\\\', e);\\\\n          }\\\\n\\\\n          // Use product\\\'s whop_plan or fall back to global default\\\\n          let planId = product.whop_plan || globalSettings.default_plan_id || globalSettings.default_plan || \\\'\\\';\\\\n\\\\n          if (!planId) {\\\\n            return json({\\\\n              error: \\\'Whop not configured. Please set a plan for this product or configure a default plan in Settings.\\\'\\\\n            }, 400);\\\\n          }\\\\n\\\\n          // Extract Plan ID from link or use directly\\\\n          planId = planId.trim();\\\\n          \\\\n          // If it\\\'s a link, extract the plan ID\\\\n          if (planId.startsWith(\\\'http\\\')) {\\\\n            // Try to extract from various Whop URL formats\\\\n            // Format 1: https://whop.com/checkout/plan_xxxxx\\\\n            // Format 2: https://whop.com/product-name (contains plan in page)\\\\n            const planMatch = planId.match(/plan_[a-zA-Z0-9]+/);\\\\n            if (planMatch) {\\\\n              planId = planMatch[0];\\\\n            } else {\\\\n              // If no plan ID in URL, we need to fetch it (not ideal but works)\\\\n              // For now, show error - user should provide direct plan ID or proper link\\\\n              return json({ \\\\n                error: \\\'Could not extract Plan ID from link. Please use: https://whop.com/checkout/plan_XXXXX or just plan_XXXXX\\\' \\\\n              }, 400);\\\\n            }\\\\n          }\\\\n          \\\\n          // Validate Plan ID format\\\\n          if (!planId.startsWith(\\\'plan_\\\')) {\\\\n            return json({ error: \\\'Invalid Whop Plan ID format. Should start with plan_\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Get Whop API key from database or environment\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ error: \\\'Whop API key not configured. Please add it in admin Settings.\\\' }, 500);\\\\n          }\\\\n\\\\n          // Calculate expiry time (15 minutes from now)\\\\n          const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\\\\n\\\\n          // Create Whop checkout session\\\\n          try {\\\\n            const whopResponse = await fetch(\\\'https://api.whop.com/api/v2/checkout_sessions\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify({\\\\n                plan_id: planId,\\\\n                redirect_url: `${url.origin}/success.html?product=${product.id}`,\\\\n                metadata: {\\\\n                  product_id: product.id.toString(),\\\\n                  product_title: product.title,\\\\n                  created_at: new Date().toISOString(),\\\\n                  expires_at: expiryTime\\\\n                }\\\\n              })\\\\n            });\\\\n            \\\\n            if (!whopResponse.ok) {\\\\n              const errorText = await whopResponse.text();\\\\n              console.error(\\\'Whop API error:\\\', errorText);\\\\n              \\\\n              // Try to parse error message\\\\n              try {\\\\n                const errorData = JSON.parse(errorText);\\\\n                return json({ \\\\n                  error: errorData.message || errorData.error || \\\'Failed to create checkout\\\' \\\\n                }, whopResponse.status);\\\\n              } catch (e) {\\\\n                return json({ error: \\\'Failed to create checkout session\\\' }, whopResponse.status);\\\\n              }\\\\n            }\\\\n            \\\\n            const checkoutData = await whopResponse.json();\\\\n            \\\\n            // Store checkout for cleanup tracking (optional - for 15 min auto-delete)\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\\\\n                VALUES (?, ?, NULL, ?, \\\'pending\\\', datetime(\\\'now\\\'))\\\\n              `).bind(checkoutData.id, product.id, expiryTime).run();\\\\n            } catch (e) {\\\\n              // Table might not exist - that\\\'s okay, we\\\'ll still return the checkout\\\\n              console.log(\\\'Checkout tracking skipped:\\\', e.message);\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              checkout_id: checkoutData.id,\\\\n              checkout_url: checkoutData.purchase_url,\\\\n              expires_in: \\\'15 minutes\\\'\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Whop checkout error:\\\', e);\\\\n            return json({ error: e.message || \\\'Failed to create checkout\\\' }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- WHOP DYNAMIC PLAN + CHECKOUT -----\\\\n        // Create a temporary plan on Whop for the given product price and immediately\\\\n        // create a checkout session for that plan.  After payment, the webhook\\\\n        // handler will delete both the checkout session and the plan.  This can be\\\\n        // used when you need to charge custom one\\\\u2011time amounts per customer\\\\n        // without pre\\\\u2011creating plans in the Whop dashboard.  Requires\\\\n        // `plan:create` and `plan:delete` permissions on the API key as well as a\\\\n        // configured `WHOP_COMPANY_ID`.  Each product should store the\\\\n        // corresponding Whop `product_id` in the `whop_product_id` column.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/create-plan-checkout\\\') {\\\\n          const body = await req.json();\\\\n          const { product_id, amount, email, metadata } = body || {};\\\\n          if (!product_id) {\\\\n            return json({ error: \\\'Product ID required\\\' }, 400);\\\\n          }\\\\n          // Lookup product from database\\\\n          const product = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(product_id)).first();\\\\n          if (!product) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          // Determine the price to charge; prefer sale_price over normal_price\\\\n          const priceValue = (product.sale_price !== null && product.sale_price !== undefined && product.sale_price !== \\\'\\\')\\\\n            ? Number(product.sale_price)\\\\n            : Number(product.normal_price);\\\\n          // Allow $0 for testing, but reject negative prices\\\\n          if (isNaN(priceValue) || priceValue < 0) {\\\\n            return json({ error: \\\'Invalid price for product\\\' }, 400);\\\\n          }\\\\n          // Ensure we have the Whop product ID for attaching the plan to the correct product\\\\n          // Use the product\\\'s specific Whop product ID if available.\\\\n          const directProdId = (product.whop_product_id || \\\'\\\').trim();\\\\n          let finalProdId = directProdId;\\\\n          // If no product-specific ID, fallback to global default_product_id from settings\\\\n          if (!finalProdId) {\\\\n            try {\\\\n              const srow = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n              let settings = {};\\\\n              if (srow && srow.value) {\\\\n                try { settings = JSON.parse(srow.value); } catch (e) { settings = {}; }\\\\n              }\\\\n              if (settings && settings.default_product_id) {\\\\n                finalProdId = (settings.default_product_id || \\\'\\\').trim();\\\\n              }\\\\n            } catch (e) {\\\\n              console.log(\\\'Failed to load whop settings for default product ID:\\\', e);\\\\n            }\\\\n          }\\\\n          if (!finalProdId) {\\\\n            return json({ error: \\\'whop_product_id not configured for this product and no default_product_id set\\\' }, 400);\\\\n          }\\\\n          // Company ID must be provided via environment variables\\\\n          const companyId = env.WHOP_COMPANY_ID;\\\\n          if (!companyId) {\\\\n            return json({ error: \\\'WHOP_COMPANY_ID environment variable not set\\\' }, 500);\\\\n          }\\\\n          // Get API key from database or environment\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ error: \\\'Whop API key not configured. Please add it in admin Settings.\\\' }, 500);\\\\n          }\\\\n          // Derive currency from environment or fallback to USD\\\\n          const currency = env.WHOP_CURRENCY || \\\'usd\\\';\\\\n          // Prepare plan creation request for one-time payment (no renewal)\\\\n          // For one_time plans, we should NOT set renewal_price\\\\n          const planBody = {\\\\n            company_id: companyId,\\\\n            product_id: finalProdId,\\\\n            plan_type: \\\'one_time\\\',\\\\n            release_method: \\\'buy_now\\\',\\\\n            currency: currency,\\\\n            initial_price: priceValue,\\\\n            // Do NOT set renewal_price for one_time plans - it causes error\\\\n            // Provide a default title for the plan so the seller can see it in their dashboard\\\\n            title: `${product.title || \\\'One\\\\u2011time purchase\\\'} - $${priceValue}`,\\\\n            // Set unlimited stock to prevent \\\\"out of stock\\\\" errors\\\\n            stock: 999999,\\\\n            internal_notes: `Auto-generated for product ${product.id} - ${new Date().toISOString()}`\\\\n          };\\\\n          try {\\\\n            // Create the plan on Whop\\\\n            const planResp = await fetch(\\\'https://api.whop.com/api/v2/plans\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify(planBody)\\\\n            });\\\\n            if (!planResp.ok) {\\\\n              const errorText = await planResp.text();\\\\n              console.error(\\\'Whop plan create error:\\\', errorText);\\\\n              let msg = \\\'Failed to create plan\\\';\\\\n              try {\\\\n                const j = JSON.parse(errorText);\\\\n                msg = j.message || j.error || msg;\\\\n              } catch (_) {}\\\\n              return json({ error: msg }, planResp.status);\\\\n            }\\\\n            const planData = await planResp.json();\\\\n            const planId = planData.id;\\\\n            if (!planId) {\\\\n              return json({ error: \\\'Plan ID missing from Whop response\\\' }, 500);\\\\n            }\\\\n            // Compute expiry time (15 mins) for cleanup\\\\n            const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\\\\n\\\\n            // Store plan for cleanup, no checkout session needed for embedded flow\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\\\\n                VALUES (?, ?, ?, ?, \\\'pending\\\', datetime(\\\'now\\\'))\\\\n              `).bind(\\\'plan_\\\' + planId, product.id, planId, expiryTime).run();\\\\n            } catch (e) {\\\\n              console.log(\\\'Plan tracking insert failed:\\\', e.message);\\\\n            }\\\\n\\\\n            // Create checkout session with email prefill for better UX\\\\n            const checkoutBody = {\\\\n              plan_id: planId,\\\\n              redirect_url: `${url.origin}/success.html?product=${product.id}`,\\\\n              metadata: {\\\\n                product_id: product.id.toString(),\\\\n                product_title: product.title,\\\\n                addons: metadata?.addons || [],\\\\n                amount: amount || priceValue,\\\\n                created_at: new Date().toISOString()\\\\n              }\\\\n            };\\\\n\\\\n            // Add email prefill if provided\\\\n            if (email && email.includes(\\\'@\\\')) {\\\\n              checkoutBody.prefill = {\\\\n                email: email.trim()\\\\n              };\\\\n            }\\\\n\\\\n            const checkoutResp = await fetch(\\\'https://api.whop.com/api/v2/checkout_sessions\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify(checkoutBody)\\\\n            });\\\\n\\\\n            if (!checkoutResp.ok) {\\\\n              const errorText = await checkoutResp.text();\\\\n              console.error(\\\'Whop checkout session error:\\\', errorText);\\\\n              // If checkout session fails, still return plan ID for fallback\\\\n              return json({\\\\n                success: true,\\\\n                plan_id: planId,\\\\n                product_id: product.id,\\\\n                email: email,\\\\n                metadata: {\\\\n                  product_id: product.id.toString(),\\\\n                  product_title: product.title,\\\\n                  addons: metadata?.addons || [],\\\\n                  amount: amount || priceValue\\\\n                },\\\\n                expires_in: \\\'15 minutes\\\',\\\\n                warning: \\\'Email prefill not available\\\'\\\\n              });\\\\n            }\\\\n\\\\n            const checkoutData = await checkoutResp.json();\\\\n\\\\n            // Update database record with checkout session ID\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                UPDATE checkout_sessions \\\\n                SET checkout_id = ?\\\\n                WHERE checkout_id = ?\\\\n              `).bind(checkoutData.id, \\\'plan_\\\' + planId).run();\\\\n            } catch (e) {\\\\n              console.log(\\\'Checkout session tracking update failed:\\\', e.message);\\\\n            }\\\\n\\\\n            // Return both plan ID and checkout URL with email prefill\\\\n            return json({\\\\n              success: true,\\\\n              plan_id: planId,\\\\n              checkout_id: checkoutData.id,\\\\n              checkout_url: checkoutData.purchase_url,\\\\n              product_id: product.id,\\\\n              email: email,\\\\n              metadata: {\\\\n                product_id: product.id.toString(),\\\\n                product_title: product.title,\\\\n                addons: metadata?.addons || [],\\\\n                amount: amount || priceValue\\\\n              },\\\\n              expires_in: \\\'15 minutes\\\',\\\\n              email_prefilled: !!(email && email.includes(\\\'@\\\'))\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Dynamic checkout error:\\\', e);\\\\n            return json({ error: e.message || \\\'Failed to create plan/checkout\\\' }, 500);\\\\n          }\\\\n        }\\\\n        \\\\n        // ----- WHOP WEBHOOK -----\\\\n        // Handle Whop payment webhooks\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/webhook\\\') {\\\\n          try {\\\\n            const webhookData = await req.json();\\\\n            const eventType = webhookData.type;\\\\n            \\\\n            console.log(\\\'Whop webhook received:\\\', eventType);\\\\n            \\\\n            // Handle payment success\\\\n            if (eventType === \\\'payment.succeeded\\\') {\\\\n              const checkoutSessionId = webhookData.data?.checkout_session_id;\\\\n              const membershipId = webhookData.data?.id;\\\\n              const metadata = webhookData.data?.metadata || {};\\\\n              \\\\n              console.log(\\\'Payment succeeded:\\\', {\\\\n                checkoutSessionId,\\\\n                membershipId,\\\\n                metadata\\\\n              });\\\\n              \\\\n              // Mark checkout as completed in database\\\\n              if (checkoutSessionId) {\\\\n                try {\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'completed\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkoutSessionId).run();\\\\n                } catch (e) {\\\\n                  console.log(\\\'Checkout tracking update skipped:\\\', e.message);\\\\n                }\\\\n              }\\\\n              \\\\n              // Delete the temporary checkout session from Whop\\\\n              if (checkoutSessionId && env.WHOP_API_KEY) {\\\\n                try {\\\\n                  await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkoutSessionId}`, {\\\\n                    method: \\\'DELETE\\\',\\\\n                    headers: {\\\\n                      \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}`\\\\n                    }\\\\n                  });\\\\n                  console.log(\\\'\\\\u2705 Checkout session deleted immediately after payment:\\\', checkoutSessionId);\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to delete checkout session:\\\', e);\\\\n                }\\\\n              }\\\\n              // If we created a dynamic plan for this checkout, delete the plan as well\\\\n              if (checkoutSessionId && env.WHOP_API_KEY) {\\\\n                try {\\\\n                  // Fetch plan_id from checkout_sessions table\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkoutSessionId).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Plan deleted immediately after payment:\\\', planId);\\\\n                  }\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to delete plan:\\\', e);\\\\n                }\\\\n              }\\\\n              \\\\n              // Create order in database (optional - for tracking)\\\\n              if (metadata.product_id) {\\\\n                try {\\\\n                  const orderId = `WHOP-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\\\n                  await env.DB.prepare(\\\\n                    \\\'INSERT INTO orders (order_id, product_id, status, created_at) VALUES (?, ?, ?, datetime(\\\\"now\\\\"))\\\'\\\\n                  ).bind(orderId, Number(metadata.product_id), \\\'completed\\\').run();\\\\n                  \\\\n                  console.log(\\\'Order created:\\\', orderId);\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to create order:\\\', e);\\\\n                }\\\\n              }\\\\n            }\\\\n            \\\\n            // Handle membership validation\\\\n            if (eventType === \\\'membership.went_valid\\\') {\\\\n              console.log(\\\'Membership validated:\\\', webhookData.data?.id);\\\\n            }\\\\n            \\\\n            // Always return 200 to acknowledge webhook\\\\n            return json({ received: true });\\\\n          } catch (e) {\\\\n            console.error(\\\'Webhook error:\\\', e);\\\\n            return json({ error: \\\'Webhook processing failed\\\' }, 500);\\\\n          }\\\\n        }\\\\n        // ----- WHOP TEST API -----\\\\n        // Simple endpoint to verify Whop API connectivity and permissions.  This\\\\n        // GET call attempts to fetch the current company details using\\\\n        // WHOP_COMPANY_ID and WHOP_API_KEY.  A successful response means the\\\\n        // API key is valid and has at least `company:basic:read` permissions.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-api\\\') {\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ success: false, error: \\\'Whop API key not configured. Please add it in Settings.\\\' }, 500);\\\\n          }\\\\n          try {\\\\n            // Test API key by listing plans - this endpoint works with basic plan permissions\\\\n            // and doesn\\\'t require company ID or special permissions\\\\n            const resp = await fetch(\\\'https://api.whop.com/api/v2/plans?page=1&per=1\\\', {\\\\n              method: \\\'GET\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              }\\\\n            });\\\\n\\\\n            // Return detailed error info for debugging\\\\n            if (!resp.ok) {\\\\n              const text = await resp.text();\\\\n              let errMsg = \\\'Whop API call failed\\\';\\\\n              let errorDetails = null;\\\\n              try {\\\\n                errorDetails = JSON.parse(text);\\\\n                errMsg = errorDetails.message || errorDetails.error || errMsg;\\\\n              } catch (_) {\\\\n                errMsg = text || errMsg;\\\\n              }\\\\n              return json({\\\\n                success: false,\\\\n                error: errMsg,\\\\n                status: resp.status,\\\\n                details: errorDetails,\\\\n                debug: {\\\\n                  apiKeyLength: apiKey?.length || 0,\\\\n                  apiKeyPrefix: apiKey?.substring(0, 10) + \\\'...\\\'\\\\n                }\\\\n              }, resp.status);\\\\n            }\\\\n\\\\n            const data = await resp.json();\\\\n            return json({\\\\n              success: true,\\\\n              message: \\\'API connection successful!\\\',\\\\n              plansCount: data.data?.length || 0,\\\\n              apiKeyValid: true\\\\n            });\\\\n          } catch (e) {\\\\n            return json({ success: false, error: e.message || \\\'API test error\\\' }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- WHOP TEST WEBHOOK -----\\\\n        // Endpoint to verify that the webhook endpoint is reachable.  This\\\\n        // simply returns a success object.  It does not call the external\\\\n        // Whop service.  Use this to check that your domain and Cloudflare\\\\n        // routing are configured correctly.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-webhook\\\') {\\\\n          return json({ success: true, message: \\\'Webhook endpoint reachable\\\' });\\\\n        }\\\\n        \\\\n        // ----- CLEANUP EXPIRED CHECKOUTS -----\\\\n        // Endpoint to cleanup expired checkout sessions (call this from a cron job)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/cleanup\\\') {\\\\n          if (!env.WHOP_API_KEY) {\\\\n            return json({ error: \\\'Whop API key not configured\\\' }, 500);\\\\n          }\\\\n          \\\\n          try {\\\\n            // Get expired checkouts from database\\\\n            const expiredCheckouts = await env.DB.prepare(`\\\\n              SELECT checkout_id, product_id, expires_at\\\\n              FROM checkout_sessions\\\\n              WHERE status = \\\'pending\\\' \\\\n              AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n              ORDER BY created_at ASC\\\\n              LIMIT 50\\\\n            `).all();\\\\n            \\\\n            let deleted = 0;\\\\n            let failed = 0;\\\\n            \\\\n            for (const checkout of (expiredCheckouts.results || [])) {\\\\n              try {\\\\n                // Delete the checkout session from Whop (ignore if already gone)\\\\n                const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n                  method: \\\'DELETE\\\',\\\\n                  headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                });\\\\n                // Attempt to delete the associated plan if one exists\\\\n                let planDeleted = false;\\\\n                try {\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkout.checkout_id).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    planDeleted = delPlanResp.ok || delPlanResp.status === 404;\\\\n                  }\\\\n                } catch (pe) {\\\\n                  console.error(\\\'Plan deletion error:\\\', pe);\\\\n                }\\\\n                if (deleteSessionResp.ok || deleteSessionResp.status === 404) {\\\\n                  // Mark as expired in database regardless of plan deletion outcome\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkout.checkout_id).run();\\\\n                  deleted++;\\\\n                  console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id, planDeleted ? \\\'and plan cleaned up\\\' : \\\'\\\');\\\\n                } else {\\\\n                  failed++;\\\\n                }\\\\n              } catch (e) {\\\\n                failed++;\\\\n                console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, e);\\\\n              }\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              deleted: deleted,\\\\n              failed: failed,\\\\n              message: `Cleaned up ${deleted} expired checkouts`\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Cleanup error:\\\', e);\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/product/\\\')) {\\\\n          const id = path.split(\\\'/\\\').pop();\\\\n          let row;\\\\n          if (isNaN(Number(id))) {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE slug = ?\\\').bind(id).first();\\\\n          } else {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          }\\\\n          if (!row) return json({ error: \\\'Product not found\\\' }, 404);\\\\n          \\\\n          let addons = [];\\\\n          try {\\\\n            addons = JSON.parse(row.addons_json || \\\'[]\\\');\\\\n          } catch(e) {\\\\n            console.error(\\\'Failed to parse addons_json for product\\\', row.id, \\\':\\\', e.message);\\\\n          }\\\\n          \\\\n          const stats = await env.DB.prepare(\\\\n            \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n          ).bind(row.id, \\\'approved\\\').first();\\\\n          \\\\n          // Fetch reviews for rich results schema (directly use review\\\'s own video URLs)\\\\n          const reviewsResult = await env.DB.prepare(\\\\n            `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n             FROM reviews \\\\n             LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n             WHERE reviews.product_id = ? AND reviews.status = ? \\\\n             ORDER BY reviews.created_at DESC`\\\\n          ).bind(row.id, \\\'approved\\\').all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (reviewsResult.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            if (review.updated_at && typeof review.updated_at === \\\'string\\\') {\\\\n              review.updated_at = review.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n          \\\\n          return json({\\\\n            product: {\\\\n              ...row,\\\\n              addons,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,\\\\n              reviews: reviews\\\\n            },\\\\n            addons\\\\n          });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/product/save\\\') {\\\\n          const body = await req.json();\\\\n          const title = (body.title || \\\'\\\').trim();\\\\n          if (!title) return json({ error: \\\'Title required\\\' }, 400);\\\\n          \\\\n          const slug = (body.slug || \\\'\\\').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const addonsJson = JSON.stringify(body.addons || []);\\\\n          \\\\n          if (body.id) {\\\\n            // Prepare gallery_images as JSON string if it\\\'s an array\\\\n            const galleryJson = Array.isArray(body.gallery_images) \\\\n              ? JSON.stringify(body.gallery_images) \\\\n              : (body.gallery_images || \\\'[]\\\');\\\\n            \\\\n            await env.DB.prepare(`\\\\n              UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\\\\n              instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\\\\n              gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\\\\n              whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?\\\\n            `).bind(\\\\n              title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n              body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n              body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n              body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n              body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\', Number(body.id)\\\\n            ).run();\\\\n            return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });\\\\n          }\\\\n          \\\\n          // Prepare gallery_images as JSON string if it\\\'s an array\\\\n          const galleryJson = Array.isArray(body.gallery_images) \\\\n            ? JSON.stringify(body.gallery_images) \\\\n            : (body.gallery_images || \\\'[]\\\');\\\\n          \\\\n          const r = await env.DB.prepare(`\\\\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\\\\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\\\\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \\\'active\\\', 0)\\\\n          `).bind(\\\\n            title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n            body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n            body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n            body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n            body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\'\\\\n          ).run();\\\\n          const newId = r.meta?.last_row_id;\\\\n          return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/product/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          if (!id) return json({ error: \\\'ID required\\\' }, 400);\\\\n          await env.DB.prepare(\\\'DELETE FROM products WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS LIST (admin) -----\\\\n        // Return all products regardless of status.  Used by the admin UI to\\\\n        // manage published and draft products.  Includes the status column to\\\\n        // drive publish/unpublish toggles.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products/list\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          return json({ products: r.results || [] });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS STATUS UPDATE -----\\\\n        // Update the status of a product (active for published, draft for draft).\\\\n        // Accepts JSON with `id` and `status`.  Status must be \\\'active\\\' or \\\'draft\\\'.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!id || !status) {\\\\n            return json({ error: \\\'id and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'active\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE products SET status = ? WHERE id = ?\\\').bind(status, Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS DUPLICATE -----\\\\n        // Duplicate an existing product.  Accepts JSON with `id`.  Copies\\\\n        // all fields and inserts a new product with slug suffixed by \\\'-copy\\\'\\\\n        // and status set to \\\'draft\\\'.  Ensures slug uniqueness by adding\\\\n        // numerical suffixes when needed.  Returns the new product id and slug.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          if (!id) {\\\\n            return json({ error: \\\'id required\\\' }, 400);\\\\n          }\\\\n          const row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Determine unique new slug\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          // Copy all relevant fields into a new product row\\\\n          const r = await env.DB.prepare(\\\\n            `INSERT INTO products (\\\\n              title, slug, description, normal_price, sale_price,\\\\n              instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n              addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n              whop_plan, whop_price_map, status, sort_order\\\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\\\\n          ).bind(\\\\n            (row.title || \\\'\\\') + \\\' Copy\\\',\\\\n            newSlug,\\\\n            row.description || \\\'\\\',\\\\n            row.normal_price || 0,\\\\n            row.sale_price || null,\\\\n            row.instant_delivery || 0,\\\\n            row.normal_delivery_text || \\\'\\\',\\\\n            row.thumbnail_url || \\\'\\\',\\\\n            row.video_url || \\\'\\\',\\\\n            row.addons_json || \\\'[]\\\',\\\\n            row.seo_title || \\\'\\\',\\\\n            row.seo_description || \\\'\\\',\\\\n            row.seo_keywords || \\\'\\\',\\\\n            row.seo_canonical || \\\'\\\',\\\\n            row.whop_plan || \\\'\\\',\\\\n            row.whop_price_map || \\\'\\\',\\\\n            \\\'draft\\\',\\\\n            0\\\\n          ).run();\\\\n          return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- ORDERS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/orders\\\') {\\\\n          const r = await env.DB.prepare(\\\'SELECT * FROM orders ORDER BY id DESC\\\').all();\\\\n          const orders = (r.results || []).map(row => {\\\\n            let email = \\\'\\\', amount = null, addons = [];\\\\n            try {\\\\n              if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n                const d = JSON.parse(row.encrypted_data);\\\\n                email = d.email || \\\'\\\';\\\\n                amount = d.amount;\\\\n                addons = d.addons || [];\\\\n              }\\\\n            } catch(e) {\\\\n              console.error(\\\'Failed to parse order encrypted_data for order:\\\', row.order_id, e.message);\\\\n            }\\\\n            return { ...row, email, amount, addons };\\\\n          });\\\\n          return json({ orders });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && (path === \\\'/api/order/create\\\' || path === \\\'/submit-order\\\')) {\\\\n          const body = await req.json();\\\\n          if (!body.productId) return json({ error: \\\'productId required\\\' }, 400);\\\\n          \\\\n          const orderId = body.orderId || crypto.randomUUID().split(\\\'-\\\')[0].toUpperCase();\\\\n          const data = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount,\\\\n            productId: body.productId,\\\\n            addons: body.addons || []\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(orderId, Number(body.productId), data, \\\'PAID\\\', Number(body.delive",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nThe file is quite large. Let me continue reading the rest of it:\n\n<function_calls>\n<execute-command>\nwc -l wishesu-main/worker.js\n</execute-command>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "3303 wishesu-main/worker.js\\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nLet me read the rest of the file in chunks:\n\n<function_calls>\n<execute-command>\ntail -n 1604 wishesu-main/worker.js\n</execute-command>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "          }\\\\n        }\\\\n\\\\n        // ----- WHOP TEST WEBHOOK -----\\\\n        // Endpoint to verify that the webhook endpoint is reachable.  This\\\\n        // simply returns a success object.  It does not call the external\\\\n        // Whop service.  Use this to check that your domain and Cloudflare\\\\n        // routing are configured correctly.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-webhook\\\') {\\\\n          return json({ success: true, message: \\\'Webhook endpoint reachable\\\' });\\\\n        }\\\\n        \\\\n        // ----- CLEANUP EXPIRED CHECKOUTS -----\\\\n        // Endpoint to cleanup expired checkout sessions (call this from a cron job)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/cleanup\\\') {\\\\n          if (!env.WHOP_API_KEY) {\\\\n            return json({ error: \\\'Whop API key not configured\\\' }, 500);\\\\n          }\\\\n          \\\\n          try {\\\\n            // Get expired checkouts from database\\\\n            const expiredCheckouts = await env.DB.prepare(`\\\\n              SELECT checkout_id, product_id, expires_at\\\\n              FROM checkout_sessions\\\\n              WHERE status = \\\'pending\\\' \\\\n              AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n              ORDER BY created_at ASC\\\\n              LIMIT 50\\\\n            `).all();\\\\n            \\\\n            let deleted = 0;\\\\n            let failed = 0;\\\\n            \\\\n            for (const checkout of (expiredCheckouts.results || [])) {\\\\n              try {\\\\n                // Delete the checkout session from Whop (ignore if already gone)\\\\n                const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n                  method: \\\'DELETE\\\',\\\\n                  headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                });\\\\n                // Attempt to delete the associated plan if one exists\\\\n                let planDeleted = false;\\\\n                try {\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkout.checkout_id).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    planDeleted = delPlanResp.ok || delPlanResp.status === 404;\\\\n                  }\\\\n                } catch (pe) {\\\\n                  console.error(\\\'Plan deletion error:\\\', pe);\\\\n                }\\\\n                if (deleteSessionResp.ok || deleteSessionResp.status === 404) {\\\\n                  // Mark as expired in database regardless of plan deletion outcome\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkout.checkout_id).run();\\\\n                  deleted++;\\\\n                  console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id, planDeleted ? \\\'and plan cleaned up\\\' : \\\'\\\');\\\\n                } else {\\\\n                  failed++;\\\\n                }\\\\n              } catch (e) {\\\\n                failed++;\\\\n                console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, e);\\\\n              }\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              deleted: deleted,\\\\n              failed: failed,\\\\n              message: `Cleaned up ${deleted} expired checkouts`\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Cleanup error:\\\', e);\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/product/\\\')) {\\\\n          const id = path.split(\\\'/\\\').pop();\\\\n          let row;\\\\n          if (isNaN(Number(id))) {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE slug = ?\\\').bind(id).first();\\\\n          } else {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          }\\\\n          if (!row) return json({ error: \\\'Product not found\\\' }, 404);\\\\n          \\\\n          let addons = [];\\\\n          try {\\\\n            addons = JSON.parse(row.addons_json || \\\'[]\\\');\\\\n          } catch(e) {\\\\n            console.error(\\\'Failed to parse addons_json for product\\\', row.id, \\\':\\\', e.message);\\\\n          }\\\\n          \\\\n          const stats = await env.DB.prepare(\\\\n            \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n          ).bind(row.id, \\\'approved\\\').first();\\\\n          \\\\n          // Fetch reviews for rich results schema (directly use review\\\'s own video URLs)\\\\n          const reviewsResult = await env.DB.prepare(\\\\n            `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n             FROM reviews \\\\n             LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n             WHERE reviews.product_id = ? AND reviews.status = ? \\\\n             ORDER BY reviews.created_at DESC`\\\\n          ).bind(row.id, \\\'approved\\\').all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (reviewsResult.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            if (review.updated_at && typeof review.updated_at === \\\'string\\\') {\\\\n              review.updated_at = review.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n          \\\\n          return json({\\\\n            product: {\\\\n              ...row,\\\\n              addons,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,\\\\n              reviews: reviews\\\\n            },\\\\n            addons\\\\n          });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/product/save\\\') {\\\\n          const body = await req.json();\\\\n          const title = (body.title || \\\'\\\').trim();\\\\n          if (!title) return json({ error: \\\'Title required\\\' }, 400);\\\\n          \\\\n          const slug = (body.slug || \\\'\\\').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const addonsJson = JSON.stringify(body.addons || []);\\\\n          \\\\n          if (body.id) {\\\\n            // Prepare gallery_images as JSON string if it\\\'s an array\\\\n            const galleryJson = Array.isArray(body.gallery_images) \\\\n              ? JSON.stringify(body.gallery_images) \\\\n              : (body.gallery_images || \\\'[]\\\');\\\\n            \\\\n            await env.DB.prepare(`\\\\n              UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\\\\n              instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\\\\n              gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\\\\n              whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?\\\\n            `).bind(\\\\n              title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n              body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n              body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n              body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n              body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\', Number(body.id)\\\\n            ).run();\\\\n            return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });\\\\n          }\\\\n          \\\\n          // Prepare gallery_images as JSON string if it\\\'s an array\\\\n          const galleryJson = Array.isArray(body.gallery_images) \\\\n            ? JSON.stringify(body.gallery_images) \\\\n            : (body.gallery_images || \\\'[]\\\');\\\\n          \\\\n          const r = await env.DB.prepare(`\\\\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\\\\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\\\\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \\\'active\\\', 0)\\\\n          `).bind(\\\\n            title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n            body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n            body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n            body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n            body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\'\\\\n          ).run();\\\\n          const newId = r.meta?.last_row_id;\\\\n          return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/product/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          if (!id) return json({ error: \\\'ID required\\\' }, 400);\\\\n          await env.DB.prepare(\\\'DELETE FROM products WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS LIST (admin) -----\\\\n        // Return all products regardless of status.  Used by the admin UI to\\\\n        // manage published and draft products.  Includes the status column to\\\\n        // drive publish/unpublish toggles.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products/list\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          return json({ products: r.results || [] });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS STATUS UPDATE -----\\\\n        // Update the status of a product (active for published, draft for draft).\\\\n        // Accepts JSON with `id` and `status`.  Status must be \\\'active\\\' or \\\'draft\\\'.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!id || !status) {\\\\n            return json({ error: \\\'id and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'active\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE products SET status = ? WHERE id = ?\\\').bind(status, Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS DUPLICATE -----\\\\n        // Duplicate an existing product.  Accepts JSON with `id`.  Copies\\\\n        // all fields and inserts a new product with slug suffixed by \\\'-copy\\\'\\\\n        // and status set to \\\'draft\\\'.  Ensures slug uniqueness by adding\\\\n        // numerical suffixes when needed.  Returns the new product id and slug.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          if (!id) {\\\\n            return json({ error: \\\'id required\\\' }, 400);\\\\n          }\\\\n          const row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Determine unique new slug\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          // Copy all relevant fields into a new product row\\\\n          const r = await env.DB.prepare(\\\\n            `INSERT INTO products (\\\\n              title, slug, description, normal_price, sale_price,\\\\n              instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n              addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n              whop_plan, whop_price_map, status, sort_order\\\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\\\\n          ).bind(\\\\n            (row.title || \\\'\\\') + \\\' Copy\\\',\\\\n            newSlug,\\\\n            row.description || \\\'\\\',\\\\n            row.normal_price || 0,\\\\n            row.sale_price || null,\\\\n            row.instant_delivery || 0,\\\\n            row.normal_delivery_text || \\\'\\\',\\\\n            row.thumbnail_url || \\\'\\\',\\\\n            row.video_url || \\\'\\\',\\\\n            row.addons_json || \\\'[]\\\',\\\\n            row.seo_title || \\\'\\\',\\\\n            row.seo_description || \\\'\\\',\\\\n            row.seo_keywords || \\\'\\\',\\\\n            row.seo_canonical || \\\'\\\',\\\\n            row.whop_plan || \\\'\\\',\\\\n            row.whop_price_map || \\\'\\\',\\\\n            \\\'draft\\\',\\\\n            0\\\\n          ).run();\\\\n          return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- ORDERS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/orders\\\') {\\\\n          const r = await env.DB.prepare(\\\'SELECT * FROM orders ORDER BY id DESC\\\').all();\\\\n          const orders = (r.results || []).map(row => {\\\\n            let email = \\\'\\\', amount = null, addons = [];\\\\n            try {\\\\n              if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n                const d = JSON.parse(row.encrypted_data);\\\\n                email = d.email || \\\'\\\';\\\\n                amount = d.amount;\\\\n                addons = d.addons || [];\\\\n              }\\\\n            } catch(e) {\\\\n              console.error(\\\'Failed to parse order encrypted_data for order:\\\', row.order_id, e.message);\\\\n            }\\\\n            return { ...row, email, amount, addons };\\\\n          });\\\\n          return json({ orders });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && (path === \\\'/api/order/create\\\' || path === \\\'/submit-order\\\')) {\\\\n          const body = await req.json();\\\\n          if (!body.productId) return json({ error: \\\'productId required\\\' }, 400);\\\\n          \\\\n          const orderId = body.orderId || crypto.randomUUID().split(\\\'-\\\')[0].toUpperCase();\\\\n          const data = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount,\\\\n            productId: body.productId,\\\\n            addons: body.addons || []\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(orderId, Number(body.productId), data, \\\'PAID\\\', Number(body.deliveryTime) || 60).run();\\\\n          \\\\n          return json({ success: true, orderId });\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/order/buyer/\\\')) {\\\\n           const orderId = path.split(\\\'/\\\').pop();\\\\n           const row = await env.DB.prepare(\\\\n             \\\'SELECT o.*, p.title as product_title, p.thumbnail_url as product_thumbnail FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\\\'\\\\n           ).bind(orderId).first();\\\\n\\\\n           if (!row) return json({ error: \\\'Order not found\\\' }, 404);\\\\n\\\\n           // Check if review already exists for this order\\\\n           const reviewCheck = await env.DB.prepare(\\\\n             \\\'SELECT id FROM reviews WHERE order_id = ? LIMIT 1\\\'\\\\n           ).bind(orderId).first();\\\\n           const hasReview = !!reviewCheck;\\\\n\\\\n           let addons = [], email = \\\'\\\', amount = null;\\\\n           try {\\\\n             if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n               const d = JSON.parse(row.encrypted_data);\\\\n               addons = d.addons || [];\\\\n               email = d.email || \\\'\\\';\\\\n               amount = d.amount;\\\\n             }\\\\n           } catch(e) {\\\\n             console.error(\\\'Failed to parse order encrypted_data for buyer order:\\\', orderId, e.message);\\\\n           }\\\\n\\\\n           // Convert SQLite datetime to ISO 8601 format with Z suffix for UTC\\\\n           const orderData = { ...row, addons, email, amount, has_review: hasReview };\\\\n           if (orderData.created_at && typeof orderData.created_at === \\\'string\\\') {\\\\n             // SQLite format: YYYY-MM-DD HH:MM:SS -> ISO 8601: YYYY-MM-DDTHH:MM:SSZ\\\\n             orderData.created_at = orderData.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n\\\\n           return json({ order: orderData });\\\\n         }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/order/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM orders WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // Update order (status, delivery time, etc.)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/update\\\') {\\\\n          const body = await req.json();\\\\n          const orderId = body.orderId;\\\\n          \\\\n          if (!orderId) return json({ error: \\\'orderId required\\\' }, 400);\\\\n          \\\\n          const updates = [];\\\\n          const values = [];\\\\n          \\\\n          if (body.status !== undefined) {\\\\n            updates.push(\\\'status = ?\\\');\\\\n            values.push(body.status);\\\\n          }\\\\n          if (body.delivery_time_minutes !== undefined) {\\\\n            updates.push(\\\'delivery_time_minutes = ?\\\');\\\\n            values.push(Number(body.delivery_time_minutes));\\\\n          }\\\\n          \\\\n          if (updates.length === 0) {\\\\n            return json({ error: \\\'No fields to update\\\' }, 400);\\\\n          }\\\\n          \\\\n          values.push(orderId);\\\\n          await env.DB.prepare(`UPDATE orders SET ${updates.join(\\\', \\\')} WHERE order_id = ?`).bind(...values).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // Create order manually (admin)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/create\\\') {\\\\n          const body = await req.json();\\\\n          \\\\n          if (!body.productId || !body.email) {\\\\n            return json({ error: \\\'productId and email required\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Generate unique order ID\\\\n          const orderId = \\\'MO\\\' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 6).toUpperCase();\\\\n          \\\\n          // Store order data\\\\n          const encryptedData = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount || 0,\\\\n            addons: body.notes ? [{ field: \\\'Admin Notes\\\', value: body.notes }] : [],\\\\n            manualOrder: true\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(\\\\n            orderId,\\\\n            Number(body.productId),\\\\n            encryptedData,\\\\n            body.status || \\\'paid\\\',\\\\n            Number(body.deliveryTime) || 60\\\\n          ).run();\\\\n          \\\\n          return json({ success: true, orderId });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/deliver\\\') {\\\\n                  const body = await req.json();\\\\n                  if (!body.orderId || !body.videoUrl) return json({ error: \\\'orderId and videoUrl required\\\' }, 400);\\\\n\\\\n                  // Get order data before updating\\\\n                  const orderResult = await env.DB.prepare(\\\\n                    \\\'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\\\'\\\\n                  ).bind(body.orderId).first();\\\\n\\\\n                  // Prepare additional metadata for delivered videos (Archive.org + subtitles, etc)\\\\n                  const deliveredVideoMetadata = JSON.stringify({\\\\n                    embedUrl: body.embedUrl,\\\\n                    itemId: body.itemId,\\\\n                    subtitlesUrl: body.subtitlesUrl,\\\\n                    tracks: Array.isArray(body.tracks) ? body.tracks : undefined,\\\\n                    deliveredAt: new Date().toISOString()\\\\n                  });\\\\n\\\\n                  await env.DB.prepare(\\\\n                    \\\'UPDATE orders SET delivered_video_url=?, delivered_thumbnail_url=?, status=?, delivered_at=CURRENT_TIMESTAMP, delivered_video_metadata=? WHERE order_id=?\\\'\\\\n                  ).bind(body.videoUrl, body.thumbnailUrl || null, \\\'delivered\\\', deliveredVideoMetadata, body.orderId).run();\\\\n          \\\\n          // Trigger email webhook if configured\\\\n          try {\\\\n            const googleScriptUrl = await getGoogleScriptUrl(env);\\\\n            if (googleScriptUrl && orderResult) {\\\\n              // Extract email from encrypted data\\\\n              let customerEmail = \\\'\\\';\\\\n              try {\\\\n                const decrypted = JSON.parse(orderResult.encrypted_data);\\\\n                customerEmail = decrypted.email || \\\'\\\';\\\\n              } catch (e) {\\\\n                console.warn(\\\'Could not decrypt order data for email\\\');\\\\n              }\\\\n              \\\\n              // Send delivery notification webhook\\\\n              await fetch(googleScriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'order.delivered\\\',\\\\n                  order: {\\\\n                    order_id: body.orderId,\\\\n                    product_title: orderResult.product_title || \\\'Your Order\\\',\\\\n                    email: customerEmail,\\\\n                    delivered_video_url: body.videoUrl,\\\\n                    status: \\\'delivered\\\'\\\\n                  }\\\\n                })\\\\n              }).catch(err => console.error(\\\'Failed to send delivery webhook:\\\', err));\\\\n            }\\\\n          } catch (err) {\\\\n            console.error(\\\'Error triggering delivery webhook:\\\', err);\\\\n          }\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/revision\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.orderId) return json({ error: \\\'orderId required\\\' }, 400);\\\\n          \\\\n          // Get order data before updating\\\\n          const orderResult = await env.DB.prepare(\\\\n            \\\'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\\\'\\\\n          ).bind(body.orderId).first();\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'UPDATE orders SET revision_requested=1, revision_count=revision_count+1, status=? WHERE order_id=?\\\'\\\\n          ).bind(\\\'revision\\\', body.orderId).run();\\\\n          \\\\n          // Trigger revision notification webhook if configured\\\\n          try {\\\\n            const googleScriptUrl = await getGoogleScriptUrl(env);\\\\n            if (googleScriptUrl && orderResult) {\\\\n              // Extract email from encrypted data\\\\n              let customerEmail = \\\'\\\';\\\\n              try {\\\\n                const decrypted = JSON.parse(orderResult.encrypted_data);\\\\n                customerEmail = decrypted.email || \\\'\\\';\\\\n              } catch (e) {\\\\n                console.warn(\\\'Could not decrypt order data for email\\\');\\\\n              }\\\\n              \\\\n              // Send revision notification webhook\\\\n              await fetch(googleScriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'order.revision_requested\\\',\\\\n                  order: {\\\\n                    order_id: body.orderId,\\\\n                    product_title: orderResult.product_title || \\\'Your Order\\\',\\\\n                    email: customerEmail,\\\\n                    revision_reason: body.reason || \\\'No reason provided\\\',\\\\n                    revision_count: (orderResult.revision_count || 0) + 1,\\\\n                    status: \\\'revision\\\'\\\\n                  }\\\\n                })\\\\n              }).catch(err => console.error(\\\'Failed to send revision webhook:\\\', err));\\\\n            }\\\\n          } catch (err) {\\\\n            console.error(\\\'Error triggering revision webhook:\\\', err);\\\\n          }\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/portfolio\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\\n            \\\'UPDATE orders SET portfolio_enabled=? WHERE order_id=?\\\'\\\\n          ).bind(body.portfolioEnabled ? 1 : 0, body.orderId).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/archive-link\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\'UPDATE orders SET archive_url=? WHERE order_id=?\\\').bind(body.archiveUrl, body.orderId).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- REVIEWS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/reviews\\\') {\\\\n          // Support filtering by productId(s), ids and rating via query parameters.\\\\n          const params = url.searchParams;\\\\n          const rating = params.get(\\\'rating\\\');\\\\n          const productId = params.get(\\\'productId\\\');\\\\n          const productIds = params.get(\\\'productIds\\\');\\\\n          const ids = params.get(\\\'ids\\\');\\\\n          let sql = \\\'SELECT r.*, p.title as product_title FROM reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.status = ?\\\';\\\\n          /**\\\\n           * Bind values can be strings or numbers.  TypeScript incorrectly infers\\\\n           * this array as `string[]` because the first value is a string, which causes\\\\n           * type errors when numbers are pushed.  Annotate the type explicitly to\\\\n           * avoid type errors in the Cloudflare editor.\\\\n           * @type {(string|number)[]}\\\\n           */\\\\n          const binds = [\\\'approved\\\'];\\\\n          // Filter by rating\\\\n          if (rating) {\\\\n            sql += \\\' AND r.rating = ?\\\';\\\\n            binds.push(Number(rating));\\\\n          }\\\\n          // Filter by single product\\\\n          if (productId) {\\\\n            sql += \\\' AND r.product_id = ?\\\';\\\\n            binds.push(Number(productId));\\\\n          }\\\\n          // Filter by multiple products\\\\n          if (productIds) {\\\\n            const idsArr = productIds.split(\\\',\\\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\\\\n            if (idsArr.length > 0) {\\\\n              sql += ` AND r.product_id IN (${idsArr.map(() => \\\'?\\\').join(\\\',\\\')})`;\\\\n              binds.push(...idsArr);\\\\n            }\\\\n          }\\\\n          // Filter by specific review IDs\\\\n          if (ids) {\\\\n            const idsArr2 = ids.split(\\\',\\\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\\\\n            if (idsArr2.length > 0) {\\\\n              sql += ` AND r.id IN (${idsArr2.map(() => \\\'?\\\').join(\\\',\\\')})`;\\\\n              binds.push(...idsArr2);\\\\n            }\\\\n          }\\\\n          sql += \\\' ORDER BY r.created_at DESC\\\';\\\\n          const stmt = await env.DB.prepare(sql);\\\\n          const r = await stmt.bind(...binds).all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (r.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n\\\\n          return json({ reviews });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/reviews/add\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.productId || !body.rating) return json({ error: \\\'productId and rating required\\\' }, 400);\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO reviews (product_id, author_name, rating, comment, status, order_id, show_on_product) VALUES (?, ?, ?, ?, ?, ?, ?)\\\'\\\\n          ).bind(Number(body.productId), body.author || \\\'Customer\\\', Number(body.rating), body.comment || \\\'\\\', \\\'approved\\\', body.orderId || null, body.showOnProduct !== undefined ? (body.showOnProduct ? 1 : 0) : 1).run();\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/reviews/\\\')) {\\\\n           const productId = path.split(\\\'/\\\').pop();\\\\n           const r = await env.DB.prepare(\\\\n             `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n              FROM reviews \\\\n              LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n              WHERE reviews.product_id = ? AND reviews.status = ? \\\\n              ORDER BY reviews.created_at DESC`\\\\n           ).bind(Number(productId), \\\'approved\\\').all();\\\\n\\\\n           // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n           const reviews = (r.results || []).map(review => {\\\\n             if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n               review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             return review;\\\\n           });\\\\n\\\\n           return json({ reviews });\\\\n         }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/reviews/update\\\') {\\\\n          const body = await req.json();\\\\n          const id = Number(body.id);\\\\n          \\\\n          // Build dynamic update query based on provided fields\\\\n          const updates = [];\\\\n          const values = [];\\\\n          \\\\n          if (body.status !== undefined) {\\\\n            updates.push(\\\'status = ?\\\');\\\\n            values.push(body.status);\\\\n          }\\\\n          if (body.author_name !== undefined) {\\\\n            updates.push(\\\'author_name = ?\\\');\\\\n            values.push(body.author_name);\\\\n          }\\\\n          if (body.rating !== undefined) {\\\\n            updates.push(\\\'rating = ?\\\');\\\\n            values.push(Number(body.rating));\\\\n          }\\\\n          if (body.comment !== undefined) {\\\\n            updates.push(\\\'comment = ?\\\');\\\\n            values.push(body.comment);\\\\n          }\\\\n          if (body.show_on_product !== undefined) {\\\\n            updates.push(\\\'show_on_product = ?\\\');\\\\n            values.push(Number(body.show_on_product));\\\\n          }\\\\n          \\\\n          if (updates.length === 0) {\\\\n            return json({ error: \\\'No fields to update\\\' }, 400);\\\\n          }\\\\n          \\\\n          values.push(id);\\\\n          await env.DB.prepare(`UPDATE reviews SET ${updates.join(\\\', \\\')} WHERE id = ?`).bind(...values).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n\\\\n        // REMOVED: Review migration endpoint no longer needed with JOIN-based fetching\\\\n        // Migration endpoint removed as reviews now fetch delivery URLs dynamically from orders table\\\\n\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/reviews/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM reviews WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- SETTINGS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/settings/whop\\\') {\\\\n          const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n          let settings = {};\\\\n          try { if (row?.value) settings = JSON.parse(row.value); } catch(e) {}\\\\n          return json({ settings });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/settings/whop\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\\\').bind(\\\'whop\\\', JSON.stringify(body)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n\\\\n        // ----- PAGES -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages\\\') {\\\\n           const r = await env.DB.prepare(\\\'SELECT id, slug, title, status, created_at, updated_at FROM pages ORDER BY id DESC\\\').all();\\\\n\\\\n           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\\\\n           const pages = (r.results || []).map(page => {\\\\n             if (page.created_at && typeof page.created_at === \\\'string\\\') {\\\\n               page.created_at = page.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             if (page.updated_at && typeof page.updated_at === \\\'string\\\') {\\\\n               page.updated_at = page.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             return page;\\\\n           });\\\\n\\\\n           return json({ pages });\\\\n         }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/page/\\\')) {\\\\n           const slug = path.split(\\\'/\\\').pop();\\\\n           const row = await env.DB.prepare(\\\'SELECT * FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n           if (!row) return json({ error: \\\'Page not found\\\' }, 404);\\\\n\\\\n           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\\\\n           if (row.created_at && typeof row.created_at === \\\'string\\\') {\\\\n             row.created_at = row.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n           if (row.updated_at && typeof row.updated_at === \\\'string\\\') {\\\\n             row.updated_at = row.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n\\\\n           return json({ page: row });\\\\n         }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/page/save\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.slug || !body.title) return json({ error: \\\'slug and title required\\\' }, 400);\\\\n          \\\\n          if (body.id) {\\\\n            await env.DB.prepare(\\\\n              \\\'UPDATE pages SET slug=?, title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?\\\'\\\\n            ).bind(body.slug, body.title, body.content || \\\'\\\', body.meta_description || \\\'\\\', body.status || \\\'published\\\', Number(body.id)).run();\\\\n            return json({ success: true, id: body.id });\\\\n          }\\\\n          \\\\n          const r = await env.DB.prepare(\\\\n            \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(body.slug, body.title, body.content || \\\'\\\', body.meta_description || \\\'\\\', body.status || \\\'published\\\').run();\\\\n          return json({ success: true, id: r.meta?.last_row_id });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/page/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM pages WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- R2 UPLOAD -----\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/upload/temp-file\\\') {\\\\n          try {\\\\n            if (!env.R2_BUCKET) {\\\\n              console.error(\\\'R2_BUCKET not configured\\\');\\\\n              return json({ error: \\\'R2 storage not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            const sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n            const filename = url.searchParams.get(\\\'filename\\\');\\\\n\\\\n            if (!sessionId || !filename) {\\\\n              console.error(\\\'Missing sessionId or filename\\\');\\\\n              return json({ error: \\\'sessionId and filename required\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'Uploading file:\\\', filename, \\\'for session:\\\', sessionId);\\\\n\\\\n            const buf = await req.arrayBuffer();\\\\n\\\\n            // Validate file size (max 500MB for videos, 10MB for other files)\\\\n            const isVideo = filename.toLowerCase().match(/\\\\\\\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);\\\\n            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024; // 500MB for videos, 10MB for others\\\\n            const maxSizeLabel = isVideo ? \\\'500MB\\\' : \\\'10MB\\\';\\\\n            \\\\n            if (buf.byteLength > maxSize) {\\\\n              console.error(\\\'File too large:\\\', buf.byteLength, \\\'bytes (max\\\', maxSizeLabel, \\\')\\\');\\\\n              return json({\\\\n                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \\\'videos\\\' : \\\'files\\\'}.`,\\\\n                fileSize: buf.byteLength,\\\\n                maxSize: maxSize,\\\\n                fileType: isVideo ? \\\'video\\\' : \\\'file\\\'\\\\n              }, 400);\\\\n            }\\\\n\\\\n            if (!buf || buf.byteLength === 0) {\\\\n              console.error(\\\'Empty file buffer\\\');\\\\n              return json({ error: \\\'Empty file - please select a valid file\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'File size:\\\', (buf.byteLength / 1024 / 1024).toFixed(2), \\\'MB\\\');\\\\n\\\\n            const key = `temp/${sessionId}/${filename}`;\\\\n\\\\n            await env.R2_BUCKET.put(key, buf, {\\\\n              httpMetadata: { contentType: req.headers.get(\\\'content-type\\\') || \\\'application/octet-stream\\\' }\\\\n            });\\\\n\\\\n            console.log(\\\'File uploaded successfully:\\\', key);\\\\n\\\\n            return json({ success: true, tempUrl: `r2://${key}` });\\\\n          } catch (err) {\\\\n            console.error(\\\'Upload error:\\\', err);\\\\n            return json({\\\\n              error: \\\'Upload failed: \\\' + err.message,\\\\n              details: err.stack\\\\n            }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/r2/file\\\') {\\\\n          if (!env.R2_BUCKET) return json({ error: \\\'R2 not configured\\\' }, 500);\\\\n          \\\\n          const key = url.searchParams.get(\\\'key\\\');\\\\n          if (!key) return json({ error: \\\'key required\\\' }, 400);\\\\n          \\\\n          const obj = await env.R2_BUCKET.get(key);\\\\n          if (!obj) return json({ error: \\\'File not found\\\' }, 404);\\\\n          \\\\n          return new Response(obj.body, {\\\\n            headers: {\\\\n              \\\'Content-Type\\\': obj.httpMetadata?.contentType || \\\'application/octet-stream\\\',\\\\n              \\\'Cache-Control\\\': \\\'public, max-age=3600\\\'\\\\n            }\\\\n          });\\\\n        }\\\\n\\\\n        // ----- DELIVERY VIDEO UPLOAD -----\\\\n        // Two-stage upload process:\\\\n        // 1. Upload to R2 temp bucket for verification\\\\n        // 2. Upload to Archive.org for public access\\\\n        // 3. Verify both uploads succeeded before returning URL\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/upload/customer-file\\\') {\\\\n          try {\\\\n            if (!env.R2_BUCKET) {\\\\n              console.error(\\\'R2_BUCKET not configured\\\');\\\\n              return json({ error: \\\'R2 storage not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {\\\\n              console.error(\\\'Archive.org credentials not configured\\\');\\\\n              return json({ error: \\\'Archive.org credentials not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            const itemId = (url.searchParams.get(\\\'itemId\\\') || \\\'\\\').replace(/[^a-zA-Z0-9_.-]/g, \\\'-\\\');\\\\n            const filename = (url.searchParams.get(\\\'filename\\\') || \\\'\\\').replace(/[^a-zA-Z0-9_.-]/g, \\\'-\\\');\\\\n            const originalFilename = url.searchParams.get(\\\'originalFilename\\\');\\\\n\\\\n            if (!itemId || !filename) {\\\\n              console.error(\\\'Missing itemId or filename\\\');\\\\n              return json({ error: \\\'itemId and filename required\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'Starting two-stage upload:\\\', filename, \\\'Item:\\\', itemId);\\\\n\\\\n            const buf = await req.arrayBuffer();\\\\n\\\\n            // Validate file size (max 500MB for videos, 10MB for other files)\\\\n            const videoExtensions = /\\\\\\\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;\\\\n            const isVideo = videoExtensions.test(filename);\\\\n            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;\\\\n            const maxSizeLabel = isVideo ? \\\'500MB\\\' : \\\'10MB\\\';\\\\n            \\\\n            if (buf.byteLength > maxSize) {\\\\n              console.error(\\\'File too large:\\\', buf.byteLength, \\\'bytes (max\\\', maxSizeLabel, \\\')\\\');\\\\n              return json({\\\\n                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \\\'videos\\\' : \\\'files\\\'}.`,\\\\n                fileSize: buf.byteLength,\\\\n                maxSize: maxSize,\\\\n                fileType: isVideo ? \\\'video\\\' : \\\'file\\\'\\\\n              }, 400);\\\\n            }\\\\n\\\\n            if (buf.byteLength === 0) {\\\\n              console.error(\\\'Empty file\\\');\\\\n              return json({ error: \\\'Empty file - please select a valid file\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'File size:\\\', (buf.byteLength / 1024 / 1024).toFixed(2), \\\'MB\\\');\\\\n\\\\n            // Force video MIME type for video files\\\\n            const contentType = isVideo \\\\n              ? (getMimeTypeFromFilename(filename) || \\\'video/mp4\\\')\\\\n              : resolveContentType(req, filename);\\\\n            const isVideoUpload = isVideo;\\\\n\\\\n            // STAGE 1: Upload to R2 temp bucket for verification\\\\n            console.log(\\\'STAGE 1: Uploading to R2 temp bucket...\\\');\\\\n            const r2TempKey = `temp/${itemId}/${filename}`;\\\\n            try {\\\\n              await env.R2_BUCKET.put(r2TempKey, buf, {\\\\n                httpMetadata: { contentType: contentType }\\\\n              });\\\\n              console.log(\\\'R2 temp upload successful:\\\', r2TempKey);\\\\n            } catch (r2Err) {\\\\n              console.error(\\\'R2 temp upload failed:\\\', r2Err);\\\\n              return json({\\\\n                error: \\\'Failed to upload to temp storage: \\\' + r2Err.message,\\\\n                stage: \\\'r2-temp\\\',\\\\n                details: r2Err.stack\\\\n              }, 500);\\\\n            }\\\\n\\\\n            // Verify R2 file exists\\\\n            console.log(\\\'Verifying R2 temp upload...\\\');\\\\n            let r2File;\\\\n            try {\\\\n              r2File = await env.R2_BUCKET.get(r2TempKey);\\\\n              if (!r2File) {\\\\n                throw new Error(\\\'File not found in R2 after upload\\\');\\\\n              }\\\\n              console.log(\\\'R2 verification successful\\\');\\\\n            } catch (verifyErr) {\\\\n              console.error(\\\'R2 verification failed:\\\', verifyErr);\\\\n              return json({\\\\n                error: \\\'R2 upload verification failed: \\\' + verifyErr.message,\\\\n                stage: \\\'r2-verify\\\',\\\\n                details: verifyErr.stack\\\\n              }, 500);\\\\n            }\\\\n\\\\n            // Get order details for Archive.org metadata\\\\n            const orderIdFromQuery = url.searchParams.get(\\\'orderId\\\');\\\\n            let resolvedOrderId = orderIdFromQuery;\\\\n            if (!resolvedOrderId) {\\\\n              const match = itemId.match(/^delivery_(.+?)_\\\\\\\\d+$/);\\\\n              if (match) {\\\\n                resolvedOrderId = match[1];\\\\n              }\\\\n            }\\\\n\\\\n            let archiveDescription = \\\'\\\';\\\\n            if (resolvedOrderId) {\\\\n              try {\\\\n                const orderRow = await env.DB.prepare(\\\\n                  \\\'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\\\'\\\\n                ).bind(resolvedOrderId).first();\\\\n\\\\n                if (orderRow) {\\\\n                  const productTitle = orderRow.product_title || \\\'\\\';\\\\n                  const productDescription = orderRow.product_description || \\\'\\\';\\\\n\\\\n                  if (productDescription) {\\\\n                    archiveDescription = productTitle\\\\n                      ? `${productTitle} - ${productDescription}`\\\\n                      : productDescription;\\\\n                  } else {\\\\n                    archiveDescription = `Order #${orderRow.order_id} - ${productTitle || \\\'Video Delivery\\\'}`;\\\\n                  }\\\\n                } else {\\\\n                  archiveDescription = `Order #${resolvedOrderId} video delivery`;\\\\n                }\\\\n              } catch (dbErr) {\\\\n                console.warn(\\\'Could not fetch order details:\\\', dbErr);\\\\n                archiveDescription = `Order #${resolvedOrderId} video delivery`;\\\\n              }\\\\n            } else {\\\\n              archiveDescription = `${isVideoUpload ? \\\'Video\\\' : \\\'File\\\'} uploaded via order delivery system`;\\\\n            }\\\\n\\\\n            const archiveHeaders = {\\\\n              Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,\\\\n              \\\'Content-Type\\\': contentType,\\\\n              \\\'x-archive-auto-make-bucket\\\': \\\'1\\\',\\\\n              \\\'x-archive-meta-mediatype\\\': isVideoUpload ? \\\'movies\\\' : \\\'data\\\',\\\\n              \\\'x-archive-meta-collection\\\': isVideoUpload ? \\\'opensource_movies\\\' : \\\'opensource\\\',\\\\n              \\\'x-archive-meta-title\\\': normalizeArchiveMetaValue(originalFilename || filename),\\\\n              \\\'x-archive-meta-description\\\': normalizeArchiveMetaValue(archiveDescription),\\\\n              \\\'x-archive-meta-subject\\\': \\\'video; delivery\\\',\\\\n              \\\'x-archive-meta-language\\\': \\\'eng\\\'\\\\n            };\\\\n\\\\n            console.log(\\\'Archive.org Upload Metadata:\\\', {\\\\n              isVideo: isVideo,\\\\n              isVideoUpload: isVideoUpload,\\\\n              contentType: contentType,\\\\n              mediatype: archiveHeaders[\\\'x-archive-meta-mediatype\\\'],\\\\n              filename: filename,\\\\n              itemId: itemId\\\\n            });\\\\n\\\\n            // STAGE 2: Upload to Archive.org\\\\n            console.log(\\\'STAGE 2: Uploading to Archive.org...\\\');\\\\n            const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;\\\\n            let archiveResp;\\\\n            try {\\\\n              archiveResp = await fetch(archiveUrl, {\\\\n                method: \\\'PUT\\\',\\\\n                headers: archiveHeaders,\\\\n                body: buf\\\\n              });\\\\n\\\\n              if (!archiveResp.ok) {\\\\n                const errorText = await archiveResp.text().catch(() => \\\'Unknown error\\\');\\\\n                console.error(\\\'Archive.org upload failed:\\\', archiveResp.status, errorText);\\\\n                return json({\\\\n                  error: \\\'Archive.org upload failed\\\',\\\\n                  status: archiveResp.status,\\\\n                  details: errorText,\\\\n                  stage: \\\'archive-upload\\\',\\\\n                  r2Uploaded: true\\\\n                }, 502);\\\\n              }\\\\n              console.log(\\\'Archive.org upload successful, status:\\\', archiveResp.status);\\\\n            } catch (archiveErr) {\\\\n              console.error(\\\'Archive.org upload network error:\\\', archiveErr);\\\\n              return json({\\\\n                error: \\\'Failed to connect to Archive.org: \\\' + archiveErr.message,\\\\n                stage: \\\'archive-connect\\\',\\\\n                details: archiveErr.message,\\\\n                r2Uploaded: true\\\\n              }, 502);\\\\n            }\\\\n\\\\n            // STAGE 3: Wait for Archive.org to index the file\\\\n            console.log(\\\'STAGE 3: Waiting for Archive.org indexing...\\\');\\\\n            await new Promise(resolve => setTimeout(resolve, 3000));\\\\n\\\\n            // STAGE 4: Verify Archive.org file is accessible\\\\n            console.log(\\\'STAGE 4: Verifying Archive.org file...\\\');\\\\n            const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;\\\\n            const embedUrl = `https://archive.org/details/${itemId}`;\\\\n            \\\\n            let verifyAttempts = 0;\\\\n            const maxVerifyAttempts = 3;\\\\n            let archiveVerified = false;\\\\n\\\\n            while (verifyAttempts < maxVerifyAttempts && !archiveVerified) {\\\\n              verifyAttempts++;\\\\n              try {\\\\n                const verifyResp = await fetch(downloadUrl, { method: \\\'HEAD\\\' });\\\\n                if (verifyResp.ok) {\\\\n                  console.log(\\\'Archive.org file verified at attempt\\\', verifyAttempts);\\\\n                  archiveVerified = true;\\\\n                  break;\\\\n                } else if (verifyResp.status === 404 && verifyAttempts < maxVerifyAttempts) {\\\\n                  console.log(`Archive.org file not yet available (attempt ${verifyAttempts}/${maxVerifyAttempts}), waiting...`);\\\\n                  await new Promise(resolve => setTimeout(resolve, 2000));\\\\n                } else {\\\\n                  console.warn(`Archive.org verification returned status ${verifyResp.status}`);\\\\n                  break;\\\\n                }\\\\n              } catch (verifyErr) {\\\\n                console.warn(`Archive.org verification attempt ${verifyAttempts} failed:`, verifyErr.message);\\\\n                if (verifyAttempts < maxVerifyAttempts) {\\\\n                  await new Promise(resolve => setTimeout(resolve, 2000));\\\\n                }\\\\n              }\\\\n            }\\\\n\\\\n            if (!archiveVerified) {\\\\n              console.warn(\\\'Archive.org file could not be verified, but upload was successful\\\');\\\\n            }\\\\n\\\\n            console.log(\\\'Upload complete - both R2 and Archive.org successful\\\');\\\\n            return json({ \\\\n              success: true, \\\\n              url: downloadUrl,\\\\n              embedUrl: embedUrl,\\\\n              itemId: itemId,\\\\n              filename: filename,\\\\n              r2Verified: true,\\\\n              archiveVerified: archiveVerified,\\\\n              isVideo: isVideoUpload\\\\n            });\\\\n\\\\n          } catch (err) {\\\\n            console.error(\\\'Customer file upload error:\\\', err);\\\\n            return json({\\\\n              error: \\\'Upload failed: \\\' + err.message,\\\\n              details: err.stack,\\\\n              stage: \\\'unknown\\\'\\\\n            }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- ORDER ENCRYPTED FILE UPLOAD -----\\\\n        // This endpoint allows the admin UI to upload a file for a specific order.\\\\n        // The file will be stored in the configured R2 bucket and the order record\\\\n        // can be updated with a link to the uploaded file. This mirrors the\\\\n        // expectation of the admin/orders.js front\\\\u2011end which calls\\\\n        // `/api/order/upload-encrypted-file`.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/upload-encrypted-file\\\') {\\\\n          if (!env.R2_BUCKET) {\\\\n            return json({ error: \\\'R2 not configured\\\' }, 500);\\\\n          }\\\\n          const orderId = url.searchParams.get(\\\'orderId\\\');\\\\n          const itemId = url.searchParams.get(\\\'itemId\\\');\\\\n          const filename = url.searchParams.get(\\\'filename\\\');\\\\n          if (!orderId || !itemId || !filename) {\\\\n            return json({ error: \\\'orderId, itemId and filename required\\\' }, 400);\\\\n          }\\\\n          // Read the request body into a buffer\\\\n          const fileBuf = await req.arrayBuffer();\\\\n          const key = `orders/${orderId}/${itemId}/${filename}`;\\\\n          await env.R2_BUCKET.put(key, fileBuf, {\\\\n            httpMetadata: { contentType: req.headers.get(\\\'content-type\\\') || \\\'application/octet-stream\\\' }\\\\n          });\\\\n          // You could update the orders table with the uploaded file key or URL here.\\\\n          // We return the R2 key so the caller can take further action if needed.\\\\n          return json({ success: true, r2Key: key });\\\\n        }\\\\n\\\\n        // ----- PAGE BUILDER SAVE (plural) -----\\\\n        // The page builder UI posts to /api/pages/save with a JSON body containing a\\\\n        // `name` (used as slug/title) and `html` (the full HTML document). Because the\\\\n        // existing API only exposes singular `/api/page/save`, we implement this\\\\n        // convenience endpoint here. If a page with the same slug already exists,\\\\n        // it is updated instead of inserted. The HTML is stored verbatim in the\\\\n        // pages table\\\'s content column.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/save\\\') {\\\\n          const body = await req.json();\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          const html = (body.html || \\\'\\\').trim();\\\\n          if (!name || !html) {\\\\n            return json({ error: \\\'name and html required\\\' }, 400);\\\\n          }\\\\n          // Sanitize the slug: lower\\\\u2011case and replace non\\\\u2011alphanumeric characters with dashes\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Check if page already exists\\\\n          const existing = await env.DB.prepare(\\\'SELECT id FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (existing) {\\\\n            await env.DB.prepare(\\\\n              \\\'UPDATE pages SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?\\\'\\\\n            ).bind(name, html, existing.id).run();\\\\n          } else {\\\\n            await env.DB.prepare(\\\\n              \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n            ).bind(slug, name, html, \\\'\\\', \\\'published\\\').run();\\\\n          }\\\\n          return json({ success: true, slug });\\\\n        }\\\\n\\\\n        // ----- PAGES LIST (plural) -----\\\\n        // Returns a list of pages stored in the pages table, formatted for the\\\\n        // admin UI. Each entry includes a `name` (slug), `url` (path to the\\\\n        // generated static file), `uploaded` timestamp, and estimated `size`\\\\n        // (length of the HTML content). This endpoint exists to support\\\\n        // admin/pages.html which expects `/api/pages/list`.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages/list\\\') {\\\\n          // Return all pages with their publish status. The admin UI uses this to\\\\n          // display published/draft pages and provide actions.  Selecting the\\\\n          // status column allows distinguishing between published and draft.\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT slug, title, content, created_at, status FROM pages ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          const pages = (r.results || []).map(p => {\\\\n            const size = p.content ? p.content.length : 0;\\\\n            // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n            let createdAt = p.created_at;\\\\n            if (createdAt && typeof createdAt === \\\'string\\\') {\\\\n              createdAt = createdAt.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return {\\\\n              name: p.slug,\\\\n              slug: p.slug,\\\\n              title: p.title,\\\\n              url: `/${p.slug}.html`,\\\\n              uploaded: createdAt,\\\\n              size: size,\\\\n              status: p.status || \\\'published\\\'\\\\n            };\\\\n          });\\\\n          return json({ success: true, pages });\\\\n        }\\\\n\\\\n        // ----- PAGES DELETE (plural) -----\\\\n        // Deletes a page by slug/name. Accepts a JSON body with a `name` field.\\\\n        // Returns success if the page was removed. This mirrors the admin UI\\\\n        // expectation that deletion happens via POST to `/api/pages/delete`.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/delete\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM pages WHERE slug = ?\\\').bind(slug).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PAGES STATUS UPDATE -----\\\\n        // Update the publish status of a page. Accepts JSON with `name` (slug)\\\\n        // and `status` (\\\'published\\\' or \\\'draft\\\'). Updates the status column\\\\n        // accordingly. Returns an error if the page does not exist.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!name || !status) {\\\\n            return json({ error: \\\'name and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'published\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const existing = await env.DB.prepare(\\\'SELECT id FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (!existing) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE pages SET status = ? WHERE slug = ?\\\').bind(status, slug).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PAGES DUPLICATE -----\\\\n        // Duplicate an existing page into a draft. Accepts JSON with `name`\\\\n        // (slug of the existing page). Copies title, content and meta description,\\\\n        // derives a new slug by appending \\\'-copy\\\' and ensures uniqueness.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const baseSlug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const row = await env.DB.prepare(\\\'SELECT title, content, meta_description FROM pages WHERE slug = ?\\\').bind(baseSlug).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          // Determine new slug by adding \\\'-copy\\\' and ensuring uniqueness\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM pages WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM pages WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          const newTitle = (row.title || baseSlug) + \\\' Copy\\\';\\\\n          const metaDesc = row.meta_description || \\\'\\\';\\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(newSlug, newTitle, row.content || \\\'\\\', metaDesc, \\\'draft\\\').run();\\\\n          return json({ success: true, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- PAGE BUILDER LOAD (plural) -----\\\\n        // Fetch and parse a saved landing page for editing in the builder. The\\\\n        // builder expects separate `html` (the body content) and `css` (style) fields.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages/load\\\') {\\\\n          const name = url.searchParams.get(\\\'name\\\');\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const row = await env.DB.prepare(\\\'SELECT content FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          let full = row.content || \\\'\\\';\\\\n          let css = \\\'\\\';\\\\n          let htmlBody = \\\'\\\';\\\\n          try {\\\\n            // Extract CSS between <style> tags\\\\n            const styleMatch = full.match(/<style[^>]*>([\\\\\\\\s\\\\\\\\S]*?)<\\\\\\\\/style>/i);\\\\n            if (styleMatch) {\\\\n              css = styleMatch[1];\\\\n            }\\\\n            // Extract body content between <body> tags\\\\n            const bodyMatch = full.match(/<body[^>]*>([\\\\\\\\s\\\\\\\\S]*?)<\\\\\\\\/body>/i);\\\\n            htmlBody = bodyMatch ? bodyMatch[1] : full;\\\\n          } catch (e) {\\\\n            htmlBody = full;\\\\n          }\\\\n          return json({ success: true, html: htmlBody.trim(), css: css.trim() });\\\\n        }\\\\n\\\\n        // ----- WEBHOOK -----\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/webhook\\\') {\\\\n          const body = await req.text();\\\\n          console.log(\\\'Webhook received:\\\', body.substring(0, 200));\\\\n          return new Response(\\\'OK\\\', { status: 200 });\\\\n        }\\\\n\\\\n        return json({ error: \\\'API endpoint not found\\\', path, method }, 404);\\\\n      }\\\\n\\\\n      // ===== SECURE DOWNLOAD =====\\\\n      if (path.startsWith(\\\'/download/\\\')) {\\\\n        const orderId = path.split(\\\'/\\\').pop();\\\\n        const order = await env.DB.prepare(\\\\n          \\\'SELECT archive_url, delivered_video_url FROM orders WHERE order_id = ?\\\'\\\\n        ).bind(orderId).first();\\\\n\\\\n        const sourceUrl = (order?.delivered_video_url || order?.archive_url || \\\'\\\').toString().trim();\\\\n\\\\n        if (!sourceUrl) {\\\\n          return new Response(\\\'Download link expired or not found\\\', { status: 404 });\\\\n        }\\\\n\\\\n        const lowered = sourceUrl.toLowerCase();\\\\n        const openOnly =\\\\n          lowered.includes(\\\'youtube.com\\\') ||\\\\n          lowered.includes(\\\'youtu.be\\\') ||\\\\n          lowered.includes(\\\'vimeo.com\\\') ||\\\\n          lowered.includes(\\\'iframe.mediadelivery.net/embed/\\\') ||\\\\n          lowered.includes(\\\'video.bunnycdn.com/play/\\\') ||\\\\n          (lowered.includes(\\\'archive.org/details/\\\') && !lowered.includes(\\\'/download/\\\'));\\\\n\\\\n        if (openOnly) {\\\\n          return Response.redirect(sourceUrl, 302);\\\\n        }\\\\n\\\\n        const fileResp = await fetch(sourceUrl);\\\\n        if (!fileResp.ok) {\\\\n          return new Response(\\\'File not available\\\', { status: 404 });\\\\n        }\\\\n\\\\n        const srcUrl = new URL(sourceUrl, url.origin);\\\\n        let filename = srcUrl.pathname.split(\\\'/\\\').pop() || \\\'video.mp4\\\';\\\\n        try {\\\\n          filename = decodeURIComponent(filename);\\\\n        } catch (_) {}\\\\n        filename = filename.replace(/\\\\"/g, \\\'\\\');\\\\n\\\\n        const contentTypeHeader = (fileResp.headers.get(\\\'content-type\\\') || \\\'\\\').split(\\\';\\\')[0].trim();\\\\n        const contentType = contentTypeHeader || getMimeTypeFromFilename(filename) || \\\'application/octet-stream\\\';\\\\n\\\\n        const headers = new Headers({ ...CORS });\\\\n        headers.set(\\\'Content-Type\\\', contentType);\\\\n        headers.set(\\\'Content-Disposition\\\', `attachment; filename=\\\\"${filename}\\\\"`);\\\\n\\\\n        const contentLength = fileResp.headers.get(\\\'content-length\\\');\\\\n        if (contentLength) {\\\\n          headers.set(\\\'Content-Length\\\', contentLength);\\\\n        }\\\\n\\\\n        return new Response(fileResp.body, {\\\\n          status: 200,\\\\n          headers\\\\n        });\\\\n      }\\\\n\\\\n      // ===== ADMIN SPA ROUTING =====\\\\n      // All /admin/* routes (except API endpoints) serve the unified dashboard.html\\\\n      // This enables the Single Page Application (SPA) structure for the admin panel\\\\n      if (path.startsWith(\\\'/admin/\\\') && !path.startsWith(\\\'/api/\\\')) {\\\\n        // Special handling for standalone pages that remain separate\\\\n        if (path.endsWith(\\\'/page-builder.html\\\') || \\\\n            path.endsWith(\\\'/landing-builder.html\\\') ||\\\\n            path.endsWith(\\\'/product-form.html\\\')) {\\\\n          // These pages are served directly as they are complex standalone apps\\\\n          // Let them fall through to the asset serving logic below\\\\n        } else if (path === \\\'/admin/\\\' || path === \\\'/admin\\\' || path.endsWith(\\\'/dashboard.html\\\')) {\\\\n          // Serve the main dashboard.html for root admin path\\\\n          if (env.ASSETS) {\\\\n            const assetResp = await env.ASSETS.fetch(new Request(new URL(\\\'/admin/dashboard.html\\\', req.url)));\\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n          }\\\\n        } else if (path.endsWith(\\\'.html\\\')) {\\\\n          // For any other /admin/*.html requests, redirect to dashboard.html\\\\n          // This ensures all old fragmented pages load as the unified dashboard\\\\n          if (env.ASSETS) {\\\\n            const assetResp = await env.ASSETS.fetch(new Request(new URL(\\\'/admin/dashboard.html\\\', req.url)));\\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      // ===== DYNAMIC PAGES =====\\\\n      // Serve saved landing pages from the pages table. If the request path ends\\\\n      // with `.html` and a corresponding page exists in the database, return its\\\\n      // HTML content. This allows pages saved via the page builder to be\\\\n      // accessed at `/{slug}.html`.\\\\n      if (path.endsWith(\\\'.html\\\') && !path.includes(\\\'/admin/\\\')) {\\\\n        const slug = path.slice(1).replace(/\\\\\\\\.html$/, \\\'\\\');\\\\n        try {\\\\n          const row = await env.DB.prepare(\\\'SELECT content FROM pages WHERE slug = ? AND status = ?\\\').bind(slug, \\\'published\\\').first();\\\\n          if (row && row.content) {\\\\n            return new Response(row.content, {\\\\n              headers: { \\\'Content-Type\\\': \\\'text/html; charset=utf-8\\\' }\\\\n            });\\\\n          }\\\\n        } catch (e) {\\\\n          // continue to static assets\\\\n        }\\\\n      }\\\\n\\\\n      // ===== STATIC ASSETS WITH SERVER-SIDE SCHEMA INJECTION =====\\\\n      if (env.ASSETS) {\\\\n        /*\\\\n         * Serve static assets from the bound ASSETS namespace.  We wrap the\\\\n         * returned response to add headers that prevent stale caching on the\\\\n         * Cloudflare edge and include a custom version header.  Without these\\\\n         * headers it is possible for older builds to persist at the edge or in\\\\n         * the browser cache.  See https://developers.cloudflare.com/workers/\\\\n         * for guidance on controlling caching behavior.\\\\n         */\\\\n        // Support pretty product URLs: /product/<slug>\\\\n        let assetReq = req;\\\\n        let assetPath = path;\\\\n        let schemaProductId = null;\\\\n\\\\n        // Canonical product URLs: /product-<id>/<slug>\\\\n        // Render without redirecting (page JS reads the id from the querystring).\\\\n        if ((method === \\\'GET\\\' || method === \\\'HEAD\\\')) {\\\\n          const canonicalMatch = assetPath.match(/^\\\\\\\\/product-(\\\\\\\\d+)\\\\\\\\/(.+)$/);\\\\n          if (canonicalMatch) {\\\\n            const pid = Number(canonicalMatch[1]);\\\\n            if (!Number.isNaN(pid)) {\\\\n              schemaProductId = pid;\\\\n              const rewritten = new URL(req.url);\\\\n              rewritten.pathname = \\\'/_product_template.tpl\\\';\\\\n              rewritten.searchParams.set(\\\'id\\\', String(schemaProductId));\\\\n              assetReq = new Request(rewritten.toString(), req);\\\\n              assetPath = \\\'/_product_template.tpl\\\';\\\\n            }\\\\n          }\\\\n        }\\\\n\\\\n        const assetResp = await env.ASSETS.fetch(assetReq);\\\\n        \\\\n        // For HTML pages with schema placeholders, inject server-side schemas\\\\n        const contentType = assetResp.headers.get(\\\'content-type\\\') || \\\'\\\';\\\\n        // The product template is stored as a .tpl asset to avoid Clean URL redirects.\\\\n        // ASSETS may serve unknown extensions as application/octet-stream, which makes\\\\n        // browsers download it instead of rendering. Treat the template as HTML.\\\\n        const isHTML = contentType.includes(\\\'text/html\\\') || assetPath === \\\'/_product_template.tpl\\\';\\\\n        const isSuccess = assetResp.status === 200;\\\\n        \\\\n        if (isHTML && isSuccess) {\\\\n          try {\\\\n            const baseUrl = url.origin;\\\\n            let html = await assetResp.text();\\\\n            \\\\n            // Product detail page - inject individual product schema\\\\n            if (assetPath === \\\'/_product_template.tpl\\\' || assetPath === \\\'/product.html\\\' || assetPath === \\\'/product\\\') {\\\\n              const productId = schemaProductId ? String(schemaProductId) : url.searchParams.get(\\\'id\\\');\\\\n              if (productId && env.DB) {\\\\n                await initDB(env);\\\\n                const product = await env.DB.prepare(`\\\\n                  SELECT p.*, \\\\n                    COUNT(r.id) as review_count, \\\\n                    AVG(r.rating) as rating_average\\\\n                  FROM products p\\\\n                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = \\\'approved\\\'\\\\n                  WHERE p.id = ?\\\\n                  GROUP BY p.id\\\\n                `).bind(Number(productId)).first();\\\\n                \\\\n                if (product) {\\\\n                  // Fetch individual reviews for schema\\\\n                  const reviewsResult = await env.DB.prepare(`\\\\n                    SELECT * FROM reviews\\\\n                    WHERE product_id = ? AND status = \\\'approved\\\'\\\\n                    ORDER BY created_at DESC\\\\n                    LIMIT 5\\\\n                  `).bind(Number(productId)).all();\\\\n                  let reviews = reviewsResult.results || [];\\\\n\\\\n                  // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n                  reviews = reviews.map(review => {\\\\n                    if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n                      review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n                    }\\\\n                    return review;\\\\n                  });\\\\n\\\\n                  const schemaJson = generateProductSchema(product, baseUrl, reviews);\\\\n                  html = injectSchemaIntoHTML(html, \\\'product-schema\\\', schemaJson);\\\\n                }\\\\n              }\\\\n            }\\\\n            // Product listing pages - inject collection schema\\\\n            else if (path === \\\'/index.html\\\' || path === \\\'/\\\' || \\\\n                     path === \\\'/products-grid.html\\\' ||\\\\n                     path === \\\'/all-products\\\' || path === \\\'/all-products.html\\\') {\\\\n              if (env.DB) {\\\\n                await initDB(env);\\\\n                const result = await env.DB.prepare(`\\\\n                  SELECT p.id, p.title, p.slug, p.description, \\\\n                    p.thumbnail_url, p.normal_price, p.sale_price,\\\\n                    COUNT(r.id) as review_count, \\\\n                    AVG(r.rating) as rating_average\\\\n                  FROM products p\\\\n                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = \\\'approved\\\'\\\\n                  WHERE p.status = \\\'active\\\'\\\\n                  GROUP BY p.id\\\\n                  ORDER BY p.sort_order ASC, p.id DESC\\\\n                  LIMIT 50\\\\n                `).all();\\\\n                \\\\n                const products = result.results || [];\\\\n                if (products.length > 0) {\\\\n                  const schemaJson = generateCollectionSchema(products, baseUrl);\\\\n                  html = injectSchemaIntoHTML(html, \\\'collection-schema\\\', schemaJson);\\\\n                }\\\\n              }\\\\n            }\\\\n            \\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            headers.set(\\\'Content-Type\\\', \\\'text/html; charset=utf-8\\\');\\\\n            headers.set(\\\'Content-Disposition\\\', \\\'inline\\\');\\\\n            \\\\n            return new Response(html, {\\\\n              status: assetResp.status,\\\\n              headers\\\\n            });\\\\n          } catch (err) {\\\\n            console.error(\\\'Schema injection error:\\\', err);\\\\n            // Fall through to default asset serving on error\\\\n          }\\\\n        }\\\\n        \\\\n        // For non-HTML assets or on error, serve normally\\\\n        const headers = new Headers(assetResp.headers);\\\\n        headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n        headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n        headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n        // Safety: if the product template ever falls through here (e.g. schema injection error),\\\\n        // ensure the browser renders it instead of downloading.\\\\n        if (assetPath === \\\'/_product_template.tpl\\\') {\\\\n          headers.set(\\\'Content-Type\\\', \\\'text/html; charset=utf-8\\\');\\\\n          headers.set(\\\'Content-Disposition\\\', \\\'inline\\\');\\\\n        }\\\\n        return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n      }\\\\n\\\\n      return new Response(\\\'Worker is running\\\', { headers: { \\\'Content-Type\\\': \\\'text/plain\\\' } });\\\\n\\\\n    } catch (err) {\\\\n      console.error(\\\'Worker error:\\\', err);\\\\n      return json({ error: err.message, stack: err.stack }, 500);\\\\n    }\\\\n  },\\\\n\\\\n  // Scheduled handler for Cloudflare Cron Triggers\\\\n  // This runs automatically based on cron schedule in wrangler.toml\\\\n  async scheduled(event, env, ctx) {\\\\n    console.log(\\\'\\\\ud83d\\\\udd52 Scheduled cleanup running...\\\');\\\\n    \\\\n    try {\\\\n      // Initialize database\\\\n      await initDB(env);\\\\n      \\\\n      if (!env.WHOP_API_KEY) {\\\\n        console.error(\\\'WHOP_API_KEY not configured, skipping cleanup\\\');\\\\n        return;\\\\n      }\\\\n      \\\\n      // Get expired checkouts\\\\n      const expiredCheckouts = await env.DB.prepare(`\\\\n        SELECT checkout_id, product_id, expires_at\\\\n        FROM checkout_sessions\\\\n        WHERE status = \\\'pending\\\' \\\\n        AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n        ORDER BY created_at ASC\\\\n        LIMIT 50\\\\n      `).all();\\\\n      \\\\n      let deleted = 0;\\\\n      let failed = 0;\\\\n      \\\\n      for (const checkout of (expiredCheckouts.results || [])) {\\\\n        try {\\\\n          // Delete from Whop\\\\n          const deleteResponse = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n            method: \\\'DELETE\\\',\\\\n            headers: {\\\\n              \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}`\\\\n            }\\\\n          });\\\\n          \\\\n          if (deleteResponse.ok || deleteResponse.status === 404) {\\\\n            // Mark as expired in database\\\\n            await env.DB.prepare(`\\\\n              UPDATE checkout_sessions \\\\n              SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n              WHERE checkout_id = ?\\\\n            `).bind(checkout.checkout_id).run();\\\\n            \\\\n            deleted++;\\\\n            console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id);\\\\n          } else {\\\\n            failed++;\\\\n            console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, deleteResponse.status);\\\\n          }\\\\n        } catch (e) {\\\\n          failed++;\\\\n          console.error(\\\'Error deleting checkout:\\\', checkout.checkout_id, e.message);\\\\n        }\\\\n      }\\\\n      \\\\n      console.log(`\\\\u2705 Cleanup complete: ${deleted} deleted, ${failed} failed`);\\\\n    } catch (err) {\\\\n      console.error(\\\'Scheduled cleanup error:\\\', err);\\\\n    }\\\\n  }\\\\n};\\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me examine the current wrangler.toml file to understand the configuration:\n\n<function_calls>\n<execute-command>\ncat wishesu-main/wrangler.toml\n</execute-command>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "name = \\\\"wishesu1\\\\"\\\\nmain = \\\\"worker.js\\\\"\\\\ncompatibility_date = \\\\"2024-01-01\\\\"\\\\n\\\\n[assets]\\\\ndirectory = \\\\"./public\\\\"\\\\n# Expose the static asset directory as the `ASSETS` binding.  With a Worker\\\\n# script present, Cloudflare still serves matching files automatically\\\\n#\\\\u3010679589428825689\\\\u2020L551-L555\\\\u3011; however, binding the directory allows our worker to\\\\n# explicitly fetch assets and modify response headers (for example, to set\\\\n# `Cache-Control` and attach a version header)\\\\u3010679589428825689\\\\u2020L520-L544\\\\u3011.\\\\nbinding = \\\\"ASSETS\\\\"\\\\n# Always run the worker before serving assets.  This setting allows the\\\\n# worker to inject custom headers and perform routing logic before\\\\n# delegating to the static asset server.  Without this option, asset requests\\\\n# would bypass the worker entirely when a matching file exists\\\\u3010679589428825689\\\\u2020L594-L641\\\\u3011.\\\\nrun_worker_first = true\\\\nnot_found_handling = \\\\"404-page\\\\"\\\\n\\\\n[[d1_databases]]\\\\nbinding = \\\\"DB\\\\"\\\\ndatabase_name = \\\\"secure-shop-db\\\\"\\\\n\\\\n[[r2_buckets]]\\\\nbinding = \\\\"PRODUCT_MEDIA\\\\"\\\\nbucket_name = \\\\"product-media-bucket\\\\"\\\\n\\\\n[[r2_buckets]]\\\\nbinding = \\\\"R2_BUCKET\\\\"\\\\nbucket_name = \\\\"temp-uploads-bucket\\\\"\\\\n\\\\n[triggers]\\\\ncrons = [\\\\"0 2 * * *\\\\"]\\\\n\\\\n# Optional build-time variables.  You can update VERSION before each publish\\\\n# to force Cloudflare to treat your worker and static assets as a new\\\\n# deployment.  This value is also surfaced via the /api/debug endpoint and\\\\n# attached to static asset responses via the X-Worker-Version header.  It can\\\\n# help confirm that you are receiving the latest build.\\\\n[vars]\\\\nVERSION = \\\\"18\\\\"\\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nPerfect! Now I have a complete understanding of the monolithic `worker.js` file. Let me create a todo list to track the refactoring process and then proceed with the modular restructuring.\n\n<function_calls>\n<create-file file_path="todo.md">\n# TODO: Cloudflare Workers Refactoring\n\n## Planning Phase\n- [x] Analyze the monolithic worker.js file structure\n- [x] Identify all API endpoints and their logic\n- [x] Map out the required folder structure\n- [x] Review current wrangler.toml configuration\n\n## Development Phase\n- [ ] Create src/ directory structure\n- [ ] Extract response utilities to src/utils/response.js\n- [ ] Extract helper functions to src/utils/helpers.js\n- [ ] Extract database initialization to src/db/init.js\n- [ ] Create products controller (src/controllers/products.js)\n- [ ] Create orders controller (src/controllers/orders.js)\n- [ ] Create reviews controller (src/controllers/reviews.js)\n- [ ] Create chat controller (src/controllers/chat.js)\n- [ ] Create upload controller (src/controllers/upload.js)\n- [ ] Create whop controller (src/controllers/whop.js)\n- [ ] Create admin controller (src/controllers/admin.js)\n- [ ] Create pages controller (src/controllers/pages.js)\n- [ ] Create main index.js entry point\n- [ ] Update wrangler.toml configuration\n- [ ] Test import paths and dependencies\n\n## Verification Phase\n- [ ] Verify all API endpoints are preserved\n- [ ] Verify env bindings are correctly passed\n- [ ] Verify error handling is maintained\n- [ ] Verify static assets and schema injection remain in main entry point\n- [ ] Final code review and documentation\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'todo.md\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me start the refactoring process by creating the src directory structure:\n\n<function_calls>\n<execute-command>\nmkdir -p src/utils src/db src/controllers\n</execute-command>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}
{'role': 'assistant', 'content': '\nLet me start by extracting the response utilities to `src/utils/response.js`:\n\n<function_calls>\n<create-file file_path="src/utils/response.js">\n// Response utilities for Cloudflare Workers\n\n// The CORS and cache configuration for all API responses.\nexport const CORS = {\n  \'Access-Control-Allow-Origin\': \'*\',\n  \'Access-Control-Allow-Methods\': \'GET, POST, PUT, DELETE, OPTIONS\',\n  \'Access-Control-Allow-Headers\': \'Content-Type\',\n  \'Cache-Control\': \'no-store, no-cache, must-revalidate\',\n  \'Pragma\': \'no-cache\'\n};\n\n/**\n * Standard JSON response helper\n * @param {any} data - Response data\n * @param {number} status - HTTP status code (default: 200)\n * @returns {Response} Response object\n */\nexport function json(data, status = 200) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { ...CORS, \'Content-Type\': \'application/json\' }\n  });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/utils/response.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the helper functions in `src/utils/helpers.js`:\n\n<function_calls>\n<create-file file_path="src/utils/helpers.js">\n// Helper functions for Cloudflare Workers\n\n/**\n * Escape HTML to prevent XSS attacks\n * @param {string} input - Input string\n * @returns {string} Escaped HTML string\n */\nexport function escapeHtml(input) {\n  return String(input ?? \'\')\n    .replaceAll(\'&\', \'&amp;\')\n    .replaceAll(\'<\', \'&lt;\')\n    .replaceAll(\'>\', \'&gt;\')\n    .replaceAll(\'"\', \'&quot;\')\n    .replaceAll("\'", \'&#39;\');\n}\n\n/**\n * Normalize quick action text for comparison\n * @param {string} text - Input text\n * @returns {string} Normalized text\n */\nexport function normalizeQuickAction(text) {\n  return String(text || \'\')\n    .trim()\n    .replace(/\\s+/g, \' \')\n    .toLowerCase();\n}\n\n/**\n * Get MIME type from filename extension\n * @param {string} filename - Filename\n * @returns {string} MIME type\n */\nexport function getMimeTypeFromFilename(filename) {\n  const ext = (filename || \'\').split(\'.\').pop()?.toLowerCase();\n  switch (ext) {\n    case \'mp4\':\n      return \'video/mp4\';\n    case \'webm\':\n      return \'video/webm\';\n    case \'mov\':\n      return \'video/quicktime\';\n    case \'m4v\':\n      return \'video/x-m4v\';\n    case \'mkv\':\n      return \'video/x-matroska\';\n    case \'avi\':\n      return \'video/x-msvideo\';\n    case \'wmv\':\n      return \'video/x-ms-wmv\';\n    case \'flv\':\n      return \'video/x-flv\';\n    case \'jpg\':\n    case \'jpeg\':\n      return \'image/jpeg\';\n    case \'png\':\n      return \'image/png\';\n    case \'gif\':\n      return \'image/gif\';\n    case \'webp\':\n      return \'image/webp\';\n    case \'svg\':\n      return \'image/svg+xml\';\n    case \'pdf\':\n      return \'application/pdf\';\n    case \'zip\':\n      return \'application/zip\';\n    default:\n      return \'\';\n  }\n}\n\n/**\n * Resolve content type from request headers and filename\n * @param {Request} req - Request object\n * @param {string} filename - Filename\n * @returns {string} Content type\n */\nexport function resolveContentType(req, filename) {\n  const headerContentType = (req.headers.get(\'content-type\') || \'\').split(\';\')[0].trim().toLowerCase();\n  if (headerContentType && headerContentType !== \'application/octet-stream\') {\n    return headerContentType;\n  }\n  return getMimeTypeFromFilename(filename) || headerContentType || \'application/octet-stream\';\n}\n\n/**\n * Normalize archive metadata value\n * @param {string} value - Metadata value\n * @returns {string} Normalized value\n */\nexport function normalizeArchiveMetaValue(value) {\n  return (value || \'\').toString().replace(/[\\r\\n\\t]+/g, \' \').trim();\n}\n\n/**\n * Slugify string for URLs\n * @param {string} input - Input string\n * @returns {string} Slugified string\n */\nexport function slugifyStr(input) {\n  return String(input || \'\')\n    .toLowerCase()\n    .trim()\n    .replace(/[\'"`]/g, \'\')\n    .replace(/[^a-z0-9]+/g, \'-\')\n    .replace(/^-+|-+$/g, \'\')\n    .replace(/-+/g, \'-\');\n}\n\n/**\n * Generate canonical product path\n * @param {Object} product - Product object\n * @returns {string} Canonical path\n */\nexport function canonicalProductPath(product) {\n  const id = product && product.id != null ? String(product.id) : \'\';\n  const slug = (product && product.slug) ? String(product.slug) : slugifyStr(product && product.title ? product.title : \'product\');\n  return `/product-${id}/${encodeURIComponent(slug)}`;\n}\n\n/**\n * Enforce user rate limit (1 message per second)\n * @param {Object} env - Environment bindings\n * @param {string} sessionId - Chat session ID\n * @returns {Promise<void>}\n */\nexport async function enforceUserRateLimit(env, sessionId) {\n  const row = await env.DB.prepare(\n    `SELECT strftime(\'%s\', created_at) AS ts\n     FROM chat_messages\n     WHERE session_id = ? AND role = \'user\'\n     ORDER BY id DESC\n     LIMIT 1`\n  ).bind(sessionId).first();\n\n  if (!row?.ts) return;\n\n  const lastTs = Number(row.ts) || 0;\n  const nowTs = Math.floor(Date.now() / 1000);\n\n  if (nowTs - lastTs < 1) {\n    const err = new Error(\'Rate limited\');\n    err.status = 429;\n    throw err;\n  }\n}\n\n/**\n * Get latest order for email\n * @param {Object} env - Environment bindings\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} Latest order or null\n */\nexport async function getLatestOrderForEmail(env, email) {\n  const candidates = await env.DB.prepare(\n    `SELECT order_id, status, archive_url, encrypted_data, created_at\n     FROM orders\n     ORDER BY datetime(created_at) DESC\n     LIMIT 80`\n  ).all();\n\n  const list = candidates?.results || [];\n  const target = String(email || \'\').trim().toLowerCase();\n  if (!target) return null;\n\n  for (const o of list) {\n    try {\n      if (!o.encrypted_data) continue;\n      const data = JSON.parse(o.encrypted_data);\n      const e = String(data.email || \'\').trim().toLowerCase();\n      if (e && e === target) {\n        return {\n          order_id: o.order_id,\n          status: o.status,\n          trackLink: `/buyer-order.html?id=${encodeURIComponent(o.order_id)}`\n        };\n      }\n    } catch {}\n  }\n  return null;\n}\n\n/**\n * Get Whop API key from database or environment\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} API key or null\n */\nexport async function getWhopApiKey(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.api_key) {\n          return settings.api_key;\n        }\n      }\n    }\n  } catch (e) {\n    console.error(\'Error reading API key from database:\', e);\n  }\n  // Fallback to environment variable\n  return env.WHOP_API_KEY || null;\n}\n\n/**\n * Get Whop webhook secret from database or environment\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} Webhook secret or null\n */\nexport async function getWhopWebhookSecret(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.webhook_secret) {\n          return settings.webhook_secret;\n        }\n      }\n    }\n  } catch (e) {\n    console.error(\'Error reading webhook secret from database:\', e);\n  }\n  // Fallback to environment variable\n  return env.WHOP_WEBHOOK_SECRET || null;\n}\n\n/**\n * Get Google Apps Script URL from database settings\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} Script URL or null\n */\nexport async function getGoogleScriptUrl(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.google_webapp_url) {\n          return settings.google_webapp_url;\n        }\n      }\n    }\n  } catch (e) {\n    console.warn(\'Error reading Google Script URL from database:\', e);\n  }\n  return null;\n}\n\n/**\n * Helper function to generate Offer object for Product schemas\n * @param {Object} product - Product data\n * @param {string} baseUrl - Site base URL\n * @returns {Object} Offer schema\n */\nexport function generateOfferObject(product, baseUrl) {\n  const price = parseFloat(product.sale_price || product.normal_price || 0);\n  const date = new Date();\n  date.setFullYear(date.getFullYear() + 1);\n  const priceValidUntil = date.toISOString().split(\'T\')[0];\n  \n  // Check if product is digital (instant_delivery = 1 means digital/no shipping)\n  const isDigital = product.instant_delivery === 1;\n\n  const offer = {\n    "@type": "Offer",\n    "url": `${baseUrl}${canonicalProductPath(product)}`,\n    "priceCurrency": "USD",\n    "price": price.toString(),\n    "availability": "https://schema.org/InStock",\n    "itemCondition": "https://schema.org/NewCondition",\n    "priceValidUntil": priceValidUntil,\n    "seller": {\n      "@type": "Organization",\n      "name": "WishVideo"\n    }\n  };\n\n  // Only add shipping details for physical products (non-digital)\n  if (!isDigital) {\n    offer.shippingDetails = {\n      "@type": "OfferShippingDetails",\n      "shippingDestination": [\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "US"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "GB"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "CA"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "AU"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "DE"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "FR"\n        }\n      ],\n      "shippingRate": {\n        "@type": "MonetaryAmount",\n        "currency": "USD",\n        "value": "0"\n      },\n      "deliveryTime": {\n        "@type": "ShippingDeliveryTime",\n        "handlingTime": {\n          "@type": "QuantitativeValue",\n          "minValue": 0,\n          "maxValue": 1,\n          "unitCode": "DAY"\n        },\n        "transitTime": {\n          "@type": "QuantitativeValue",\n          "minValue": 1,\n          "maxValue": 3,\n          "unitCode": "DAY"\n        }\n      }\n    };\n    \n    offer.hasMerchantReturnPolicy = {\n      "@type": "MerchantReturnPolicy",\n      "applicableCountry": "US",\n      "returnPolicyCategory": "MerchantReturnNotPermitted",\n      "merchantReturnDays": 0\n    };\n  }\n\n  return offer;\n}\n\n/**\n * Generate Product schema for individual product pages\n * @param {Object} product - Product data from database\n * @param {string} baseUrl - Site base URL\n * @param {Array} reviews - Individual reviews for this product\n * @returns {string} JSON-LD schema as string\n */\nexport function generateProductSchema(product, baseUrl, reviews = []) {\n  const sku = product.slug ? `WV-${product.id}-${product.slug.toUpperCase().replace(/-/g, \'\')}` : `WV-${product.id}`;\n\n  const schema = {\n    "@context": "https://schema.org/",\n    "@type": "Product",\n    "@id": `${baseUrl}${canonicalProductPath(product)}`,\n    "name": product.title,\n    "description": product.seo_description || product.description || product.title,\n    "sku": sku,\n    "mpn": sku,\n    "image": product.thumbnail_url ? [product.thumbnail_url] : [],\n    "brand": {\n      "@type": "Brand",\n      "name": "WishVideo",\n      "logo": `${baseUrl}/favicon.ico`\n    },\n    "manufacturer": {\n      "@type": "Organization",\n      "name": "WishVideo",\n      "url": baseUrl\n    },\n    "category": "Digital Goods > Personalized Videos",\n    "offers": generateOfferObject(product, baseUrl)\n  };\n\n   // Add aggregateRating (always present, even with 0 reviews for better Rich Results)\n   schema.aggregateRating = {\n     "@type": "AggregateRating",\n     "ratingValue": parseFloat(product.rating_average) || 5.0,\n     "reviewCount": Math.max(1, parseInt(product.review_count) || 1),\n     "bestRating": 5,\n     "worstRating": 1\n   };\n\n   // Add individual reviews (first 5 for Rich Results)\n   if (reviews && reviews.length > 0) {\n     const limitedReviews = reviews.slice(0, 5);\n     schema.review = limitedReviews.map(review => ({\n      "@type": "Review",\n      "reviewRating": {\n        "@type": "Rating",\n        "ratingValue": review.rating,\n        "bestRating": 5,\n        "worstRating": 1\n      },\n      "author": {\n        "@type": "Person",\n        "name": review.author_name || "Customer"\n      },\n      "reviewBody": review.comment || "",\n      "datePublished": review.created_at ? new Date(review.created_at).toISOString().split(\'T\')[0] : new Date().toISOString().split(\'T\')[0]\n    }));\n  }\n\n  return JSON.stringify(schema);\n}\n\n/**\n * Generate ItemList schema for product collection pages\n * @param {Array} products - Array of product data\n * @param {string} baseUrl - Site base URL\n * @returns {string} JSON-LD schema as string\n */\nexport function generateCollectionSchema(products, baseUrl) {\n  if (!products || products.length === 0) {\n    return \'{}\';\n  }\n\n  const itemListElement = products.map((product, index) => {\n    const item = {\n      "@type": "ListItem",\n      "position": index + 1,\n      "url": `${baseUrl}${canonicalProductPath(product)}`,\n      "item": {\n        "@type": "Product",\n        "@id": `${baseUrl}${canonicalProductPath(product)}`,\n        "name": product.title,\n        "description": product.description || product.title,\n        "image": product.thumbnail_url || `${baseUrl}/placeholder.jpg`,\n        "brand": {\n          "@type": "Brand",\n          "name": "WishVideo"\n        },\n        "offers": generateOfferObject(product, baseUrl)\n      }\n    };\n\n    // Add aggregateRating (always present for better Rich Results)\n    item.item.aggregateRating = {\n      "@type": "AggregateRating",\n      "ratingValue": parseFloat(product.rating_average) || 5.0,\n      "reviewCount": Math.max(1, parseInt(product.review_count) || 1),\n      "bestRating": 5,\n      "worstRating": 1\n    };\n\n    return item;\n  });\n\n  const schema = {\n    "@context": "https://schema.org/",\n    "@type": "ItemList",\n    "itemListElement": itemListElement\n  };\n\n  return JSON.stringify(schema);\n}\n\n/**\n * Inject schema into HTML by replacing placeholder\n * @param {string} html - Original HTML content\n * @param {string} schemaId - ID of schema tag (product-schema or collection-schema)\n * @param {string} schemaJson - JSON-LD schema string\n * @returns {string} Modified HTML with schema injected\n */\nexport function injectSchemaIntoHTML(html, schemaId, schemaJson) {\n  // Replace empty schema placeholder with actual data\n  const placeholder = `<script type="application/ld+json" id="${schemaId}">{}</script>`;\n  const replacement = `<script type="application/ld+json" id="${schemaId}">${schemaJson}</script>`;\n  return html.replace(placeholder, replacement);\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/utils/helpers.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the database initialization module in `src/db/init.js`:\n\n<function_calls>\n<create-file file_path="src/db/init.js">\n// Database initialization and schema creation for Cloudflare Workers D1\n\nlet dbReady = false;\n\n/**\n * Initialize database and create all necessary tables\n * @param {Object} env - Environment bindings\n * @returns {Promise<void>}\n */\nexport async function initDB(env) {\n  if (dbReady || !env.DB) return;\n  \n  try {\n    await env.DB.prepare(`\n      CREATE TABLE IF NOT EXISTS products (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT, slug TEXT, description TEXT,\n        normal_price REAL, sale_price REAL,\n        instant_delivery INTEGER DEFAULT 0,\n        normal_delivery_text TEXT,\n        thumbnail_url TEXT, video_url TEXT,\n        gallery_images TEXT,\n        addons_json TEXT,\n        seo_title TEXT, seo_description TEXT, seo_keywords TEXT, seo_canonical TEXT,\n        whop_plan TEXT, whop_price_map TEXT,\n        whop_product_id TEXT,\n        status TEXT DEFAULT \'active\',\n        sort_order INTEGER DEFAULT 0\n      )\n    `).run();\n\n    // Add gallery_images column to existing products table if it doesn\'t exist\n    try {\n      await env.DB.prepare(\'SELECT gallery_images FROM products LIMIT 1\').run();\n    } catch (e) {\n      try {\n        console.log(\'Adding gallery_images column to products table...\');\n        await env.DB.prepare(\'ALTER TABLE products ADD COLUMN gallery_images TEXT\').run();\n      } catch (alterError) {\n        console.log(\'Column might already exist:\', alterError.message);\n      }\n    }\n\n    await env.DB.prepare(`\n      CREATE TABLE IF NOT EXISTS orders (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        order_id TEXT UNIQUE, product_id INTEGER,\n        encrypted_data TEXT, iv TEXT,\n        archive_url TEXT, archive_data TEXT,\n        status TEXT DEFAULT \'pending\',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT,\n        delivered_video_metadata TEXT,\n        portfolio_enabled INTEGER DEFAULT 1,\n        delivered_at DATETIME,\n        delivery_time_minutes INTEGER DEFAULT 60,\n        revision_count INTEGER DEFAULT 0,\n        revision_requested INTEGER DEFAULT 0\n      )\n    `).run();\n\n    // Add delivered_video_metadata column to existing orders table if it doesn\'t exist\n    try {\n      await env.DB.prepare(\'SELECT delivered_video_metadata FROM orders LIMIT 1\').run();\n    } catch (e) {\n      try {\n        console.log(\'Adding delivered_video_metadata column to orders table...\');\n        await env.DB.prepare(\'ALTER TABLE orders ADD COLUMN delivered_video_metadata TEXT\').run();\n      } catch (alterError) {\n        console.log(\'Column might already exist:\', alterError.message);\n      }\n    }\n\n    await env.DB.prepare(`\n      CREATE TABLE IF NOT EXISTS reviews (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        product_id INTEGER, author_name TEXT, rating INTEGER, comment TEXT,\n        status TEXT DEFAULT \'approved\',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        order_id TEXT, show_on_product INTEGER DEFAULT 1,\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT\n      )\n    `).run();\n    \n    // Auto-migration: Add delivery columns if missing\n    try {\n      const tableInfo = await env.DB.prepare(`PRAGMA table_info(reviews)`).all();\n      const columns = tableInfo.results.map(col => col.name);\n      if (!columns.includes(\'delivered_video_url\')) {\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_video_url TEXT`).run();\n      }\n      if (!columns.includes(\'delivered_thumbnail_url\')) {\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_thumbnail_url TEXT`).run();\n      }\n    } catch (e) { /* ignore */ }\n\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT)`).run();\n    \n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS pages (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      slug TEXT UNIQUE, title TEXT, content TEXT,\n      meta_description TEXT, status TEXT DEFAULT \'published\',\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n    )`).run();\n\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS checkout_sessions (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      checkout_id TEXT UNIQUE,\n      product_id INTEGER,\n      plan_id TEXT,\n      expires_at DATETIME,\n      status TEXT DEFAULT \'pending\',\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      completed_at DATETIME\n    )`).run();\n\n    \n    // Chat tables\n    await env.DB.prepare(`\n      CREATE TABLE IF NOT EXISTS chat_sessions (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        email TEXT NOT NULL,\n        blocked INTEGER DEFAULT 0,\n        last_message_content TEXT,\n        last_message_at DATETIME,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `).run();\n\n    // Add blocked column to existing chat_sessions table if it doesn\'t exist\n    try {\n      await env.DB.prepare(\'SELECT blocked FROM chat_sessions LIMIT 1\').run();\n    } catch (e) {\n      try {\n        console.log(\'Adding blocked column to chat_sessions table...\');\n        await env.DB.prepare(\'ALTER TABLE chat_sessions ADD COLUMN blocked INTEGER DEFAULT 0\').run();\n      } catch (alterError) {\n        console.log(\'Column might already exist:\', alterError.message);\n      }\n    }\n    // Add last_message_content column to existing chat_sessions table if it doesn\'t exist\n    try {\n      await env.DB.prepare(\'SELECT last_message_content FROM chat_sessions LIMIT 1\').run();\n    } catch (e) {\n      try {\n        console.log(\'Adding last_message_content column to chat_sessions table...\');\n        await env.DB.prepare(\'ALTER TABLE chat_sessions ADD COLUMN last_message_content TEXT\').run();\n      } catch (alterError) {\n        console.log(\'Column might already exist:\', alterError.message);\n      }\n    }\n\n    // Add last_message_at column to existing chat_sessions table if it doesn\'t exist\n    try {\n      await env.DB.prepare(\'SELECT last_message_at FROM chat_sessions LIMIT 1\').run();\n    } catch (e) {\n      try {\n        console.log(\'Adding last_message_at column to chat_sessions table...\');\n        await env.DB.prepare(\'ALTER TABLE chat_sessions ADD COLUMN last_message_at DATETIME\').run();\n      } catch (alterError) {\n        console.log(\'Column might already exist:\', alterError.message);\n      }\n    }\n\n\n    await env.DB.prepare(`\n      CREATE TABLE IF NOT EXISTS chat_messages (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        session_id TEXT NOT NULL,\n        role TEXT NOT NULL,\n        content TEXT NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (session_id) REFERENCES chat_sessions(id)\n      )\n    `).run();\n\n    await env.DB.prepare(`\n      CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id_id\n      ON chat_messages(session_id, id)\n    `).run();\n\n    dbReady = true;\n  } catch (e) {\n    console.error(\'DB init error:\', e);\n  }\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/db/init.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the products controller in `src/controllers/products.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/products.js">\n// Products API controller\nimport { json } from \'../utils/response.js\';\nimport { slugifyStr } from \'../utils/helpers.js\';\n\n/**\n * Get all active products with review statistics\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getProducts(env) {\n  const r = await env.DB.prepare(\n    \'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text FROM products WHERE status = ? ORDER BY sort_order ASC, id DESC\'\n  ).bind(\'active\').all();\n  \n  // Fetch review statistics for each product\n  const products = r.results || [];\n  const productsWithReviews = await Promise.all(products.map(async (product) => {\n    const stats = await env.DB.prepare(\n      \'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\'\n    ).bind(product.id, \'approved\').first();\n    \n    return {\n      ...product,\n      review_count: stats?.cnt || 0,\n      rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 0\n    };\n  }));\n  \n  return json({ products: productsWithReviews });\n}\n\n/**\n * Get a single product by ID or slug with reviews\n * @param {Object} env - Environment bindings\n * @param {string} id - Product ID or slug\n * @returns {Promise<Response>}\n */\nexport async function getProduct(env, id) {\n  let row;\n  if (isNaN(Number(id))) {\n    row = await env.DB.prepare(\'SELECT * FROM products WHERE slug = ?\').bind(id).first();\n  } else {\n    row = await env.DB.prepare(\'SELECT * FROM products WHERE id = ?\').bind(Number(id)).first();\n  }\n  if (!row) return json({ error: \'Product not found\' }, 404);\n  \n  let addons = [];\n  try {\n    addons = JSON.parse(row.addons_json || \'[]\');\n  } catch(e) {\n    console.error(\'Failed to parse addons_json for product\', row.id, \':\', e.message);\n  }\n  \n  const stats = await env.DB.prepare(\n    \'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\'\n  ).bind(row.id, \'approved\').first();\n  \n  // Fetch reviews for rich results schema (directly use review\'s own video URLs)\n  const reviewsResult = await env.DB.prepare(\n    `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \n     FROM reviews \n     LEFT JOIN orders ON reviews.order_id = orders.order_id \n     WHERE reviews.product_id = ? AND reviews.status = ? \n     ORDER BY reviews.created_at DESC`\n  ).bind(row.id, \'approved\').all();\n\n  // Convert created_at to ISO 8601 format with Z suffix for UTC\n  const reviews = (reviewsResult.results || []).map(review => {\n    if (review.created_at && typeof review.created_at === \'string\') {\n      review.created_at = review.created_at.replace(\' \', \'T\') + \'Z\';\n    }\n    if (review.updated_at && typeof review.updated_at === \'string\') {\n      review.updated_at = review.updated_at.replace(\' \', \'T\') + \'Z\';\n    }\n    return review;\n  });\n  \n  return json({\n    product: {\n      ...row,\n      addons,\n      review_count: stats?.cnt || 0,\n      rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,\n      reviews: reviews\n    },\n    addons\n  });\n}\n\n/**\n * Save a product (create or update)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Product data\n * @returns {Promise<Response>}\n */\nexport async function saveProduct(env, body) {\n  const title = (body.title || \'\').trim();\n  if (!title) return json({ error: \'Title required\' }, 400);\n  \n  const slug = (body.slug || \'\').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  const addonsJson = JSON.stringify(body.addons || []);\n  \n  if (body.id) {\n    // Prepare gallery_images as JSON string if it\'s an array\n    const galleryJson = Array.isArray(body.gallery_images) \n      ? JSON.stringify(body.gallery_images) \n      : (body.gallery_images || \'[]\');\n    \n    await env.DB.prepare(`\n      UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\n      instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\n      gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\n      whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?\n    `).bind(\n      title, slug, body.description || \'\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\n      body.instant_delivery ? 1 : 0, body.normal_delivery_text || \'\',\n      body.thumbnail_url || \'\', body.video_url || \'\', galleryJson, addonsJson,\n      body.seo_title || \'\', body.seo_description || \'\', body.seo_keywords || \'\', body.seo_canonical || \'\',\n      body.whop_plan || \'\', body.whop_price_map || \'\', body.whop_product_id || \'\', Number(body.id)\n    ).run();\n    return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });\n  }\n  \n  // Prepare gallery_images as JSON string if it\'s an array\n  const galleryJson = Array.isArray(body.gallery_images) \n    ? JSON.stringify(body.gallery_images) \n    : (body.gallery_images || \'[]\');\n  \n  const r = await env.DB.prepare(`\n    INSERT INTO products (title, slug, description, normal_price, sale_price,\n    instant_delivery, normal_delivery_text, thumbnail_url, video_url,\n    gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\n    whop_plan, whop_price_map, whop_product_id, status, sort_order)\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \'active\', 0)\n  `).bind(\n    title, slug, body.description || \'\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\n    body.instant_delivery ? 1 : 0, body.normal_delivery_text || \'\',\n    body.thumbnail_url || \'\', body.video_url || \'\', galleryJson, addonsJson,\n    body.seo_title || \'\', body.seo_description || \'\', body.seo_keywords || \'\', body.seo_canonical || \'\',\n    body.whop_plan || \'\', body.whop_price_map || \'\', body.whop_product_id || \'\'\n  ).run();\n  const newId = r.meta?.last_row_id;\n  return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });\n}\n\n/**\n * Delete a product\n * @param {Object} env - Environment bindings\n * @param {string} id - Product ID\n * @returns {Promise<Response>}\n */\nexport async function deleteProduct(env, id) {\n  if (!id) return json({ error: \'ID required\' }, 400);\n  await env.DB.prepare(\'DELETE FROM products WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n\n/**\n * Get all products for admin (including inactive)\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getProductsList(env) {\n  const r = await env.DB.prepare(\n    \'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC\'\n  ).all();\n  return json({ products: r.results || [] });\n}\n\n/**\n * Update product status\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body with id and status\n * @returns {Promise<Response>}\n */\nexport async function updateProductStatus(env, body) {\n  const id = body.id;\n  const status = (body.status || \'\').trim().toLowerCase();\n  if (!id || !status) {\n    return json({ error: \'id and status required\' }, 400);\n  }\n  if (status !== \'active\' && status !== \'draft\') {\n    return json({ error: \'invalid status\' }, 400);\n  }\n  await env.DB.prepare(\'UPDATE products SET status = ? WHERE id = ?\').bind(status, Number(id)).run();\n  return json({ success: true });\n}\n\n/**\n * Duplicate a product\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body with id\n * @returns {Promise<Response>}\n */\nexport async function duplicateProduct(env, body) {\n  const id = body.id;\n  if (!id) {\n    return json({ error: \'id required\' }, 400);\n  }\n  const row = await env.DB.prepare(\'SELECT * FROM products WHERE id = ?\').bind(Number(id)).first();\n  if (!row) {\n    return json({ error: \'Product not found\' }, 404);\n  }\n  const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  // Determine unique new slug\n  let newSlug = baseSlug + \'-copy\';\n  let idx = 1;\n  let exists = await env.DB.prepare(\'SELECT slug FROM products WHERE slug = ?\').bind(newSlug).first();\n  while (exists) {\n    newSlug = `${baseSlug}-copy${idx}`;\n    idx++;\n    exists = await env.DB.prepare(\'SELECT slug FROM products WHERE slug = ?\').bind(newSlug).first();\n  }\n  // Copy all relevant fields into a new product row\n  const r = await env.DB.prepare(\n    `INSERT INTO products (\n      title, slug, description, normal_price, sale_price,\n      instant_delivery, normal_delivery_text, thumbnail_url, video_url,\n      addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\n      whop_plan, whop_price_map, status, sort_order\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n  ).bind(\n    (row.title || \'\') + \' Copy\',\n    newSlug,\n    row.description || \'\',\n    row.normal_price || 0,\n    row.sale_price || null,\n    row.instant_delivery || 0,\n    row.normal_delivery_text || \'\',\n    row.thumbnail_url || \'\',\n    row.video_url || \'\',\n    row.addons_json || \'[]\',\n    row.seo_title || \'\',\n    row.seo_description || \'\',\n    row.seo_keywords || \'\',\n    row.seo_canonical || \'\',\n    row.whop_plan || \'\',\n    row.whop_price_map || \'\',\n    \'draft\',\n    0\n  ).run();\n  return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/products.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the orders controller in `src/controllers/orders.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/orders.js">\n// Orders API controller\nimport { json } from \'../utils/response.js\';\nimport { getGoogleScriptUrl } from \'../utils/helpers.js\';\n\n/**\n * Get all orders\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getOrders(env) {\n  const r = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n  const orders = (r.results || []).map(row => {\n    let email = \'\', amount = null, addons = [];\n    try {\n      if (row.encrypted_data && row.encrypted_data[0] === \'{\') {\n        const d = JSON.parse(row.encrypted_data);\n        email = d.email || \'\';\n        amount = d.amount;\n        addons = d.addons || [];\n      }\n    } catch(e) {\n      console.error(\'Failed to parse order encrypted_data for order:\', row.order_id, e.message);\n    }\n    return { ...row, email, amount, addons };\n  });\n  return json({ orders });\n}\n\n/**\n * Create a new order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Order data\n * @returns {Promise<Response>}\n */\nexport async function createOrder(env, body) {\n  if (!body.productId) return json({ error: \'productId required\' }, 400);\n  \n  const orderId = body.orderId || crypto.randomUUID().split(\'-\')[0].toUpperCase();\n  const data = JSON.stringify({\n    email: body.email,\n    amount: body.amount,\n    productId: body.productId,\n    addons: body.addons || []\n  });\n  \n  await env.DB.prepare(\n    \'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(orderId, Number(body.productId), data, \'PAID\', Number(body.deliveryTime) || 60).run();\n  \n  return json({ success: true, orderId });\n}\n\n/**\n * Get buyer order details\n * @param {Object} env - Environment bindings\n * @param {string} orderId - Order ID\n * @returns {Promise<Response>}\n */\nexport async function getBuyerOrder(env, orderId) {\n   const row = await env.DB.prepare(\n     \'SELECT o.*, p.title as product_title, p.thumbnail_url as product_thumbnail FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\'\n   ).bind(orderId).first();\n\n   if (!row) return json({ error: \'Order not found\' }, 404);\n\n   // Check if review already exists for this order\n   const reviewCheck = await env.DB.prepare(\n     \'SELECT id FROM reviews WHERE order_id = ? LIMIT 1\'\n   ).bind(orderId).first();\n   const hasReview = !!reviewCheck;\n\n   let addons = [], email = \'\', amount = null;\n   try {\n     if (row.encrypted_data && row.encrypted_data[0] === \'{\') {\n       const d = JSON.parse(row.encrypted_data);\n       addons = d.addons || [];\n       email = d.email || \'\';\n       amount = d.amount;\n     }\n   } catch(e) {\n     console.error(\'Failed to parse order encrypted_data for buyer order:\', orderId, e.message);\n   }\n\n   // Convert SQLite datetime to ISO 8601 format with Z suffix for UTC\n   const orderData = { ...row, addons, email, amount, has_review: hasReview };\n   if (orderData.created_at && typeof orderData.created_at === \'string\') {\n     // SQLite format: YYYY-MM-DD HH:MM:SS -> ISO 8601: YYYY-MM-DDTHH:MM:SSZ\n     orderData.created_at = orderData.created_at.replace(\' \', \'T\') + \'Z\';\n   }\n\n   return json({ order: orderData });\n}\n\n/**\n * Delete an order\n * @param {Object} env - Environment bindings\n * @param {string} id - Order ID\n * @returns {Promise<Response>}\n */\nexport async function deleteOrder(env, id) {\n  await env.DB.prepare(\'DELETE FROM orders WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n\n/**\n * Update an order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Update data\n * @returns {Promise<Response>}\n */\nexport async function updateOrder(env, body) {\n  const orderId = body.orderId;\n  \n  if (!orderId) return json({ error: \'orderId required\' }, 400);\n  \n  const updates = [];\n  const values = [];\n  \n  if (body.status !== undefined) {\n    updates.push(\'status = ?\');\n    values.push(body.status);\n  }\n  if (body.delivery_time_minutes !== undefined) {\n    updates.push(\'delivery_time_minutes = ?\');\n    values.push(Number(body.delivery_time_minutes));\n  }\n  \n  if (updates.length === 0) {\n    return json({ error: \'No fields to update\' }, 400);\n  }\n  \n  values.push(orderId);\n  await env.DB.prepare(`UPDATE orders SET ${updates.join(\', \')} WHERE order_id = ?`).bind(...values).run();\n  return json({ success: true });\n}\n\n/**\n * Create manual order (admin)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Order data\n * @returns {Promise<Response>}\n */\nexport async function createManualOrder(env, body) {\n  if (!body.productId || !body.email) {\n    return json({ error: \'productId and email required\' }, 400);\n  }\n  \n  // Generate unique order ID\n  const orderId = \'MO\' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 6).toUpperCase();\n  \n  // Store order data\n  const encryptedData = JSON.stringify({\n    email: body.email,\n    amount: body.amount || 0,\n    addons: body.notes ? [{ field: \'Admin Notes\', value: body.notes }] : [],\n    manualOrder: true\n  });\n  \n  await env.DB.prepare(\n    \'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(\n    orderId,\n    Number(body.productId),\n    encryptedData,\n    body.status || \'paid\',\n    Number(body.deliveryTime) || 60\n  ).run();\n  \n  return json({ success: true, orderId });\n}\n\n/**\n * Deliver video to order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Delivery data\n * @returns {Promise<Response>}\n */\nexport async function deliverOrder(env, body) {\n  if (!body.orderId || !body.videoUrl) return json({ error: \'orderId and videoUrl required\' }, 400);\n\n  // Get order data before updating\n  const orderResult = await env.DB.prepare(\n    \'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\'\n  ).bind(body.orderId).first();\n\n  // Prepare additional metadata for delivered videos (Archive.org + subtitles, etc)\n  const deliveredVideoMetadata = JSON.stringify({\n    embedUrl: body.embedUrl,\n    itemId: body.itemId,\n    subtitlesUrl: body.subtitlesUrl,\n    tracks: Array.isArray(body.tracks) ? body.tracks : undefined,\n    deliveredAt: new Date().toISOString()\n  });\n\n  await env.DB.prepare(\n    \'UPDATE orders SET delivered_video_url=?, delivered_thumbnail_url=?, status=?, delivered_at=CURRENT_TIMESTAMP, delivered_video_metadata=? WHERE order_id=?\'\n  ).bind(body.videoUrl, body.thumbnailUrl || null, \'delivered\', deliveredVideoMetadata, body.orderId).run();\n  \n  // Trigger email webhook if configured\n  try {\n    const googleScriptUrl = await getGoogleScriptUrl(env);\n    if (googleScriptUrl && orderResult) {\n      // Extract email from encrypted data\n      let customerEmail = \'\';\n      try {\n        const decrypted = JSON.parse(orderResult.encrypted_data);\n        customerEmail = decrypted.email || \'\';\n      } catch (e) {\n        console.warn(\'Could not decrypt order data for email\');\n      }\n      \n      // Send delivery notification webhook\n      await fetch(googleScriptUrl, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify({\n          event: \'order.delivered\',\n          order: {\n            order_id: body.orderId,\n            product_title: orderResult.product_title || \'Your Order\',\n            email: customerEmail,\n            delivered_video_url: body.videoUrl,\n            status: \'delivered\'\n          }\n        })\n      }).catch(err => console.error(\'Failed to send delivery webhook:\', err));\n    }\n  } catch (err) {\n    console.error(\'Error triggering delivery webhook:\', err);\n  }\n  \n  return json({ success: true });\n}\n\n/**\n * Request revision for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Revision data\n * @returns {Promise<Response>}\n */\nexport async function requestRevision(env, body) {\n  if (!body.orderId) return json({ error: \'orderId required\' }, 400);\n  \n  // Get order data before updating\n  const orderResult = await env.DB.prepare(\n    \'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\'\n  ).bind(body.orderId).first();\n  \n  await env.DB.prepare(\n    \'UPDATE orders SET revision_requested=1, revision_count=revision_count+1, status=? WHERE order_id=?\'\n  ).bind(\'revision\', body.orderId).run();\n  \n  // Trigger revision notification webhook if configured\n  try {\n    const googleScriptUrl = await getGoogleScriptUrl(env);\n    if (googleScriptUrl && orderResult) {\n      // Extract email from encrypted data\n      let customerEmail = \'\';\n      try {\n        const decrypted = JSON.parse(orderResult.encrypted_data);\n        customerEmail = decrypted.email || \'\';\n      } catch (e) {\n        console.warn(\'Could not decrypt order data for email\');\n      }\n      \n      // Send revision notification webhook\n      await fetch(googleScriptUrl, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify({\n          event: \'order.revision_requested\',\n          order: {\n            order_id: body.orderId,\n            product_title: orderResult.product_title || \'Your Order\',\n            email: customerEmail,\n            revision_reason: body.reason || \'No reason provided\',\n            revision_count: (orderResult.revision_count || 0) + 1,\n            status: \'revision\'\n          }\n        })\n      }).catch(err => console.error(\'Failed to send revision webhook:\', err));\n    }\n  } catch (err) {\n    console.error(\'Error triggering revision webhook:\', err);\n  }\n  \n  return json({ success: true });\n}\n\n/**\n * Update portfolio settings for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Portfolio data\n * @returns {Promise<Response>}\n */\nexport async function updatePortfolio(env, body) {\n  await env.DB.prepare(\n    \'UPDATE orders SET portfolio_enabled=? WHERE order_id=?\'\n  ).bind(body.portfolioEnabled ? 1 : 0, body.orderId).run();\n  return json({ success: true });\n}\n\n/**\n * Update archive URL for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Archive data\n * @returns {Promise<Response>}\n */\nexport async function updateArchiveUrl(env, body) {\n  await env.DB.prepare(\'UPDATE orders SET archive_url=? WHERE order_id=?\').bind(body.archiveUrl, body.orderId).run();\n  return json({ success: true });\n}\n\n/**\n * Upload encrypted file for order\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {Object} queryParams - Query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadEncryptedFile(env, req, queryParams) {\n  if (!env.R2_BUCKET) {\n    return json({ error: \'R2 not configured\' }, 500);\n  }\n  const orderId = queryParams.get(\'orderId\');\n  const itemId = queryParams.get(\'itemId\');\n  const filename = queryParams.get(\'filename\');\n  if (!orderId || !itemId || !filename) {\n    return json({ error: \'orderId, itemId and filename required\' }, 400);\n  }\n  // Read the request body into a buffer\n  const fileBuf = await req.arrayBuffer();\n  const key = `orders/${orderId}/${itemId}/${filename}`;\n  await env.R2_BUCKET.put(key, fileBuf, {\n    httpMetadata: { contentType: req.headers.get(\'content-type\') || \'application/octet-stream\' }\n  });\n  // You could update the orders table with the uploaded file key or URL here.\n  // We return the R2 key so the caller can take further action if needed.\n  return json({ success: true, r2Key: key });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/orders.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the reviews controller in `src/controllers/reviews.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/reviews.js">\n// Reviews API controller\nimport { json } from \'../utils/response.js\';\n\n/**\n * Get all reviews with optional filtering\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function getReviews(env, url) {\n  // Support filtering by productId(s), ids and rating via query parameters.\n  const params = url.searchParams;\n  const rating = params.get(\'rating\');\n  const productId = params.get(\'productId\');\n  const productIds = params.get(\'productIds\');\n  const ids = params.get(\'ids\');\n  let sql = \'SELECT r.*, p.title as product_title FROM reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.status = ?\';\n  /**\n   * Bind values can be strings or numbers.  TypeScript incorrectly infers\n   * this array as `string[]` because the first value is a string, which causes\n   * type errors when numbers are pushed.  Annotate the type explicitly to\n   * avoid type errors in the Cloudflare editor.\n   * @type {(string|number)[]}\n   */\n  const binds = [\'approved\'];\n  // Filter by rating\n  if (rating) {\n    sql += \' AND r.rating = ?\';\n    binds.push(Number(rating));\n  }\n  // Filter by single product\n  if (productId) {\n    sql += \' AND r.product_id = ?\';\n    binds.push(Number(productId));\n  }\n  // Filter by multiple products\n  if (productIds) {\n    const idsArr = productIds.split(\',\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\n    if (idsArr.length > 0) {\n      sql += ` AND r.product_id IN (${idsArr.map(() => \'?\').join(\',\')})`;\n      binds.push(...idsArr);\n    }\n  }\n  // Filter by specific review IDs\n  if (ids) {\n    const idsArr2 = ids.split(\',\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\n    if (idsArr2.length > 0) {\n      sql += ` AND r.id IN (${idsArr2.map(() => \'?\').join(\',\')})`;\n      binds.push(...idsArr2);\n    }\n  }\n  sql += \' ORDER BY r.created_at DESC\';\n  const stmt = await env.DB.prepare(sql);\n  const r = await stmt.bind(...binds).all();\n\n  // Convert created_at to ISO 8601 format with Z suffix for UTC\n  const reviews = (r.results || []).map(review => {\n    if (review.created_at && typeof review.created_at === \'string\') {\n      review.created_at = review.created_at.replace(\' \', \'T\') + \'Z\';\n    }\n    return review;\n  });\n\n  return json({ reviews });\n}\n\n/**\n * Get reviews for a specific product\n * @param {Object} env - Environment bindings\n * @param {string} productId - Product ID\n * @returns {Promise<Response>}\n */\nexport async function getProductReviews(env, productId) {\n   const r = await env.DB.prepare(\n     `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \n      FROM reviews \n      LEFT JOIN orders ON reviews.order_id = orders.order_id \n      WHERE reviews.product_id = ? AND reviews.status = ? \n      ORDER BY reviews.created_at DESC`\n   ).bind(Number(productId), \'approved\').all();\n\n   // Convert created_at to ISO 8601 format with Z suffix for UTC\n   const reviews = (r.results || []).map(review => {\n     if (review.created_at && typeof review.created_at === \'string\') {\n       review.created_at = review.created_at.replace(\' \', \'T\') + \'Z\';\n     }\n     return review;\n   });\n\n   return json({ reviews });\n}\n\n/**\n * Add a new review\n * @param {Object} env - Environment bindings\n * @param {Object} body - Review data\n * @returns {Promise<Response>}\n */\nexport async function addReview(env, body) {\n  if (!body.productId || !body.rating) return json({ error: \'productId and rating required\' }, 400);\n  \n  await env.DB.prepare(\n    \'INSERT INTO reviews (product_id, author_name, rating, comment, status, order_id, show_on_product) VALUES (?, ?, ?, ?, ?, ?, ?)\'\n  ).bind(Number(body.productId), body.author || \'Customer\', Number(body.rating), body.comment || \'\', \'approved\', body.orderId || null, body.showOnProduct !== undefined ? (body.showOnProduct ? 1 : 0) : 1).run();\n  \n  return json({ success: true });\n}\n\n/**\n * Update a review\n * @param {Object} env - Environment bindings\n * @param {Object} body - Update data\n * @returns {Promise<Response>}\n */\nexport async function updateReview(env, body) {\n  const id = Number(body.id);\n  \n  // Build dynamic update query based on provided fields\n  const updates = [];\n  const values = [];\n  \n  if (body.status !== undefined) {\n    updates.push(\'status = ?\');\n    values.push(body.status);\n  }\n  if (body.author_name !== undefined) {\n    updates.push(\'author_name = ?\');\n    values.push(body.author_name);\n  }\n  if (body.rating !== undefined) {\n    updates.push(\'rating = ?\');\n    values.push(Number(body.rating));\n  }\n  if (body.comment !== undefined) {\n    updates.push(\'comment = ?\');\n    values.push(body.comment);\n  }\n  if (body.show_on_product !== undefined) {\n    updates.push(\'show_on_product = ?\');\n    values.push(Number(body.show_on_product));\n  }\n  \n  if (updates.length === 0) {\n    return json({ error: \'No fields to update\' }, 400);\n  }\n  \n  values.push(id);\n  await env.DB.prepare(`UPDATE reviews SET ${updates.join(\', \')} WHERE id = ?`).bind(...values).run();\n  return json({ success: true });\n}\n\n/**\n * Delete a review\n * @param {Object} env - Environment bindings\n * @param {string} id - Review ID\n * @returns {Promise<Response>}\n */\nexport async function deleteReview(env, id) {\n  await env.DB.prepare(\'DELETE FROM reviews WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/reviews.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the chat controller in `src/controllers/chat.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/chat.js">\n// Chat API controller\nimport { json } from \'../utils/response.js\';\nimport { escapeHtml, enforceUserRateLimit, normalizeQuickAction, getLatestOrderForEmail, getGoogleScriptUrl } from \'../utils/helpers.js\';\n\n/**\n * Start a new chat session\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function startChat(env, body) {\n  const nameIn = String(body.name || \'\').trim();\n  const emailIn = String(body.email || \'\').trim();\n\n  if (!nameIn || !emailIn) return json({ error: \'Name and email are required\' }, 400);\n\n  // Basic normalization\n  const email = emailIn.toLowerCase();\n  const name = nameIn;\n\n  // One email = one session (reuse + cleanup)\n  const canonical = await env.DB.prepare(\n    `SELECT id, name, created_at\n     FROM chat_sessions\n     WHERE lower(email) = lower(?)\n     ORDER BY datetime(created_at) ASC\n     LIMIT 1`\n  ).bind(email).first();\n\n  if (canonical?.id) {\n    const canonicalId = String(canonical.id);\n\n    // Update name if it changed (optional but keeps admin tidy)\n    if (name && canonical.name !== name) {\n      await env.DB.prepare(\n        `UPDATE chat_sessions SET name = ? WHERE id = ?`\n      ).bind(name, canonicalId).run();\n    }\n\n    // Migrate any stray sessions/messages for this email into the canonical session\n    const others = await env.DB.prepare(\n      `SELECT id FROM chat_sessions\n       WHERE lower(email) = lower(?) AND id != ?`\n    ).bind(email, canonicalId).all();\n\n    const otherIds = (others?.results || []).map(r => String(r.id));\n    for (const sid of otherIds) {\n      await env.DB.prepare(\n        `UPDATE chat_messages SET session_id = ? WHERE session_id = ?`\n      ).bind(canonicalId, sid).run();\n\n      await env.DB.prepare(\n        `DELETE FROM chat_sessions WHERE id = ?`\n      ).bind(sid).run();\n    }\n\n    return json({ sessionId: canonicalId, reused: true });\n  }\n\n  // Create new session\n  const sessionId = crypto.randomUUID();\n\n  await env.DB.prepare(\n    `INSERT INTO chat_sessions (id, name, email) VALUES (?, ?, ?)`\n  ).bind(sessionId, escapeHtml(name), escapeHtml(email)).run();\n\n  return json({ sessionId, reused: false });\n}\n\n/**\n * Sync chat messages\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function syncChat(env, url) {\n  const sessionId = url.searchParams.get(\'sessionId\');\n  const sinceIdRaw = url.searchParams.get(\'sinceId\') || \'0\';\n  const sinceId = Number(sinceIdRaw) || 0;\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  const rows = await env.DB.prepare(\n    `SELECT id, role, content, created_at\n     FROM chat_messages\n     WHERE session_id = ? AND id > ?\n     ORDER BY id ASC\n     LIMIT 100`\n  ).bind(sessionId, sinceId).all();\n\n  const messages = rows?.results || [];\n  const lastId = messages.length ? messages[messages.length - 1].id : sinceId;\n\n  return json({ messages, lastId });\n}\n\n/**\n * Send a chat message\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function sendChat(env, req, body) {\n  const sessionId = String(body.sessionId || \'\').trim();\n  const roleRaw = String(body.role || \'user\').trim().toLowerCase();\n\n  // accept content or message\n  const rawContent = String(body.content ?? body.message ?? \'\');\n\n  const role = [\'user\', \'admin\', \'system\'].includes(roleRaw) ? roleRaw : \'user\';\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  // Strict blocking: do not allow blocked sessions to send customer messages\n  const sess = await env.DB.prepare(\n    `SELECT blocked FROM chat_sessions WHERE id = ?`\n  ).bind(sessionId).first();\n\n  if (role === \'user\' && Number(sess?.blocked || 0) === 1) {\n    return json({ success: false, error: "You have been blocked by support." }, 403);\n  }\n\n  const trimmed = rawContent.trim();\n  if (!trimmed) return json({ error: \'content is required\' }, 400);\n\n  // 500 char limit (backend)\n  if (trimmed.length > 500) return json({ error: \'Message too long (max 500 characters)\' }, 400);\n\n  // Rate limit customers only (1 msg/sec)\n  try {\n    if (role === \'user\') await enforceUserRateLimit(env, sessionId);\n  } catch (e) {\n    if (e?.status === 429) return json({ error: \'Too many messages. Please wait a moment.\' }, 429);\n    throw e;\n  }\n\n  // Determine if this is the user\'s first message BEFORE inserting\n  let isFirstUserMessage = false;\n  if (role === \'user\') {\n    const countRow = await env.DB.prepare(\n      `SELECT COUNT(*) as c\n       FROM chat_messages\n       WHERE session_id = ? AND role = \'user\'`\n    ).bind(sessionId).first();\n    isFirstUserMessage = Number(countRow?.c || 0) === 0;\n  }\n\n  // XSS protection: escape before storing\n  const safeContent = escapeHtml(trimmed);\n\n  const insertRes = await env.DB.prepare(\n    `INSERT INTO chat_messages (session_id, role, content) VALUES (?, ?, ?)`\n  ).bind(sessionId, role, safeContent).run();\n\n  // Update denormalized last-message fields for fast admin listing\n  try {\n    await env.DB.prepare(\n      `UPDATE chat_sessions\n       SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n       WHERE id = ?`\n    ).bind(safeContent, sessionId).run();\n  } catch (e) {\n    console.error(\'Failed to update chat_sessions last-message fields:\', e);\n  }\n\n  // Trigger email alert webhook on first customer message\n  if (isFirstUserMessage) {\n    try {\n      const setting = await env.DB.prepare(\n        `SELECT value FROM settings WHERE key = ?`\n      ).bind(\'GOOGLE_SCRIPT_URL\').first();\n\n      const scriptUrl = String(setting?.value || \'\').trim();\n\n      if (scriptUrl) {\n        const session = await env.DB.prepare(\n          `SELECT id, name, email, created_at FROM chat_sessions WHERE id = ?`\n        ).bind(sessionId).first();\n\n        await fetch(scriptUrl, {\n          method: \'POST\',\n          headers: { \'Content-Type\': \'application/json\' },\n          body: JSON.stringify({\n            event: \'first_customer_message\',\n            sessionId,\n            name: session?.name || null,\n            email: session?.email || null,\n            created_at: session?.created_at || null,\n            message: trimmed\n          })\n        });\n      }\n    } catch (e) {\n      console.error(\'Chat webhook trigger failed:\', e);\n    }\n  }\n\n  // ------------------------------\n  // Smart Quick Action Auto-Replies\n  // ------------------------------\n  if (role === \'user\') {\n    const normalized = normalizeQuickAction(trimmed);\n    const session = await env.DB.prepare(\n      `SELECT email FROM chat_sessions WHERE id = ?`\n    ).bind(sessionId).first();\n\n    const email = String(session?.email || \'\').trim();\n    const origin = new URL(req.url).origin;\n\n    // "My Order Status"\n    if (normalized === \'my order status\') {\n      let replyText = "We couldn\'t find any recent orders for this email.";\n\n      if (email) {\n        const lastOrder = await getLatestOrderForEmail(env, email);\n        if (lastOrder) {\n          const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\n          replyText = `Your last order #${lastOrder.order_id} is currently ${lastOrder.status || \'unknown\'}. Track it here: ${link}`;\n        }\n      }\n\n      const safeReply = escapeHtml(replyText);\n      await env.DB.prepare(\n        `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \'system\', ?)`\n      ).bind(sessionId, safeReply).run();\n\n      // Update denormalized last-message fields\n      try {\n        await env.DB.prepare(\n          `UPDATE chat_sessions\n           SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n           WHERE id = ?`\n        ).bind(safeReply, sessionId).run();\n      } catch (e) {\n        console.error(\'Failed to update chat_sessions last-message fields:\', e);\n      }\n    }\n\n    // "Check Delivery Status"\n    if (normalized === \'check delivery status\') {\n      let replyText = "No recent orders found for this email.";\n\n      if (email) {\n        const lastOrder = await getLatestOrderForEmail(env, email);\n        if (lastOrder) {\n          const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\n          replyText = `Your last order is ${lastOrder.status || \'unknown\'}. View details here: ${link}`;\n        }\n      }\n\n      const safeReply = escapeHtml(replyText);\n      await env.DB.prepare(\n        `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \'system\', ?)`\n      ).bind(sessionId, safeReply).run();\n\n      // Update denormalized last-message fields\n      try {\n        await env.DB.prepare(\n          `UPDATE chat_sessions\n           SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n           WHERE id = ?`\n        ).bind(safeReply, sessionId).run();\n      } catch (e) {\n        console.error(\'Failed to update chat_sessions last-message fields:\', e);\n      }\n    }\n  }\n\n  return json({ success: true, messageId: insertRes?.meta?.last_row_id || null });\n}\n\n/**\n * Get all chat sessions for admin\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getChatSessions(env) {\n  // One row per email (canonical session = oldest created_at for that email)\n  // Denormalized fields on chat_sessions let us avoid heavy subqueries.\n  const rows = await env.DB.prepare(\n    `SELECT\n       s.id,\n       s.name,\n       s.email,\n       s.blocked,\n       s.last_message_at,\n       s.last_message_content AS last_message,\n       s.created_at\n     FROM chat_sessions s\n     JOIN (\n       SELECT lower(email) AS em, MIN(datetime(created_at)) AS min_created\n       FROM chat_sessions\n       GROUP BY lower(email)\n     ) x\n       ON lower(s.email) = x.em AND datetime(s.created_at) = x.min_created\n     ORDER BY COALESCE(s.last_message_at, s.created_at) DESC\n     LIMIT 200`\n  ).all();\n\n  return json({ sessions: rows?.results || [] });\n}\n\n/**\n * Block/unblock a chat session\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function blockChatSession(env, body) {\n  const sessionId = String(body.sessionId || \'\').trim();\n  const blocked = body.blocked === true || body.blocked === 1 || body.blocked === \'true\';\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  await env.DB.prepare(\n    `UPDATE chat_sessions SET blocked = ? WHERE id = ?`\n  ).bind(blocked ? 1 : 0, sessionId).run();\n\n  return json({ success: true, blocked: blocked ? 1 : 0 });\n}\n\n/**\n * Delete a chat session and its messages\n * @param {Object} env - Environment bindings\n * @param {string} sessionId - Session ID (from query or body)\n * @param {Object} body - Optional request body\n * @returns {Promise<Response>}\n */\nexport async function deleteChatSession(env, sessionId, body = {}) {\n  if (!sessionId) {\n    sessionId = String(body.sessionId || \'\').trim();\n  }\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  // Delete messages first, then session\n  await env.DB.prepare(`DELETE FROM chat_messages WHERE session_id = ?`).bind(sessionId).run();\n  await env.DB.prepare(`DELETE FROM chat_sessions WHERE id = ?`).bind(sessionId).run();\n\n  return json({ success: true });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/chat.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the upload controller in `src/controllers/upload.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/upload.js">\n// Upload API controller\nimport { json } from \'../utils/response.js\';\nimport { getMimeTypeFromFilename, resolveContentType, normalizeArchiveMetaValue } from \'../utils/helpers.js\';\n\n/**\n * Upload temporary file to R2\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadTempFile(env, req, url) {\n  try {\n    if (!env.R2_BUCKET) {\n      console.error(\'R2_BUCKET not configured\');\n      return json({ error: \'R2 storage not configured\' }, 500);\n    }\n\n    const sessionId = url.searchParams.get(\'sessionId\');\n    const filename = url.searchParams.get(\'filename\');\n\n    if (!sessionId || !filename) {\n      console.error(\'Missing sessionId or filename\');\n      return json({ error: \'sessionId and filename required\' }, 400);\n    }\n\n    console.log(\'Uploading file:\', filename, \'for session:\', sessionId);\n\n    const buf = await req.arrayBuffer();\n\n    // Validate file size (max 500MB for videos, 10MB for other files)\n    const isVideo = filename.toLowerCase().match(/\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);\n    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024; // 500MB for videos, 10MB for others\n    const maxSizeLabel = isVideo ? \'500MB\' : \'10MB\';\n    \n    if (buf.byteLength > maxSize) {\n      console.error(\'File too large:\', buf.byteLength, \'bytes (max\', maxSizeLabel, \')\');\n      return json({\n        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \'videos\' : \'files\'}.`,\n        fileSize: buf.byteLength,\n        maxSize: maxSize,\n        fileType: isVideo ? \'video\' : \'file\'\n      }, 400);\n    }\n\n    if (!buf || buf.byteLength === 0) {\n      console.error(\'Empty file buffer\');\n      return json({ error: \'Empty file - please select a valid file\' }, 400);\n    }\n\n    console.log(\'File size:\', (buf.byteLength / 1024 / 1024).toFixed(2), \'MB\');\n\n    const key = `temp/${sessionId}/${filename}`;\n\n    await env.R2_BUCKET.put(key, buf, {\n      httpMetadata: { contentType: req.headers.get(\'content-type\') || \'application/octet-stream\' }\n    });\n\n    console.log(\'File uploaded successfully:\', key);\n\n    return json({ success: true, tempUrl: `r2://${key}` });\n  } catch (err) {\n    console.error(\'Upload error:\', err);\n    return json({\n      error: \'Upload failed: \' + err.message,\n      details: err.stack\n    }, 500);\n  }\n}\n\n/**\n * Get file from R2\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function getR2File(env, url) {\n  if (!env.R2_BUCKET) return json({ error: \'R2 not configured\' }, 500);\n  \n  const key = url.searchParams.get(\'key\');\n  if (!key) return json({ error: \'key required\' }, 400);\n  \n  const obj = await env.R2_BUCKET.get(key);\n  if (!obj) return json({ error: \'File not found\' }, 404);\n  \n  return new Response(obj.body, {\n    headers: {\n      \'Content-Type\': obj.httpMetadata?.contentType || \'application/octet-stream\',\n      \'Cache-Control\': \'public, max-age=3600\'\n    }\n  });\n}\n\n/**\n * Upload customer file (delivery video) with two-stage process\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadCustomerFile(env, req, url) {\n  try {\n    if (!env.R2_BUCKET) {\n      console.error(\'R2_BUCKET not configured\');\n      return json({ error: \'R2 storage not configured\' }, 500);\n    }\n\n    if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {\n      console.error(\'Archive.org credentials not configured\');\n      return json({ error: \'Archive.org credentials not configured\' }, 500);\n    }\n\n    const itemId = (url.searchParams.get(\'itemId\') || \'\').replace(/[^a-zA-Z0-9_.-]/g, \'-\');\n    const filename = (url.searchParams.get(\'filename\') || \'\').replace(/[^a-zA-Z0-9_.-]/g, \'-\');\n    const originalFilename = url.searchParams.get(\'originalFilename\');\n\n    if (!itemId || !filename) {\n      console.error(\'Missing itemId or filename\');\n      return json({ error: \'itemId and filename required\' }, 400);\n    }\n\n    console.log(\'Starting two-stage upload:\', filename, \'Item:\', itemId);\n\n    const buf = await req.arrayBuffer();\n\n    // Validate file size (max 500MB for videos, 10MB for other files)\n    const videoExtensions = /\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;\n    const isVideo = videoExtensions.test(filename);\n    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;\n    const maxSizeLabel = isVideo ? \'500MB\' : \'10MB\';\n    \n    if (buf.byteLength > maxSize) {\n      console.error(\'File too large:\', buf.byteLength, \'bytes (max\', maxSizeLabel, \')\');\n      return json({\n        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \'videos\' : \'files\'}.`,\n        fileSize: buf.byteLength,\n        maxSize: maxSize,\n        fileType: isVideo ? \'video\' : \'file\'\n      }, 400);\n    }\n\n    if (buf.byteLength === 0) {\n      console.error(\'Empty file\');\n      return json({ error: \'Empty file - please select a valid file\' }, 400);\n    }\n\n    console.log(\'File size:\', (buf.byteLength / 1024 / 1024).toFixed(2), \'MB\');\n\n    // Force video MIME type for video files\n    const contentType = isVideo \n      ? (getMimeTypeFromFilename(filename) || \'video/mp4\')\n      : resolveContentType(req, filename);\n    const isVideoUpload = isVideo;\n\n    // STAGE 1: Upload to R2 temp bucket for verification\n    console.log(\'STAGE 1: Uploading to R2 temp bucket...\');\n    const r2TempKey = `temp/${itemId}/${filename}`;\n    try {\n      await env.R2_BUCKET.put(r2TempKey, buf, {\n        httpMetadata: { contentType: contentType }\n      });\n      console.log(\'R2 temp upload successful:\', r2TempKey);\n    } catch (r2Err) {\n      console.error(\'R2 temp upload failed:\', r2Err);\n      return json({\n        error: \'Failed to upload to temp storage: \' + r2Err.message,\n        stage: \'r2-temp\',\n        details: r2Err.stack\n      }, 500);\n    }\n\n    // Verify R2 file exists\n    console.log(\'Verifying R2 temp upload...\');\n    let r2File;\n    try {\n      r2File = await env.R2_BUCKET.get(r2TempKey);\n      if (!r2File) {\n        throw new Error(\'File not found in R2 after upload\');\n      }\n      console.log(\'R2 verification successful\');\n    } catch (verifyErr) {\n      console.error(\'R2 verification failed:\', verifyErr);\n      return json({\n        error: \'R2 upload verification failed: \' + verifyErr.message,\n        stage: \'r2-verify\',\n        details: verifyErr.stack\n      }, 500);\n    }\n\n    // Get order details for Archive.org metadata\n    const orderIdFromQuery = url.searchParams.get(\'orderId\');\n    let resolvedOrderId = orderIdFromQuery;\n    if (!resolvedOrderId) {\n      const match = itemId.match(/^delivery_(.+?)_\\d+$/);\n      if (match) {\n        resolvedOrderId = match[1];\n      }\n    }\n\n    let archiveDescription = \'\';\n    if (resolvedOrderId) {\n      try {\n        const orderRow = await env.DB.prepare(\n          \'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\'\n        ).bind(resolvedOrderId).first();\n\n        if (orderRow) {\n          const productTitle = orderRow.product_title || \'\';\n          const productDescription = orderRow.product_description || \'\';\n\n          if (productDescription) {\n            archiveDescription = productTitle\n              ? `${productTitle} - ${productDescription}`\n              : productDescription;\n          } else {\n            archiveDescription = `Order #${orderRow.order_id} - ${productTitle || \'Video Delivery\'}`;\n          }\n        } else {\n          archiveDescription = `Order #${resolvedOrderId} video delivery`;\n        }\n      } catch (dbErr) {\n        console.warn(\'Could not fetch order details:\', dbErr);\n        archiveDescription = `Order #${resolvedOrderId} video delivery`;\n      }\n    } else {\n      archiveDescription = `${isVideoUpload ? \'Video\' : \'File\'} uploaded via order delivery system`;\n    }\n\n    const archiveHeaders = {\n      Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,\n      \'Content-Type\': contentType,\n      \'x-archive-auto-make-bucket\': \'1\',\n      \'x-archive-meta-mediatype\': isVideoUpload ? \'movies\' : \'data\',\n      \'x-archive-meta-collection\': isVideoUpload ? \'opensource_movies\' : \'opensource\',\n      \'x-archive-meta-title\': normalizeArchiveMetaValue(originalFilename || filename),\n      \'x-archive-meta-description\': normalizeArchiveMetaValue(archiveDescription),\n      \'x-archive-meta-subject\': \'video; delivery\',\n      \'x-archive-meta-language\': \'eng\'\n    };\n\n    console.log(\'Archive.org Upload Metadata:\', {\n      isVideo: isVideo,\n      isVideoUpload: isVideoUpload,\n      contentType: contentType,\n      mediatype: archiveHeaders[\'x-archive-meta-mediatype\'],\n      filename: filename,\n      itemId: itemId\n    });\n\n    // STAGE 2: Upload to Archive.org\n    console.log(\'STAGE 2: Uploading to Archive.org...\');\n    const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;\n    let archiveResp;\n    try {\n      archiveResp = await fetch(archiveUrl, {\n        method: \'PUT\',\n        headers: archiveHeaders,\n        body: buf\n      });\n\n      if (!archiveResp.ok) {\n        const errorText = await archiveResp.text().catch(() => \'Unknown error\');\n        console.error(\'Archive.org upload failed:\', archiveResp.status, errorText);\n        return json({\n          error: \'Archive.org upload failed\',\n          status: archiveResp.status,\n          details: errorText,\n          stage: \'archive-upload\',\n          r2Uploaded: true\n        }, 502);\n      }\n      console.log(\'Archive.org upload successful, status:\', archiveResp.status);\n    } catch (archiveErr) {\n      console.error(\'Archive.org upload network error:\', archiveErr);\n      return json({\n        error: \'Failed to connect to Archive.org: \' + archiveErr.message,\n        stage: \'archive-connect\',\n        details: archiveErr.message,\n        r2Uploaded: true\n      }, 502);\n    }\n\n    // STAGE 3: Wait for Archive.org to index the file\n    console.log(\'STAGE 3: Waiting for Archive.org indexing...\');\n    await new Promise(resolve => setTimeout(resolve, 3000));\n\n    // STAGE 4: Verify Archive.org file is accessible\n    console.log(\'STAGE 4: Verifying Archive.org file...\');\n    const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;\n    const embedUrl = `https://archive.org/details/${itemId}`;\n    \n    let verifyAttempts = 0;\n    const maxVerifyAttempts = 3;\n    let archiveVerified = false;\n\n    while (verifyAttempts < maxVerifyAttempts && !archiveVerified) {\n      verifyAttempts++;\n      try {\n        const verifyResp = await fetch(downloadUrl, { method: \'HEAD\' });\n        if (verifyResp.ok) {\n          console.log(\'Archive.org file verified at attempt\', verifyAttempts);\n          archiveVerified = true;\n          break;\n        } else if (verifyResp.status === 404 && verifyAttempts < maxVerifyAttempts) {\n          console.log(`Archive.org file not yet available (attempt ${verifyAttempts}/${maxVerifyAttempts}), waiting...`);\n          await new Promise(resolve => setTimeout(resolve, 2000));\n        } else {\n          console.warn(`Archive.org verification returned status ${verifyResp.status}`);\n          break;\n        }\n      } catch (verifyErr) {\n        console.warn(`Archive.org verification attempt ${verifyAttempts} failed:`, verifyErr.message);\n        if (verifyAttempts < maxVerifyAttempts) {\n          await new Promise(resolve => setTimeout(resolve, 2000));\n        }\n      }\n    }\n\n    if (!archiveVerified) {\n      console.warn(\'Archive.org file could not be verified, but upload was successful\');\n    }\n\n    console.log(\'Upload complete - both R2 and Archive.org successful\');\n    return json({ \n      success: true, \n      url: downloadUrl,\n      embedUrl: embedUrl,\n      itemId: itemId,\n      filename: filename,\n      r2Verified: true,\n      archiveVerified: archiveVerified,\n      isVideo: isVideoUpload\n    });\n\n  } catch (err) {\n    console.error(\'Customer file upload error:\', err);\n    return json({\n      error: \'Upload failed: \' + err.message,\n      details: err.stack,\n      stage: \'unknown\'\n    }, 500);\n  }\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/upload.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the Whop controller in `src/controllers/whop.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/whop.js">\n// Whop integration API controller\nimport { json } from \'../utils/response.js\';\nimport { getWhopApiKey, getWhopWebhookSecret } from \'../utils/helpers.js\';\n\n/**\n * Create Whop checkout session\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @param {URL} url - Request URL\n * @returns {Promise<Response>}\n */\nexport async function createWhopCheckout(env, body, url) {\n  const { product_id } = body;\n  \n  if (!product_id) {\n    return json({ error: \'Product ID required\' }, 400);\n  }\n  \n  // Get product details\n  const product = await env.DB.prepare(\'SELECT * FROM products WHERE id = ?\').bind(Number(product_id)).first();\n  if (!product) {\n    return json({ error: \'Product not found\' }, 404);\n  }\n\n  // Get global Whop settings for fallback\n  let globalSettings = {};\n  try {\n    const settingsRow = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n    if (settingsRow && settingsRow.value) {\n      globalSettings = JSON.parse(settingsRow.value);\n    }\n  } catch (e) {\n    console.error(\'Failed to load global settings:\', e);\n  }\n\n  // Use product\'s whop_plan or fall back to global default\n  let planId = product.whop_plan || globalSettings.default_plan_id || globalSettings.default_plan || \'\';\n\n  if (!planId) {\n    return json({\n      error: \'Whop not configured. Please set a plan for this product or configure a default plan in Settings.\'\n    }, 400);\n  }\n\n  // Extract Plan ID from link or use directly\n  planId = planId.trim();\n  \n  // If it\'s a link, extract the plan ID\n  if (planId.startsWith(\'http\')) {\n    // Try to extract from various Whop URL formats\n    // Format 1: https://whop.com/checkout/plan_xxxxx\n    // Format 2: https://whop.com/product-name (contains plan in page)\n    const planMatch = planId.match(/plan_[a-zA-Z0-9]+/);\n    if (planMatch) {\n      planId = planMatch[0];\n    } else {\n      // If no plan ID in URL, we need to fetch it (not ideal but works)\n      // For now, show error - user should provide direct plan ID or proper link\n      return json({ \n        error: \'Could not extract Plan ID from link. Please use: https://whop.com/checkout/plan_XXXXX or just plan_XXXXX\' \n      }, 400);\n    }\n  }\n  \n  // Validate Plan ID format\n  if (!planId.startsWith(\'plan_\')) {\n    return json({ error: \'Invalid Whop Plan ID format. Should start with plan_\' }, 400);\n  }\n  \n  // Get Whop API key from database or environment\n  const apiKey = await getWhopApiKey(env);\n  if (!apiKey) {\n    return json({ error: \'Whop API key not configured. Please add it in admin Settings.\' }, 500);\n  }\n\n  // Calculate expiry time (15 minutes from now)\n  const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\n\n  // Create Whop checkout session\n  try {\n    const whopResponse = await fetch(\'https://api.whop.com/api/v2/checkout_sessions\', {\n      method: \'POST\',\n      headers: {\n        \'Authorization\': `Bearer ${apiKey}`,\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify({\n        plan_id: planId,\n        redirect_url: `${url.origin}/success.html?product=${product.id}`,\n        metadata: {\n          product_id: product.id.toString(),\n          product_title: product.title,\n          created_at: new Date().toISOString(),\n          expires_at: expiryTime\n        }\n      })\n    });\n    \n    if (!whopResponse.ok) {\n      const errorText = await whopResponse.text();\n      console.error(\'Whop API error:\', errorText);\n      \n      // Try to parse error message\n      try {\n        const errorData = JSON.parse(errorText);\n        return json({ \n          error: errorData.message || errorData.error || \'Failed to create checkout\' \n        }, whopResponse.status);\n      } catch (e) {\n        return json({ error: \'Failed to create checkout session\' }, whopResponse.status);\n      }\n    }\n    \n    const checkoutData = await whopResponse.json();\n    \n    // Store checkout for cleanup tracking (optional - for 15 min auto-delete)\n    try {\n      await env.DB.prepare(`\n        INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\n        VALUES (?, ?, NULL, ?, \'pending\', datetime(\'now\'))\n      `).bind(checkoutData.id, product.id, expiryTime).run();\n    } catch (e) {\n      // Table might not exist - that\'s okay, we\'ll still return the checkout\n      console.log(\'Checkout tracking skipped:\', e.message);\n    }\n    \n    return json({\n      success: true,\n      checkout_id: checkoutData.id,\n      checkout_url: checkoutData.purchase_url,\n      expires_in: \'15 minutes\'\n    });\n  } catch (e) {\n    console.error(\'Whop checkout error:\', e);\n    return json({ error: e.message || \'Failed to create checkout\' }, 500);\n  }\n}\n\n/**\n * Create dynamic Whop plan and checkout\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @param {URL} url - Request URL\n * @returns {Promise<Response>}\n */\nexport async function createWhopPlanCheckout(env, body, url) {\n  const { product_id, amount, email, metadata } = body || {};\n  if (!product_id) {\n    return json({ error: \'Product ID required\' }, 400);\n  }\n  // Lookup product from database\n  const product = await env.DB.prepare(\'SELECT * FROM products WHERE id = ?\').bind(Number(product_id)).first();\n  if (!product) {\n    return json({ error: \'Product not found\' }, 404);\n  }\n  // Determine the price to charge; prefer sale_price over normal_price\n  const priceValue = (product.sale_price !== null && product.sale_price !== undefined && product.sale_price !== \'\')\n    ? Number(product.sale_price)\n    : Number(product.normal_price);\n  // Allow $0 for testing, but reject negative prices\n  if (isNaN(priceValue) || priceValue < 0) {\n    return json({ error: \'Invalid price for product\' }, 400);\n  }\n  // Ensure we have the Whop product ID for attaching the plan to the correct product\n  // Use the product\'s specific Whop product ID if available.\n  const directProdId = (product.whop_product_id || \'\').trim();\n  let finalProdId = directProdId;\n  // If no product-specific ID, fallback to global default_product_id from settings\n  if (!finalProdId) {\n    try {\n      const srow = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      let settings = {};\n      if (srow && srow.value) {\n        try { settings = JSON.parse(srow.value); } catch (e) { settings = {}; }\n      }\n      if (settings && settings.default_product_id) {\n        finalProdId = (settings.default_product_id || \'\').trim();\n      }\n    } catch (e) {\n      console.log(\'Failed to load whop settings for default product ID:\', e);\n    }\n  }\n  if (!finalProdId) {\n    return json({ error: \'whop_product_id not configured for this product and no default_product_id set\' }, 400);\n  }\n  // Company ID must be provided via environment variables\n  const companyId = env.WHOP_COMPANY_ID;\n  if (!companyId) {\n    return json({ error: \'WHOP_COMPANY_ID environment variable not set\' }, 500);\n  }\n  // Get API key from database or environment\n  const apiKey = await getWhopApiKey(env);\n  if (!apiKey) {\n    return json({ error: \'Whop API key not configured. Please add it in admin Settings.\' }, 500);\n  }\n  // Derive currency from environment or fallback to USD\n  const currency = env.WHOP_CURRENCY || \'usd\';\n  // Prepare plan creation request for one-time payment (no renewal)\n  // For one_time plans, we should NOT set renewal_price\n  const planBody = {\n    company_id: companyId,\n    product_id: finalProdId,\n    plan_type: \'one_time\',\n    release_method: \'buy_now\',\n    currency: currency,\n    initial_price: priceValue,\n    // Do NOT set renewal_price for one_time plans - it causes error\n    // Provide a default title for the plan so the seller can see it in their dashboard\n    title: `${product.title || \'One-time purchase\'} - $${priceValue}`,\n    // Set unlimited stock to prevent "out of stock" errors\n    stock: 999999,\n    internal_notes: `Auto-generated for product ${product.id} - ${new Date().toISOString()}`\n  };\n  try {\n    // Create the plan on Whop\n    const planResp = await fetch(\'https://api.whop.com/api/v2/plans\', {\n      method: \'POST\',\n      headers: {\n        \'Authorization\': `Bearer ${apiKey}`,\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify(planBody)\n    });\n    if (!planResp.ok) {\n      const errorText = await planResp.text();\n      console.error(\'Whop plan create error:\', errorText);\n      let msg = \'Failed to create plan\';\n      try {\n        const j = JSON.parse(errorText);\n        msg = j.message || j.error || msg;\n      } catch (_) {}\n      return json({ error: msg }, planResp.status);\n    }\n    const planData = await planResp.json();\n    const planId = planData.id;\n    if (!planId) {\n      return json({ error: \'Plan ID missing from Whop response\' }, 500);\n    }\n    // Compute expiry time (15 mins) for cleanup\n    const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\n\n    // Store plan for cleanup, no checkout session needed for embedded flow\n    try {\n      await env.DB.prepare(`\n        INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\n        VALUES (?, ?, ?, ?, \'pending\', datetime(\'now\'))\n      `).bind(\'plan_\' + planId, product.id, planId, expiryTime).run();\n    } catch (e) {\n      console.log(\'Plan tracking insert failed:\', e.message);\n    }\n\n    // Create checkout session with email prefill for better UX\n    const checkoutBody = {\n      plan_id: planId,\n      redirect_url: `${url.origin}/success.html?product=${product.id}`,\n      metadata: {\n        product_id: product.id.toString(),\n        product_title: product.title,\n        addons: metadata?.addons || [],\n        amount: amount || priceValue,\n        created_at: new Date().toISOString()\n      }\n    };\n\n    // Add email prefill if provided\n    if (email && email.includes(\'@\')) {\n      checkoutBody.prefill = {\n        email: email.trim()\n      };\n    }\n\n    const checkoutResp = await fetch(\'https://api.whop.com/api/v2/checkout_sessions\', {\n      method: \'POST\',\n      headers: {\n        \'Authorization\': `Bearer ${apiKey}`,\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify(checkoutBody)\n    });\n\n    if (!checkoutResp.ok) {\n      const errorText = await checkoutResp.text();\n      console.error(\'Whop checkout session error:\', errorText);\n      // If checkout session fails, still return plan ID for fallback\n      return json({\n        success: true,\n        plan_id: planId,\n        product_id: product.id,\n        email: email,\n        metadata: {\n          product_id: product.id.toString(),\n          product_title: product.title,\n          addons: metadata?.addons || [],\n          amount: amount || priceValue\n        },\n        expires_in: \'15 minutes\',\n        warning: \'Email prefill not available\'\n      });\n    }\n\n    const checkoutData = await checkoutResp.json();\n\n    // Update database record with checkout session ID\n    try {\n      await env.DB.prepare(`\n        UPDATE checkout_sessions \n        SET checkout_id = ?\n        WHERE checkout_id = ?\n      `).bind(checkoutData.id, \'plan_\' + planId).run();\n    } catch (e) {\n      console.log(\'Checkout session tracking update failed:\', e.message);\n    }\n\n    // Return both plan ID and checkout URL with email prefill\n    return json({\n      success: true,\n      plan_id: planId,\n      checkout_id: checkoutData.id,\n      checkout_url: checkoutData.purchase_url,\n      product_id: product.id,\n      email: email,\n      metadata: {\n        product_id: product.id.toString(),\n        product_title: product.title,\n        addons: metadata?.addons || [],\n        amount: amount || priceValue\n      },\n      expires_in: \'15 minutes\',\n      email_prefilled: !!(email && email.includes(\'@\'))\n    });\n  } catch (e) {\n    console.error(\'Dynamic checkout error:\', e);\n    return json({ error: e.message || \'Failed to create plan/checkout\' }, 500);\n  }\n}\n\n/**\n * Handle Whop webhook\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @returns {Promise<Response>}\n */\nexport async function handleWhopWebhook(env, req) {\n  try {\n    const webhookData = await req.json();\n    const eventType = webhookData.type;\n    \n    console.log(\'Whop webhook received:\', eventType);\n    \n    // Handle payment success\n    if (eventType === \'payment.succeeded\') {\n      const checkoutSessionId = webhookData.data?.checkout_session_id;\n      const membershipId = webhookData.data?.id;\n      const metadata = webhookData.data?.metadata || {};\n      \n      console.log(\'Payment succeeded:\', {\n        checkoutSessionId,\n        membershipId,\n        metadata\n      });\n      \n      // Mark checkout as completed in database\n      if (checkoutSessionId) {\n        try {\n          await env.DB.prepare(`\n            UPDATE checkout_sessions \n            SET status = \'completed\', completed_at = datetime(\'now\')\n            WHERE checkout_id = ?\n          `).bind(checkoutSessionId).run();\n        } catch (e) {\n          console.log(\'Checkout tracking update skipped:\', e.message);\n        }\n      }\n      \n      // Delete the temporary checkout session from Whop\n      if (checkoutSessionId && env.WHOP_API_KEY) {\n        try {\n          await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkoutSessionId}`, {\n            method: \'DELETE\',\n            headers: {\n              \'Authorization\': `Bearer ${env.WHOP_API_KEY}`\n            }\n          });\n          console.log(\'âœ… Checkout session deleted immediately after payment:\', checkoutSessionId);\n        } catch (e) {\n          console.error(\'Failed to delete checkout session:\', e);\n        }\n      }\n      // If we created a dynamic plan for this checkout, delete the plan as well\n      if (checkoutSessionId && env.WHOP_API_KEY) {\n        try {\n          // Fetch plan_id from checkout_sessions table\n          const row = await env.DB.prepare(\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\').bind(checkoutSessionId).first();\n          const planId = row && row.plan_id;\n          if (planId) {\n            await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\n              method: \'DELETE\',\n              headers: { \'Authorization\': `Bearer ${env.WHOP_API_KEY}` }\n            });\n            console.log(\'ðŸ—‘ï¸ Plan deleted immediately after payment:\', planId);\n          }\n        } catch (e) {\n          console.error(\'Failed to delete plan:\', e);\n        }\n      }\n      \n      // Create order in database (optional - for tracking)\n      if (metadata.product_id) {\n        try {\n          const orderId = `WHOP-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n          await env.DB.prepare(\n            \'INSERT INTO orders (order_id, product_id, status, created_at) VALUES (?, ?, ?, datetime("now"))\'\n          ).bind(orderId, Number(metadata.product_id), \'completed\').run();\n          \n          console.log(\'Order created:\', orderId);\n        } catch (e) {\n          console.error(\'Failed to create order:\', e);\n        }\n      }\n    }\n    \n    // Handle membership validation\n    if (eventType === \'membership.went_valid\') {\n      console.log(\'Membership validated:\', webhookData.data?.id);\n    }\n    \n    // Always return 200 to acknowledge webhook\n    return json({ received: true });\n  } catch (e) {\n    console.error(\'Webhook error:\', e);\n    return json({ error: \'Webhook processing failed\' }, 500);\n  }\n}\n\n/**\n * Test Whop API connectivity\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function testWhopApi(env) {\n  const apiKey = await getWhopApiKey(env);\n  if (!apiKey) {\n    return json({ success: false, error: \'Whop API key not configured. Please add it in Settings.\' }, 500);\n  }\n  try {\n    // Test API key by listing plans - this endpoint works with basic plan permissions\n    // and doesn\'t require company ID or special permissions\n    const resp = await fetch(\'https://api.whop.com/api/v2/plans?page=1&per=1\', {\n      method: \'GET\',\n      headers: {\n        \'Authorization\': `Bearer ${apiKey}`,\n        \'Content-Type\': \'application/json\'\n      }\n    });\n\n    // Return detailed error info for debugging\n    if (!resp.ok) {\n      const text = await resp.text();\n      let errMsg = \'Whop API call failed\';\n      let errorDetails = null;\n      try {\n        errorDetails = JSON.parse(text);\n        errMsg = errorDetails.message || errorDetails.error || errMsg;\n      } catch (_) {\n        errMsg = text || errMsg;\n      }\n      return json({\n        success: false,\n        error: errMsg,\n        status: resp.status,\n        details: errorDetails,\n        debug: {\n          apiKeyLength: apiKey?.length || 0,\n          apiKeyPrefix: apiKey?.substring(0, 10) + \'...\'\n        }\n      }, resp.status);\n    }\n\n    const data = await resp.json();\n    return json({\n      success: true,\n      message: \'API connection successful!\',\n      plansCount: data.data?.length || 0,\n      apiKeyValid: true\n    });\n  } catch (e) {\n    return json({ success: false, error: e.message || \'API test error\' }, 500);\n  }\n}\n\n/**\n * Test webhook endpoint reachability\n * @returns {Promise<Response>}\n */\nexport async function testWhopWebhook() {\n  return json({ success: true, message: \'Webhook endpoint reachable\' });\n}\n\n/**\n * Cleanup expired checkout sessions\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function cleanupExpiredCheckouts(env) {\n  if (!env.WHOP_API_KEY) {\n    return json({ error: \'Whop API key not configured\' }, 500);\n  }\n  \n  try {\n    // Get expired checkouts from database\n    const expiredCheckouts = await env.DB.prepare(`\n      SELECT checkout_id, product_id, expires_at\n      FROM checkout_sessions\n      WHERE status = \'pending\' \n      AND datetime(expires_at) < datetime(\'now\')\n      ORDER BY created_at ASC\n      LIMIT 50\n    `).all();\n    \n    let deleted = 0;\n    let failed = 0;\n    \n    for (const checkout of (expiredCheckouts.results || [])) {\n      try {\n        // Delete the checkout session from Whop (ignore if already gone)\n        const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\n          method: \'DELETE\',\n          headers: { \'Authorization\': `Bearer ${env.WHOP_API_KEY}` }\n        });\n        // Attempt to delete the associated plan if one exists\n        let planDeleted = false;\n        try {\n          const row = await env.DB.prepare(\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\').bind(checkout.checkout_id).first();\n          const planId = row && row.plan_id;\n          if (planId) {\n            const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\n              method: \'DELETE\',\n              headers: { \'Authorization\': `Bearer ${env.WHOP_API_KEY}` }\n            });\n            planDeleted = delPlanResp.ok || delPlanResp.status === 404;\n          }\n        } catch (pe) {\n          console.error(\'Plan deletion error:\', pe);\n        }\n        if (deleteSessionResp.ok || deleteSessionResp.status === 404) {\n          // Mark as expired in database regardless of plan deletion outcome\n          await env.DB.prepare(`\n            UPDATE checkout_sessions \n            SET status = \'expired\', completed_at = datetime(\'now\')\n            WHERE checkout_id = ?\n          `).bind(checkout.checkout_id).run();\n          deleted++;\n          console.log(\'ðŸ—‘ï¸ Expired checkout deleted:\', checkout.checkout_id, planDeleted ? \'and plan cleaned up\' : \'\');\n        } else {\n          failed++;\n        }\n      } catch (e) {\n        failed++;\n        console.error(\'Failed to delete checkout:\', checkout.checkout_id, e);\n      }\n    }\n    \n    return json({\n      success: true,\n      deleted: deleted,\n      failed: failed,\n      message: `Cleaned up ${deleted} expired checkouts`\n    });\n  } catch (e) {\n    console.error(\'Cleanup error:\', e);\n    return json({ error: e.message }, 500);\n  }\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/whop.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the admin controller in `src/controllers/admin.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/admin.js">\n// Admin dashboard API controller\nimport { json } from \'../utils/response.js\';\n\n/**\n * Purge Cloudflare cache\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function purgeCache(env) {\n  const zoneId = env.CF_ZONE_ID;\n  const token = env.CF_API_TOKEN;\n  if (!zoneId || !token) {\n    return json({ error: \'CF_ZONE_ID or CF_API_TOKEN not configured\' }, 500);\n  }\n  try {\n    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\n    const cfResp = await fetch(purgeUrl, {\n      method: \'POST\',\n      headers: {\n        \'Authorization\': `Bearer ${token}`,\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify({ purge_everything: true })\n    });\n    const result = await cfResp.json();\n    return json(result, cfResp.ok ? 200 : 500);\n  } catch (e) {\n    return json({ error: e.message }, 500);\n  }\n}\n\n/**\n * Get Whop settings from database\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getWhopSettings(env) {\n  const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n  let settings = {};\n  try { if (row?.value) settings = JSON.parse(row.value); } catch(e) {}\n  return json({ settings });\n}\n\n/**\n * Save Whop settings to database\n * @param {Object} env - Environment bindings\n * @param {Object} body - Settings data\n * @returns {Promise<Response>}\n */\nexport async function saveWhopSettings(env, body) {\n  await env.DB.prepare(\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\').bind(\'whop\', JSON.stringify(body)).run();\n  return json({ success: true });\n}\n\n/**\n * Export data (products, orders, reviews)\n * @param {Object} env - Environment bindings\n * @param {string} type - Export type (\'products\', \'orders\', \'reviews\', \'all\')\n * @returns {Promise<Response>}\n */\nexport async function exportData(env, type) {\n  try {\n    let data = {};\n    \n    switch (type) {\n      case \'products\':\n        const products = await env.DB.prepare(\'SELECT * FROM products ORDER BY id DESC\').all();\n        data.products = products.results || [];\n        break;\n        \n      case \'orders\':\n        const orders = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n        data.orders = orders.results || [];\n        break;\n        \n      case \'reviews\':\n        const reviews = await env.DB.prepare(\'SELECT * FROM reviews ORDER BY id DESC\').all();\n        data.reviews = reviews.results || [];\n        break;\n        \n      case \'all\':\n      default:\n        const allProducts = await env.DB.prepare(\'SELECT * FROM products ORDER BY id DESC\').all();\n        const allOrders = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n        const allReviews = await env.DB.prepare(\'SELECT * FROM reviews ORDER BY id DESC\').all();\n        const allPages = await env.DB.prepare(\'SELECT * FROM pages ORDER BY id DESC\').all();\n        const allSettings = await env.DB.prepare(\'SELECT * FROM settings ORDER BY key\').all();\n        \n        data = {\n          products: allProducts.results || [],\n          orders: allOrders.results || [],\n          reviews: allReviews.results || [],\n          pages: allPages.results || [],\n          settings: allSettings.results || [],\n          exported_at: new Date().toISOString(),\n          version: \'1.0\'\n        };\n        break;\n    }\n    \n    // Add metadata\n    data.exported_at = new Date().toISOString();\n    data.export_type = type;\n    data.total_records = Object.keys(data).reduce((sum, key) => {\n      if (key !== \'exported_at\' && key !== \'export_type\' && key !== \'total_records\' && key !== \'version\') {\n        return sum + (Array.isArray(data[key]) ? data[key].length : 0);\n      }\n      return sum;\n    }, 0);\n    \n    return json(data);\n  } catch (e) {\n    console.error(\'Export error:\', e);\n    return json({ error: \'Export failed: \' + e.message }, 500);\n  }\n}\n\n/**\n * Import data (products, orders, reviews)\n * @param {Object} env - Environment bindings\n * @param {Object} importData - Import data\n * @returns {Promise<Response>}\n */\nexport async function importData(env, importData) {\n  try {\n    const results = {\n      products: { imported: 0, errors: [] },\n      orders: { imported: 0, errors: [] },\n      reviews: { imported: 0, errors: [] },\n      pages: { imported: 0, errors: [] },\n      settings: { imported: 0, errors: [] }\n    };\n    \n    // Import products\n    if (importData.products && Array.isArray(importData.products)) {\n      for (const product of importData.products) {\n        try {\n          // Remove ID for new insertion, or update if ID exists\n          if (product.id) {\n            const existing = await env.DB.prepare(\'SELECT id FROM products WHERE id = ?\').bind(product.id).first();\n            if (existing) {\n              // Update existing product\n              await env.DB.prepare(`\n                UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\n                instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\n                gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\n                whop_plan=?, whop_price_map=?, whop_product_id=?, status=?, sort_order=? WHERE id=?\n              `).bind(\n                product.title || \'\', product.slug || \'\', product.description || \'\',\n                product.normal_price || 0, product.sale_price || null,\n                product.instant_delivery || 0, product.normal_delivery_text || \'\',\n                product.thumbnail_url || \'\', product.video_url || \'\',\n                product.gallery_images || \'[]\', product.addons_json || \'[]\',\n                product.seo_title || \'\', product.seo_description || \'\', product.seo_keywords || \'\', product.seo_canonical || \'\',\n                product.whop_plan || \'\', product.whop_price_map || \'\', product.whop_product_id || \'\',\n                product.status || \'active\', product.sort_order || 0, product.id\n              ).run();\n              results.products.imported++;\n              continue;\n            }\n          }\n          \n          // Insert new product (without ID to avoid conflicts)\n          await env.DB.prepare(`\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            product.title || \'\', product.slug || \'\', product.description || \'\',\n            product.normal_price || 0, product.sale_price || null,\n            product.instant_delivery || 0, product.normal_delivery_text || \'\',\n            product.thumbnail_url || \'\', product.video_url || \'\',\n            product.gallery_images || \'[]\', product.addons_json || \'[]\',\n            product.seo_title || \'\', product.seo_description || \'\', product.seo_keywords || \'\', product.seo_canonical || \'\',\n            product.whop_plan || \'\', product.whop_price_map || \'\', product.whop_product_id || \'\',\n            product.status || \'active\', product.sort_order || 0\n          ).run();\n          results.products.imported++;\n        } catch (e) {\n          results.products.errors.push(`Product "${product.title || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import orders\n    if (importData.orders && Array.isArray(importData.orders)) {\n      for (const order of importData.orders) {\n        try {\n          // Check if order already exists by order_id\n          const existing = await env.DB.prepare(\'SELECT id FROM orders WHERE order_id = ?\').bind(order.order_id).first();\n          if (existing) continue; // Skip existing orders\n          \n          await env.DB.prepare(`\n            INSERT INTO orders (order_id, product_id, encrypted_data, iv, archive_url, archive_data,\n            status, created_at, delivered_video_url, delivered_thumbnail_url, delivered_video_metadata,\n            portfolio_enabled, delivered_at, delivery_time_minutes, revision_count, revision_requested)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            order.order_id, order.product_id || null, order.encrypted_data || \'{}\', order.iv || null,\n            order.archive_url || null, order.archive_data || null, order.status || \'pending\',\n            order.created_at || new Date().toISOString(), order.delivered_video_url || null,\n            order.delivered_thumbnail_url || null, order.delivered_video_metadata || null,\n            order.portfolio_enabled || 1, order.delivered_at || null, order.delivery_time_minutes || 60,\n            order.revision_count || 0, order.revision_requested || 0\n          ).run();\n          results.orders.imported++;\n        } catch (e) {\n          results.orders.errors.push(`Order "${order.order_id || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import reviews\n    if (importData.reviews && Array.isArray(importData.reviews)) {\n      for (const review of importData.reviews) {\n        try {\n          await env.DB.prepare(`\n            INSERT INTO reviews (product_id, author_name, rating, comment, status, created_at,\n            order_id, show_on_product, delivered_video_url, delivered_thumbnail_url)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            review.product_id, review.author_name || \'Customer\', review.rating || 5,\n            review.comment || \'\', review.status || \'approved\', review.created_at || new Date().toISOString(),\n            review.order_id || null, review.show_on_product !== undefined ? review.show_on_product : 1,\n            review.delivered_video_url || null, review.delivered_thumbnail_url || null\n          ).run();\n          results.reviews.imported++;\n        } catch (e) {\n          results.reviews.errors.push(`Review for product ${review.product_id || \'Unknown\'}: ${e.message}`);\n        }\n      }\n    }\n    \n    // Import pages\n    if (importData.pages && Array.isArray(importData.pages)) {\n      for (const page of importData.pages) {\n        try {\n          // Check if page already exists by slug\n          const existing = await env.DB.prepare(\'SELECT id FROM pages WHERE slug = ?\').bind(page.slug).first();\n          if (existing) {\n            // Update existing page\n            await env.DB.prepare(`\n              UPDATE pages SET title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?\n            `).bind(\n              page.title || \'\', page.content || \'\', page.meta_description || \'\',\n              page.status || \'published\', existing.id\n            ).run();\n          } else {\n            // Insert new page\n            await env.DB.prepare(`\n              INSERT INTO pages (slug, title, content, meta_description, status, created_at, updated_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?)\n            `).bind(\n              page.slug || \'\', page.title || \'\', page.content || \'\',\n              page.meta_description || \'\', page.status || \'published\',\n              page.created_at || new Date().toISOString(), page.updated_at || new Date().toISOString()\n            ).run();\n          }\n          results.pages.imported++;\n        } catch (e) {\n          results.pages.errors.push(`Page "${page.title || page.slug || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import settings\n    if (importData.settings && Array.isArray(importData.settings)) {\n      for (const setting of importData.settings) {\n        try {\n          await env.DB.prepare(\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\')\n            .bind(setting.key, setting.value || \'\').run();\n          results.settings.imported++;\n        } catch (e) {\n          results.settings.errors.push(`Setting "${setting.key || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Calculate totals\n    const totalImported = Object.values(results).reduce((sum, result) => sum + result.imported, 0);\n    const totalErrors = Object.values(results).reduce((sum, result) => sum + result.errors.length, 0);\n    \n    return json({\n      success: true,\n      results,\n      summary: {\n        total_imported: totalImported,\n        total_errors: totalErrors,\n        import_time: new Date().toISOString()\n      }\n    });\n  } catch (e) {\n    console.error(\'Import error:\', e);\n    return json({ error: \'Import failed: \' + e.message }, 500);\n  }\n}\n\n/**\n * Get system statistics\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getSystemStats(env) {\n  try {\n    const stats = {};\n    \n    // Product stats\n    const productCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM products\').first();\n    const activeProducts = await env.DB.prepare(\'SELECT COUNT(*) as count FROM products WHERE status = ?\', \'active\').first();\n    stats.products = {\n      total: productCount?.count || 0,\n      active: activeProducts?.count || 0,\n      draft: (productCount?.count || 0) - (activeProducts?.count || 0)\n    };\n    \n    // Order stats\n    const orderCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders\').first();\n    const deliveredOrders = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders WHERE status = ?\', \'delivered\').first();\n    const pendingOrders = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders WHERE status IN (?, ?, ?)\', \'pending\', \'PAID\', \'revision\').first();\n    stats.orders = {\n      total: orderCount?.count || 0,\n      delivered: deliveredOrders?.count || 0,\n      pending: pendingOrders?.count || 0\n    };\n    \n    // Review stats\n    const reviewCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM reviews\').first();\n    const approvedReviews = await env.DB.prepare(\'SELECT COUNT(*) as count FROM reviews WHERE status = ?\', \'approved\').first();\n    stats.reviews = {\n      total: reviewCount?.count || 0,\n      approved: approvedReviews?.count || 0,\n      pending: (reviewCount?.count || 0) - (approvedReviews?.count || 0)\n    };\n    \n    // Page stats\n    const pageCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM pages\').first();\n    const publishedPages = await env.DB.prepare(\'SELECT COUNT(*) as count FROM pages WHERE status = ?\', \'published\').first();\n    stats.pages = {\n      total: pageCount?.count || 0,\n      published: publishedPages?.count || 0,\n      draft: (pageCount?.count || 0) - (publishedPages?.count || 0)\n    };\n    \n    // Chat stats\n    const sessionCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM chat_sessions\').first();\n    const messageCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM chat_messages\').first();\n    stats.chat = {\n      sessions: sessionCount?.count || 0,\n      messages: messageCount?.count || 0\n    };\n    \n    // Revenue stats (basic)\n    const revenueResult = await env.DB.prepare(`\n      SELECT COUNT(*) as count, \n             AVG(CASE \n               WHEN json_extract(encrypted_data, \'$.amount\') IS NOT NULL \n               THEN json_extract(encrypted_data, \'$.amount\') \n               ELSE 0 \n             END) as avg_amount\n      FROM orders \n      WHERE status != \'pending\'\n    `).first();\n    stats.revenue = {\n      orders_processed: revenueResult?.count || 0,\n      average_order_value: revenueResult?.avg_amount || 0\n    };\n    \n    return json({ success: true, stats, generated_at: new Date().toISOString() });\n  } catch (e) {\n    console.error(\'Stats error:\', e);\n    return json({ error: \'Failed to generate stats: \' + e.message }, 500);\n  }\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/admin.js\' created successfully.") </create-file> </tool_result>'}
{'role': 'assistant', 'content': '\nNow let me create the pages controller in `src/controllers/pages.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/pages.js">\n// Pages API controller\nimport { json } from \'../utils/response.js\';\n\n/**\n * Get all pages\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getPages(env) {\n   const r = await env.DB.prepare(\'SELECT id, slug, title, status, created_at, updated_at FROM pages ORDER BY id DESC\').all();\n\n   // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\n   const pages = (r.results || []).map(page => {\n     if (page.created_at && typeof page.created_at === \'string\') {\n       page.created_at = page.created_at.replace(\' \', \'T\') + \'Z\';\n     }\n     if (page.updated_at && typeof page.updated_at === \'string\') {\n       page.updated_at = page.updated_at.replace(\' \', \'T\') + \'Z\';\n     }\n     return page;\n   });\n\n   return json({ pages });\n}\n\n/**\n * Get a single page by slug\n * @param {Object} env - Environment bindings\n * @param {string} slug - Page slug\n * @returns {Promise<Response>}\n */\nexport async function getPage(env, slug) {\n   const row = await env.DB.prepare(\'SELECT * FROM pages WHERE slug = ?\').bind(slug).first();\n   if (!row) return json({ error: \'Page not found\' }, 404);\n\n   // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\n   if (row.created_at && typeof row.created_at === \'string\') {\n     row.created_at = row.created_at.replace(\' \', \'T\') + \'Z\';\n   }\n   if (row.updated_at && typeof row.updated_at === \'string\') {\n     row.updated_at = row.updated_at.replace(\' \', \'T\') + \'Z\';\n   }\n\n   return json({ page: row });\n}\n\n/**\n * Save a page (create or update)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Page data\n * @returns {Promise<Response>}\n */\nexport async function savePage(env, body) {\n  if (!body.slug || !body.title) return json({ error: \'slug and title required\' }, 400);\n  \n  if (body.id) {\n    await env.DB.prepare(\n      \'UPDATE pages SET slug=?, title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?\'\n    ).bind(body.slug, body.title, body.content || \'\', body.meta_description || \'\', body.status || \'published\', Number(body.id)).run();\n    return json({ success: true, id: body.id });\n  }\n  \n  const r = await env.DB.prepare(\n    \'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(body.slug, body.title, body.content || \'\', body.meta_description || \'\', body.status || \'published\').run();\n  return json({ success: true, id: r.meta?.last_row_id });\n}\n\n/**\n * Delete a page\n * @param {Object} env - Environment bindings\n * @param {string} id - Page ID\n * @returns {Promise<Response>}\n */\nexport async function deletePage(env, id) {\n  await env.DB.prepare(\'DELETE FROM pages WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n\n/**\n * Save page from page builder (convenience endpoint)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Page builder data\n * @returns {Promise<Response>}\n */\nexport async function savePageBuilder(env, body) {\n  const name = (body.name || \'\').trim();\n  const html = (body.html || \'\').trim();\n  if (!name || !html) {\n    return json({ error: \'name and html required\' }, 400);\n  }\n  // Sanitize the slug: lower-case and replace non-alphanumeric characters with dashes\n  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  // Check if page already exists\n  const existing = await env.DB.prepare(\'SELECT id FROM pages WHERE slug = ?\').bind(slug).first();\n  if (existing) {\n    await env.DB.prepare(\n      \'UPDATE pages SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?\'\n    ).bind(name, html, existing.id).run();\n  } else {\n    await env.DB.prepare(\n      \'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\'\n    ).bind(slug, name, html, \'\', \'published\').run();\n  }\n  return json({ success: true, slug });\n}\n\n/**\n * Get pages list for admin UI\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getPagesList(env) {\n  // Return all pages with their publish status. The admin UI uses this to\n  // display published/draft pages and provide actions.  Selecting the\n  // status column allows distinguishing between published and draft.\n  const r = await env.DB.prepare(\n    \'SELECT slug, title, content, created_at, status FROM pages ORDER BY id DESC\'\n  ).all();\n  const pages = (r.results || []).map(p => {\n    const size = p.content ? p.content.length : 0;\n    // Convert created_at to ISO 8601 format with Z suffix for UTC\n    let createdAt = p.created_at;\n    if (createdAt && typeof createdAt === \'string\') {\n      createdAt = createdAt.replace(\' \', \'T\') + \'Z\';\n    }\n    return {\n      name: p.slug,\n      slug: p.slug,\n      title: p.title,\n      url: `/${p.slug}.html`,\n      uploaded: createdAt,\n      size: size,\n      status: p.status || \'published\'\n    };\n  });\n  return json({ success: true, pages });\n}\n\n/**\n * Delete page by name/slug (convenience endpoint)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body with name\n * @returns {Promise<Response>}\n */\nexport async function deletePageByName(env, body) {\n  const name = (body.name || \'\').trim();\n  if (!name) {\n    return json({ error: \'name required\' }, 400);\n  }\n  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  await env.DB.prepare(\'DELETE FROM pages WHERE slug = ?\').bind(slug).run();\n  return json({ success: true });\n}\n\n/**\n * Update page status\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body with name and status\n * @returns {Promise<Response>}\n */\nexport async function updatePageStatus(env, body) {\n  const name = (body.name || \'\').trim();\n  const status = (body.status || \'\').trim().toLowerCase();\n  if (!name || !status) {\n    return json({ error: \'name and status required\' }, 400);\n  }\n  if (status !== \'published\' && status !== \'draft\') {\n    return json({ error: \'invalid status\' }, 400);\n  }\n  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  const existing = await env.DB.prepare(\'SELECT id FROM pages WHERE slug = ?\').bind(slug).first();\n  if (!existing) {\n    return json({ error: \'Page not found\' }, 404);\n  }\n  await env.DB.prepare(\'UPDATE pages SET status = ? WHERE slug = ?\').bind(status, slug).run();\n  return json({ success: true });\n}\n\n/**\n * Duplicate a page\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body with name\n * @returns {Promise<Response>}\n */\nexport async function duplicatePage(env, body) {\n  const name = (body.name || \'\').trim();\n  if (!name) {\n    return json({ error: \'name required\' }, 400);\n  }\n  const baseSlug = name.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  const row = await env.DB.prepare(\'SELECT title, content, meta_description FROM pages WHERE slug = ?\').bind(baseSlug).first();\n  if (!row) {\n    return json({ error: \'Page not found\' }, 404);\n  }\n  // Determine new slug by adding \'-copy\' and ensuring uniqueness\n  let newSlug = baseSlug + \'-copy\';\n  let idx = 1;\n  let exists = await env.DB.prepare(\'SELECT slug FROM pages WHERE slug = ?\').bind(newSlug).first();\n  while (exists) {\n    newSlug = `${baseSlug}-copy${idx}`;\n    idx++;\n    exists = await env.DB.prepare(\'SELECT slug FROM pages WHERE slug = ?\').bind(newSlug).first();\n  }\n  const newTitle = (row.title || baseSlug) + \' Copy\';\n  const metaDesc = row.meta_description || \'\';\n  await env.DB.prepare(\n    \'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(newSlug, newTitle, row.content || \'\', metaDesc, \'draft\').run();\n  return json({ success: true, slug: newSlug });\n}\n\n/**\n * Load page for page builder (separate HTML and CSS)\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with name parameter\n * @returns {Promise<Response>}\n */\nexport async function loadPageForBuilder(env, url) {\n  const name = url.searchParams.get(\'name\');\n  if (!name) {\n    return json({ error: \'name required\' }, 400);\n  }\n  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \'-\').replace(/^-|-$/g, \'\');\n  const row = await env.DB.prepare(\'SELECT content FROM pages WHERE slug = ?\').bind(slug).first();\n  if (!row) {\n    return json({ error: \'Page not found\' }, 404);\n  }\n  let full = row.content || \'\';\n  let css = \'\';\n  let htmlBody = \'\';\n  try {\n    // Extract CSS between <style> tags\n    const styleMatch = full.match(/<style[^>]*>([\\s\\S]*?)<\\/style>/i);\n    if (styleMatch) {\n      css = styleMatch[1];\n    }\n    // Extract body content between <body> tags\n    const bodyMatch = full.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n    htmlBody = bodyMatch ? bodyMatch[1] : full;\n  } catch (e) {\n    htmlBody = full;\n  }\n  return json({ success: true, html: htmlBody.trim(), css: css.trim() });\n}\n</create-file>\n</function_calls>'}
{'role': 'user', 'content': '<tool_result> <create-file> ToolResult(success=True, output="File \'src/controllers/pages.js\' created successfully.") </create-file> </tool_result>'}