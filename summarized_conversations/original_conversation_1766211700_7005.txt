{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "/**\\\\n * Complete Cloudflare Worker - All Features\\\\n * Version: Fixed with Number() conversions\\\\n */\\\\n\\\\n// The CORS and cache configuration for all API responses.\\\\nconst CORS = {\\\\n  \\\'Access-Control-Allow-Origin\\\': \\\'*\\\',\\\\n  \\\'Access-Control-Allow-Methods\\\': \\\'GET, POST, PUT, DELETE, OPTIONS\\\',\\\\n  \\\'Access-Control-Allow-Headers\\\': \\\'Content-Type\\\',\\\\n  \\\'Cache-Control\\\': \\\'no-store, no-cache, must-revalidate\\\',\\\\n  \\\'Pragma\\\': \\\'no-cache\\\'\\\\n};\\\\n\\\\n// A build/version identifier that can be set at publish time via environment\\\\n// variables.  If none is provided Wrangler will default to the current\\\\n// timestamp.  This value is returned via the `/api/debug` endpoint and\\\\n// embedded in a custom header on all static asset responses.  Use this\\\\n// identifier to verify that new versions of your worker and static assets\\\\n// are being served.  You can set VERSION in wrangler.toml under [vars].\\\\nconst VERSION = globalThis.VERSION || \\\\"15\\\\";\\\\n\\\\nfunction json(data, status = 200) {\\\\n  return new Response(JSON.stringify(data), {\\\\n    status,\\\\n    headers: { ...CORS, \\\'Content-Type\\\': \\\'application/json\\\' }\\\\n  });\\\\n}\\\\n\\\\n\\\\nfunction escapeHtml(input) {\\\\n  return String(input ?? \\\'\\\')\\\\n    .replaceAll(\\\'&\\\', \\\'&amp;\\\')\\\\n    .replaceAll(\\\'<\\\', \\\'&lt;\\\')\\\\n    .replaceAll(\\\'>\\\', \\\'&gt;\\\')\\\\n    .replaceAll(\\\'\\\\"\\\', \\\'&quot;\\\')\\\\n    .replaceAll(\\\\"\\\'\\\\", \\\'&#39;\\\');\\\\n}\\\\n\\\\nfunction normalizeQuickAction(text) {\\\\n  return String(text || \\\'\\\')\\\\n    .trim()\\\\n    .replace(/\\\\\\\\s+/g, \\\' \\\')\\\\n    .toLowerCase();\\\\n}\\\\n\\\\nasync function enforceUserRateLimit(env, sessionId) {\\\\n  const row = await env.DB.prepare(\\\\n    `SELECT strftime(\\\'%s\\\', created_at) AS ts\\\\n     FROM chat_messages\\\\n     WHERE session_id = ? AND role = \\\'user\\\'\\\\n     ORDER BY id DESC\\\\n     LIMIT 1`\\\\n  ).bind(sessionId).first();\\\\n\\\\n  if (!row?.ts) return;\\\\n\\\\n  const lastTs = Number(row.ts) || 0;\\\\n  const nowTs = Math.floor(Date.now() / 1000);\\\\n\\\\n  if (nowTs - lastTs < 1) {\\\\n    const err = new Error(\\\'Rate limited\\\');\\\\n    err.status = 429;\\\\n    throw err;\\\\n  }\\\\n}\\\\n\\\\nasync function getLatestOrderForEmail(env, email) {\\\\n  const candidates = await env.DB.prepare(\\\\n    `SELECT order_id, status, archive_url, encrypted_data, created_at\\\\n     FROM orders\\\\n     ORDER BY datetime(created_at) DESC\\\\n     LIMIT 80`\\\\n  ).all();\\\\n\\\\n  const list = candidates?.results || [];\\\\n  const target = String(email || \\\'\\\').trim().toLowerCase();\\\\n  if (!target) return null;\\\\n\\\\n  for (const o of list) {\\\\n    try {\\\\n      if (!o.encrypted_data) continue;\\\\n      const data = JSON.parse(o.encrypted_data);\\\\n      const e = String(data.email || \\\'\\\').trim().toLowerCase();\\\\n      if (e && e === target) {\\\\n        return {\\\\n          order_id: o.order_id,\\\\n          status: o.status,\\\\n          trackLink: `/buyer-order.html?id=${encodeURIComponent(o.order_id)}`\\\\n        };\\\\n      }\\\\n    } catch {}\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\\n\\\\nfunction getMimeTypeFromFilename(filename) {\\\\n  const ext = (filename || \\\'\\\').split(\\\'.\\\').pop()?.toLowerCase();\\\\n  switch (ext) {\\\\n    case \\\'mp4\\\':\\\\n      return \\\'video/mp4\\\';\\\\n    case \\\'webm\\\':\\\\n      return \\\'video/webm\\\';\\\\n    case \\\'mov\\\':\\\\n      return \\\'video/quicktime\\\';\\\\n    case \\\'m4v\\\':\\\\n      return \\\'video/x-m4v\\\';\\\\n    case \\\'mkv\\\':\\\\n      return \\\'video/x-matroska\\\';\\\\n    case \\\'avi\\\':\\\\n      return \\\'video/x-msvideo\\\';\\\\n    case \\\'wmv\\\':\\\\n      return \\\'video/x-ms-wmv\\\';\\\\n    case \\\'flv\\\':\\\\n      return \\\'video/x-flv\\\';\\\\n    case \\\'jpg\\\':\\\\n    case \\\'jpeg\\\':\\\\n      return \\\'image/jpeg\\\';\\\\n    case \\\'png\\\':\\\\n      return \\\'image/png\\\';\\\\n    case \\\'gif\\\':\\\\n      return \\\'image/gif\\\';\\\\n    case \\\'webp\\\':\\\\n      return \\\'image/webp\\\';\\\\n    case \\\'svg\\\':\\\\n      return \\\'image/svg+xml\\\';\\\\n    case \\\'pdf\\\':\\\\n      return \\\'application/pdf\\\';\\\\n    case \\\'zip\\\':\\\\n      return \\\'application/zip\\\';\\\\n    default:\\\\n      return \\\'\\\';\\\\n  }\\\\n}\\\\n\\\\nfunction resolveContentType(req, filename) {\\\\n  const headerContentType = (req.headers.get(\\\'content-type\\\') || \\\'\\\').split(\\\';\\\')[0].trim().toLowerCase();\\\\n  if (headerContentType && headerContentType !== \\\'application/octet-stream\\\') {\\\\n    return headerContentType;\\\\n  }\\\\n  return getMimeTypeFromFilename(filename) || headerContentType || \\\'application/octet-stream\\\';\\\\n}\\\\n\\\\nfunction normalizeArchiveMetaValue(value) {\\\\n  return (value || \\\'\\\').toString().replace(/[\\\\\\\\r\\\\\\\\n\\\\\\\\t]+/g, \\\' \\\').trim();\\\\n}\\\\n\\\\n// ========================================\\\\n// SLUG + CANONICAL PRODUCT URL HELPERS\\\\n// ========================================\\\\nfunction slugifyStr(input) {\\\\n  return String(input || \\\'\\\')\\\\n    .toLowerCase()\\\\n    .trim()\\\\n    .replace(/[\\\'\\\\"`]/g, \\\'\\\')\\\\n    .replace(/[^a-z0-9]+/g, \\\'-\\\')\\\\n    .replace(/^-+|-+$/g, \\\'\\\')\\\\n    .replace(/-+/g, \\\'-\\\');\\\\n}\\\\n\\\\nfunction canonicalProductPath(product) {\\\\n  const id = product && product.id != null ? String(product.id) : \\\'\\\';\\\\n  const slug = (product && product.slug) ? String(product.slug) : slugifyStr(product && product.title ? product.title : \\\'product\\\');\\\\n  return `/product-${id}/${encodeURIComponent(slug)}`;\\\\n}\\\\n\\\\n// ========================================\\\\n// SERVER-SIDE SCHEMA GENERATION FOR SEO\\\\n// ========================================\\\\n// These functions generate JSON-LD structured data server-side to prevent\\\\n// duplicate schema issues and improve SEO performance. Schemas are injected\\\\n// directly into HTML before it\\\'s sent to the client.\\\\n\\\\n/**\\\\n * Helper function to generate Offer object for Product schemas\\\\n * @param {Object} product - Product data\\\\n * @param {string} baseUrl - Site base URL\\\\n * @returns {Object} Offer schema\\\\n */\\\\nfunction generateOfferObject(product, baseUrl) {\\\\n  const price = parseFloat(product.sale_price || product.normal_price || 0);\\\\n  const date = new Date();\\\\n  date.setFullYear(date.getFullYear() + 1);\\\\n  const priceValidUntil = date.toISOString().split(\\\'T\\\')[0];\\\\n  \\\\n  // Check if product is digital (instant_delivery = 1 means digital/no shipping)\\\\n  const isDigital = product.instant_delivery === 1;\\\\n\\\\n  const offer = {\\\\n    \\\\"@type\\\\": \\\\"Offer\\\\",\\\\n    \\\\"url\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n    \\\\"priceCurrency\\\\": \\\\"USD\\\\",\\\\n    \\\\"price\\\\": price.toString(),\\\\n    \\\\"availability\\\\": \\\\"https://schema.org/InStock\\\\",\\\\n    \\\\"itemCondition\\\\": \\\\"https://schema.org/NewCondition\\\\",\\\\n    \\\\"priceValidUntil\\\\": priceValidUntil,\\\\n    \\\\"seller\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Organization\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\"\\\\n    }\\\\n  };\\\\n\\\\n  // Only add shipping details for physical products (non-digital)\\\\n  if (!isDigital) {\\\\n    offer.shippingDetails = {\\\\n      \\\\"@type\\\\": \\\\"OfferShippingDetails\\\\",\\\\n      \\\\"shippingDestination\\\\": [\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"US\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"GB\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"CA\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"AU\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"DE\\\\"\\\\n        },\\\\n        {\\\\n          \\\\"@type\\\\": \\\\"DefinedRegion\\\\",\\\\n          \\\\"addressCountry\\\\": \\\\"FR\\\\"\\\\n        }\\\\n      ],\\\\n      \\\\"shippingRate\\\\": {\\\\n        \\\\"@type\\\\": \\\\"MonetaryAmount\\\\",\\\\n        \\\\"currency\\\\": \\\\"USD\\\\",\\\\n        \\\\"value\\\\": \\\\"0\\\\"\\\\n      },\\\\n      \\\\"deliveryTime\\\\": {\\\\n        \\\\"@type\\\\": \\\\"ShippingDeliveryTime\\\\",\\\\n        \\\\"handlingTime\\\\": {\\\\n          \\\\"@type\\\\": \\\\"QuantitativeValue\\\\",\\\\n          \\\\"minValue\\\\": 0,\\\\n          \\\\"maxValue\\\\": 1,\\\\n          \\\\"unitCode\\\\": \\\\"DAY\\\\"\\\\n        },\\\\n        \\\\"transitTime\\\\": {\\\\n          \\\\"@type\\\\": \\\\"QuantitativeValue\\\\",\\\\n          \\\\"minValue\\\\": 1,\\\\n          \\\\"maxValue\\\\": 3,\\\\n          \\\\"unitCode\\\\": \\\\"DAY\\\\"\\\\n        }\\\\n      }\\\\n    };\\\\n    \\\\n    offer.hasMerchantReturnPolicy = {\\\\n      \\\\"@type\\\\": \\\\"MerchantReturnPolicy\\\\",\\\\n      \\\\"applicableCountry\\\\": \\\\"US\\\\",\\\\n      \\\\"returnPolicyCategory\\\\": \\\\"MerchantReturnNotPermitted\\\\",\\\\n      \\\\"merchantReturnDays\\\\": 0\\\\n    };\\\\n  }\\\\n\\\\n  return offer;\\\\n}\\\\n\\\\n/**\\\\n * Generate Product schema for individual product pages\\\\n * @param {Object} product - Product data from database\\\\n * @param {string} baseUrl - Site base URL\\\\n * @param {Array} reviews - Individual reviews for this product\\\\n * @returns {string} JSON-LD schema as string\\\\n */\\\\nfunction generateProductSchema(product, baseUrl, reviews = []) {\\\\n  const sku = product.slug ? `WV-${product.id}-${product.slug.toUpperCase().replace(/-/g, \\\'\\\')}` : `WV-${product.id}`;\\\\n\\\\n  const schema = {\\\\n    \\\\"@context\\\\": \\\\"https://schema.org/\\\\",\\\\n    \\\\"@type\\\\": \\\\"Product\\\\",\\\\n    \\\\"@id\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n    \\\\"name\\\\": product.title,\\\\n    \\\\"description\\\\": product.seo_description || product.description || product.title,\\\\n    \\\\"sku\\\\": sku,\\\\n    \\\\"mpn\\\\": sku,\\\\n    \\\\"image\\\\": product.thumbnail_url ? [product.thumbnail_url] : [],\\\\n    \\\\"brand\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Brand\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\",\\\\n      \\\\"logo\\\\": `${baseUrl}/favicon.ico`\\\\n    },\\\\n    \\\\"manufacturer\\\\": {\\\\n      \\\\"@type\\\\": \\\\"Organization\\\\",\\\\n      \\\\"name\\\\": \\\\"WishVideo\\\\",\\\\n      \\\\"url\\\\": baseUrl\\\\n    },\\\\n    \\\\"category\\\\": \\\\"Digital Goods > Personalized Videos\\\\",\\\\n    \\\\"offers\\\\": generateOfferObject(product, baseUrl)\\\\n  };\\\\n\\\\n   // Add aggregateRating (always present, even with 0 reviews for better Rich Results)\\\\n   schema.aggregateRating = {\\\\n     \\\\"@type\\\\": \\\\"AggregateRating\\\\",\\\\n     \\\\"ratingValue\\\\": parseFloat(product.rating_average) || 5.0,\\\\n     \\\\"reviewCount\\\\": Math.max(1, parseInt(product.review_count) || 1),\\\\n     \\\\"bestRating\\\\": 5,\\\\n     \\\\"worstRating\\\\": 1\\\\n   };\\\\n\\\\n   // Add individual reviews (first 5 for Rich Results)\\\\n   if (reviews && reviews.length > 0) {\\\\n     const limitedReviews = reviews.slice(0, 5);\\\\n     schema.review = limitedReviews.map(review => ({\\\\n      \\\\"@type\\\\": \\\\"Review\\\\",\\\\n      \\\\"reviewRating\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Rating\\\\",\\\\n        \\\\"ratingValue\\\\": review.rating,\\\\n        \\\\"bestRating\\\\": 5,\\\\n        \\\\"worstRating\\\\": 1\\\\n      },\\\\n      \\\\"author\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Person\\\\",\\\\n        \\\\"name\\\\": review.author_name || \\\\"Customer\\\\"\\\\n      },\\\\n      \\\\"reviewBody\\\\": review.comment || \\\\"\\\\",\\\\n      \\\\"datePublished\\\\": review.created_at ? new Date(review.created_at).toISOString().split(\\\'T\\\')[0] : new Date().toISOString().split(\\\'T\\\')[0]\\\\n    }));\\\\n  }\\\\n\\\\n  return JSON.stringify(schema);\\\\n}\\\\n\\\\n/**\\\\n * Generate ItemList schema for product collection pages\\\\n * @param {Array} products - Array of product data\\\\n * @param {string} baseUrl - Site base URL\\\\n * @returns {string} JSON-LD schema as string\\\\n */\\\\nfunction generateCollectionSchema(products, baseUrl) {\\\\n  if (!products || products.length === 0) {\\\\n    return \\\'{}\\\';\\\\n  }\\\\n\\\\n  const itemListElement = products.map((product, index) => {\\\\n    const item = {\\\\n      \\\\"@type\\\\": \\\\"ListItem\\\\",\\\\n      \\\\"position\\\\": index + 1,\\\\n      \\\\"url\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n      \\\\"item\\\\": {\\\\n        \\\\"@type\\\\": \\\\"Product\\\\",\\\\n        \\\\"@id\\\\": `${baseUrl}${canonicalProductPath(product)}`,\\\\n        \\\\"name\\\\": product.title,\\\\n        \\\\"description\\\\": product.description || product.title,\\\\n        \\\\"image\\\\": product.thumbnail_url || `${baseUrl}/placeholder.jpg`,\\\\n        \\\\"brand\\\\": {\\\\n          \\\\"@type\\\\": \\\\"Brand\\\\",\\\\n          \\\\"name\\\\": \\\\"WishVideo\\\\"\\\\n        },\\\\n        \\\\"offers\\\\": generateOfferObject(product, baseUrl)\\\\n      }\\\\n    };\\\\n\\\\n    // Add aggregateRating (always present for better Rich Results)\\\\n    item.item.aggregateRating = {\\\\n      \\\\"@type\\\\": \\\\"AggregateRating\\\\",\\\\n      \\\\"ratingValue\\\\": parseFloat(product.rating_average) || 5.0,\\\\n      \\\\"reviewCount\\\\": Math.max(1, parseInt(product.review_count) || 1),\\\\n      \\\\"bestRating\\\\": 5,\\\\n      \\\\"worstRating\\\\": 1\\\\n    };\\\\n\\\\n    return item;\\\\n  });\\\\n\\\\n  const schema = {\\\\n    \\\\"@context\\\\": \\\\"https://schema.org/\\\\",\\\\n    \\\\"@type\\\\": \\\\"ItemList\\\\",\\\\n    \\\\"itemListElement\\\\": itemListElement\\\\n  };\\\\n\\\\n  return JSON.stringify(schema);\\\\n}\\\\n\\\\n/**\\\\n * Inject schema into HTML by replacing placeholder\\\\n * @param {string} html - Original HTML content\\\\n * @param {string} schemaId - ID of schema tag (product-schema or collection-schema)\\\\n * @param {string} schemaJson - JSON-LD schema string\\\\n * @returns {string} Modified HTML with schema injected\\\\n */\\\\nfunction injectSchemaIntoHTML(html, schemaId, schemaJson) {\\\\n  // Replace empty schema placeholder with actual data\\\\n  const placeholder = `<script type=\\\\"application/ld+json\\\\" id=\\\\"${schemaId}\\\\">{}</script>`;\\\\n  const replacement = `<script type=\\\\"application/ld+json\\\\" id=\\\\"${schemaId}\\\\">${schemaJson}</script>`;\\\\n  return html.replace(placeholder, replacement);\\\\n}\\\\n\\\\nlet dbReady = false;\\\\n\\\\n// Internal flag used to ensure the automatic cache purge check only runs\\\\n// once per worker instance.  Without this, every request would attempt to\\\\n// read from the database to determine if a purge is needed, which can\\\\n// unnecessarily slow down static asset delivery.  Once `maybePurgeCache`\\\\n// runs for the first time, this flag is set to true and subsequent calls\\\\n// will immediately return.\\\\nlet purgeVersionChecked = false;\\\\n\\\\nasync function initDB(env) {\\\\n  if (dbReady || !env.DB) return;\\\\n  \\\\n  try {\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS products (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        title TEXT, slug TEXT, description TEXT,\\\\n        normal_price REAL, sale_price REAL,\\\\n        instant_delivery INTEGER DEFAULT 0,\\\\n        normal_delivery_text TEXT,\\\\n        thumbnail_url TEXT, video_url TEXT,\\\\n        gallery_images TEXT,\\\\n        addons_json TEXT,\\\\n        seo_title TEXT, seo_description TEXT, seo_keywords TEXT, seo_canonical TEXT,\\\\n        whop_plan TEXT, whop_price_map TEXT,\\\\n        whop_product_id TEXT,\\\\n        status TEXT DEFAULT \\\'active\\\',\\\\n        sort_order INTEGER DEFAULT 0\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add gallery_images column to existing products table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT gallery_images FROM products LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding gallery_images column to products table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE products ADD COLUMN gallery_images TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS orders (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        order_id TEXT UNIQUE, product_id INTEGER,\\\\n        encrypted_data TEXT, iv TEXT,\\\\n        archive_url TEXT, archive_data TEXT,\\\\n        status TEXT DEFAULT \\\'pending\\\',\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT,\\\\n        delivered_video_metadata TEXT,\\\\n        portfolio_enabled INTEGER DEFAULT 1,\\\\n        delivered_at DATETIME,\\\\n        delivery_time_minutes INTEGER DEFAULT 60,\\\\n        revision_count INTEGER DEFAULT 0,\\\\n        revision_requested INTEGER DEFAULT 0\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add delivered_video_metadata column to existing orders table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT delivered_video_metadata FROM orders LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding delivered_video_metadata column to orders table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE orders ADD COLUMN delivered_video_metadata TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS reviews (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        product_id INTEGER, author_name TEXT, rating INTEGER, comment TEXT,\\\\n        status TEXT DEFAULT \\\'approved\\\',\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        order_id TEXT, show_on_product INTEGER DEFAULT 1,\\\\n        delivered_video_url TEXT, delivered_thumbnail_url TEXT\\\\n      )\\\\n    `).run();\\\\n    \\\\n    // Auto-migration: Add delivery columns if missing\\\\n    try {\\\\n      const tableInfo = await env.DB.prepare(`PRAGMA table_info(reviews)`).all();\\\\n      const columns = tableInfo.results.map(col => col.name);\\\\n      if (!columns.includes(\\\'delivered_video_url\\\')) {\\\\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_video_url TEXT`).run();\\\\n      }\\\\n      if (!columns.includes(\\\'delivered_thumbnail_url\\\')) {\\\\n        await env.DB.prepare(`ALTER TABLE reviews ADD COLUMN delivered_thumbnail_url TEXT`).run();\\\\n      }\\\\n    } catch (e) { /* ignore */ }\\\\n\\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT)`).run();\\\\n    \\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS pages (\\\\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n      slug TEXT UNIQUE, title TEXT, content TEXT,\\\\n      meta_description TEXT, status TEXT DEFAULT \\\'published\\\',\\\\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\\\\n    )`).run();\\\\n\\\\n    await env.DB.prepare(`CREATE TABLE IF NOT EXISTS checkout_sessions (\\\\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n      checkout_id TEXT UNIQUE,\\\\n      product_id INTEGER,\\\\n      plan_id TEXT,\\\\n      expires_at DATETIME,\\\\n      status TEXT DEFAULT \\\'pending\\\',\\\\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n      completed_at DATETIME\\\\n    )`).run();\\\\n\\\\n    \\\\n    // Chat tables\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS chat_sessions (\\\\n        id TEXT PRIMARY KEY,\\\\n        name TEXT NOT NULL,\\\\n        email TEXT NOT NULL,\\\\n        blocked INTEGER DEFAULT 0,\\\\n        last_message_content TEXT,\\\\n        last_message_at DATETIME,\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\\\n      )\\\\n    `).run();\\\\n\\\\n    // Add blocked column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT blocked FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding blocked column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN blocked INTEGER DEFAULT 0\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n    // Add last_message_content column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT last_message_content FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding last_message_content column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN last_message_content TEXT\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n    // Add last_message_at column to existing chat_sessions table if it doesn\\\'t exist\\\\n    try {\\\\n      await env.DB.prepare(\\\'SELECT last_message_at FROM chat_sessions LIMIT 1\\\').run();\\\\n    } catch (e) {\\\\n      try {\\\\n        console.log(\\\'Adding last_message_at column to chat_sessions table...\\\');\\\\n        await env.DB.prepare(\\\'ALTER TABLE chat_sessions ADD COLUMN last_message_at DATETIME\\\').run();\\\\n      } catch (alterError) {\\\\n        console.log(\\\'Column might already exist:\\\', alterError.message);\\\\n      }\\\\n    }\\\\n\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE TABLE IF NOT EXISTS chat_messages (\\\\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n        session_id TEXT NOT NULL,\\\\n        role TEXT NOT NULL,\\\\n        content TEXT NOT NULL,\\\\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\\\\n        FOREIGN KEY (session_id) REFERENCES chat_sessions(id)\\\\n      )\\\\n    `).run();\\\\n\\\\n    await env.DB.prepare(`\\\\n      CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id_id\\\\n      ON chat_messages(session_id, id)\\\\n    `).run();\\\\n\\\\ndbReady = true;\\\\n  } catch (e) {\\\\n    console.error(\\\'DB init error:\\\', e);\\\\n  }\\\\n}\\\\n\\\\n/*\\\\n * Automatically purge Cloudflare\\\'s edge cache when a new version of the\\\\n * worker is deployed.  On the first request of a new deployment, this\\\\n * function checks a value in the settings table (`last_purge_version`). If\\\\n * it differs from the current VERSION, the worker will call the Cloudflare\\\\n * API to purge all cached assets for the configured zone.  This ensures\\\\n * that outdated static assets are never served from the edge when a new\\\\n * version is published.  To enable this feature, define `CF_ZONE_ID` and\\\\n * `CF_API_TOKEN` in your wrangler.toml or via secrets.  The purge will\\\\n * silently skip if those variables are missing.\\\\n */\\\\nasync function maybePurgeCache(env) {\\\\n  // Only purge if we have the necessary bindings and tokens\\\\n  if (!env || !env.DB || !env.CF_ZONE_ID || !env.CF_API_TOKEN) return;\\\\n  // If we\\\'ve already performed this check during the lifetime of this\\\\n  // worker instance, skip further processing to avoid repeated DB calls.\\\\n  if (purgeVersionChecked) return;\\\\n  try {\\\\n    // Ensure the database schema exists\\\\n    await initDB(env);\\\\n    // Fetch the last version that triggered a purge\\\\n    let row = null;\\\\n    try {\\\\n      row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'last_purge_version\\\').first();\\\\n    } catch (_) {\\\\n      // Table might not exist; ignore\\\\n    }\\\\n    const lastVersion = row && row.value ? row.value.toString() : null;\\\\n    const currentVersion = VERSION.toString();\\\\n    if (lastVersion === currentVersion) {\\\\n      // Mark that we\\\'ve checked this version; no need to re-check on future requests\\\\n      purgeVersionChecked = true;\\\\n      return; // Already purged for this version\\\\n    }\\\\n    // Call Cloudflare API to purge everything\\\\n    const zoneId = env.CF_ZONE_ID;\\\\n    const token = env.CF_API_TOKEN;\\\\n    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\\\\n    const response = await fetch(purgeUrl, {\\\\n      method: \\\'POST\\\',\\\\n      headers: {\\\\n        \\\'Authorization\\\': `Bearer ${token}`,\\\\n        \\\'Content-Type\\\': \\\'application/json\\\'\\\\n      },\\\\n      body: JSON.stringify({ purge_everything: true })\\\\n    });\\\\n    // Even if the purge fails, we update the version to avoid repeated attempts\\\\n    await env.DB.prepare(\\\\n      \\\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\\\'\\\\n    ).bind(\\\'last_purge_version\\\', currentVersion).run();\\\\n    // Set the flag to avoid repeated attempts in this instance\\\\n    purgeVersionChecked = true;\\\\n    if (!response.ok) {\\\\n      const text = await response.text();\\\\n      console.warn(\\\'Cache purge request failed:\\\', text);\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'maybePurgeCache error:\\\', e);\\\\n  }\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Whop API key.\\\\n * First checks database settings (from admin panel), then falls back to env variable.\\\\n * This allows users to configure API key via admin UI.\\\\n */\\\\nasync function getWhopApiKey(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.api_key) {\\\\n          return settings.api_key;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'Error reading API key from database:\\\', e);\\\\n  }\\\\n  // Fallback to environment variable\\\\n  return env.WHOP_API_KEY || null;\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Whop webhook secret.\\\\n * First checks database settings, then falls back to env variable.\\\\n */\\\\nasync function getWhopWebhookSecret(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.webhook_secret) {\\\\n          return settings.webhook_secret;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.error(\\\'Error reading webhook secret from database:\\\', e);\\\\n  }\\\\n  // Fallback to environment variable\\\\n  return env.WHOP_WEBHOOK_SECRET || null;\\\\n}\\\\n\\\\n/**\\\\n * Helper function to get Google Apps Script URL for email webhooks.\\\\n * Retrieves from database settings.\\\\n */\\\\nasync function getGoogleScriptUrl(env) {\\\\n  try {\\\\n    if (env.DB) {\\\\n      const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n      if (row && row.value) {\\\\n        const settings = JSON.parse(row.value);\\\\n        if (settings.google_webapp_url) {\\\\n          return settings.google_webapp_url;\\\\n        }\\\\n      }\\\\n    }\\\\n  } catch (e) {\\\\n    console.warn(\\\'Error reading Google Script URL from database:\\\', e);\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\\nexport default {\\\\n  async fetch(req, env) {\\\\n    const url = new URL(req.url);\\\\n    // Normalize the request path.  Collapse multiple consecutive slashes\\\\n    // into a single slash (e.g. //api/debug -> /api/debug) to avoid\\\\n    // accidental 404s or redirect loops when users include double\\\\n    // slashes in the URL.\\\\u3010979016842149196\\\\u2020L0-L1\\\\u3011\\\\n    let path = url.pathname.replace(/\\\\\\\\/+/g, \\\'/\\\');\\\\n    if (!path.startsWith(\\\'/\\\')) {\\\\n      path = \\\'/\\\' + path;\\\\n    }\\\\n    const method = req.method;\\\\n\\\\n    // Before processing any request, trigger a cache purge if this is the\\\\n    // first request on a new version.  The purge will run only once per\\\\n    // deployment and only if the necessary environment variables are set.\\\\n    // Only run cache purge checks for admin surfaces or webhook calls (avoid DB hits for every customer page view)\\\\n    const shouldPurgeCache = path.startsWith(\\\'/admin/\\\') || path.startsWith(\\\'/api/admin/\\\') || path.startsWith(\\\'/api/whop/webhook\\\');\\\\n    if (shouldPurgeCache) {\\\\n      await maybePurgeCache(env);\\\\n    }\\\\n\\\\n    if (method === \\\'OPTIONS\\\') {\\\\n      return new Response(null, { headers: CORS });\\\\n    }\\\\n\\\\n    try {\\\\n      if (path === \\\'/api/health\\\') {\\\\n        return json({ ok: true, time: Date.now() });\\\\n      }\\\\n\\\\n      // Server time endpoint for accurate countdown calculations\\\\n      if (path === \\\'/api/time\\\') {\\\\n        return json({ serverTime: Date.now() });\\\\n      }\\\\n\\\\n      // Private asset: never serve the raw product template directly\\\\n      if ((method === \\\'GET\\\' || method === \\\'HEAD\\\') && (path === \\\'/_product_template.tpl\\\' || path === \\\'/_product_template\\\' || path === \\\'/_product_template.html\\\')) {\\\\n        return new Response(\\\'Not found\\\', { status: 404 });\\\\n      }\\\\n\\\\n\\\\n\\\\n      // ------------------------------\\\\n      // Canonical product URLs\\\\n      // ------------------------------\\\\n      // We keep supporting legacy /product?id=123 but we canonicalize to:\\\\n      //   /product-123/<slug>\\\\n      // We also support old pretty URLs /product/<slug> by redirecting to the\\\\n      // canonical form to ensure the product page always has the numeric ID.\\\\n      if ((method === \\\'GET\\\' || method === \\\'HEAD\\\') && (path === \\\'/product\\\' || path.startsWith(\\\'/product/\\\'))) {\\\\n        if (!env.DB) {\\\\n          // If DB is not configured, fall through to assets (will likely 404).\\\\n        } else {\\\\n          await initDB(env);\\\\n\\\\n          // Block direct access to the private template asset from the public internet.\\\\n          if (path === \\\'/_product_template.tpl\\\') {\\\\n            return new Response(\\\'Not found\\\', { status: 404 });\\\\n          }\\\\n\\\\n          // Legacy: /product?id=123  ->  /product-123/<slug>\\\\n          const legacyId = (path === \\\'/product\\\') ? url.searchParams.get(\\\'id\\\') : null;\\\\n          if (legacyId) {\\\\n            const p = await env.DB.prepare(\\\'SELECT id, title, slug FROM products WHERE id = ? LIMIT 1\\\').bind(Number(legacyId)).first();\\\\n            if (p) {\\\\n              const slug = p.slug ? String(p.slug) : slugifyStr(p.title);\\\\n              // Backfill slug if missing\\\\n              if (!p.slug) {\\\\n                try {\\\\n                  await env.DB.prepare(\\\'UPDATE products SET slug = ? WHERE id = ?\\\').bind(slug, Number(p.id)).run();\\\\n                } catch (e) {}\\\\n              }\\\\n              const canonical = `/product-${p.id}/${encodeURIComponent(slug)}`;\\\\n              return Response.redirect(`${url.origin}${canonical}`, 301);\\\\n            }\\\\n          }\\\\n\\\\n          // Old pretty: /product/<slug>  ->  /product-<id>/<slug>\\\\n          if (path.startsWith(\\\'/product/\\\') && path.length > \\\'/product/\\\'.length) {\\\\n            const slugIn = decodeURIComponent(path.slice(\\\'/product/\\\'.length));\\\\n            const row = await env.DB.prepare(\\\'SELECT id, title, slug FROM products WHERE slug = ? LIMIT 1\\\').bind(slugIn).first();\\\\n            if (row) {\\\\n              const canonicalSlug = row.slug ? String(row.slug) : slugifyStr(row.title);\\\\n              if (!row.slug) {\\\\n                try {\\\\n                  await env.DB.prepare(\\\'UPDATE products SET slug = ? WHERE id = ?\\\').bind(canonicalSlug, Number(row.id)).run();\\\\n                } catch (e) {}\\\\n              }\\\\n              const canonical = `/product-${row.id}/${encodeURIComponent(canonicalSlug)}`;\\\\n              return Response.redirect(`${url.origin}${canonical}`, 301);\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      // ------------------------------\\\\n      // Chat APIs (Customer + Admin)\\\\n      // ------------------------------\\\\n      if (path === \\\'/api/chat/start\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const nameIn = String(body.name || \\\'\\\').trim();\\\\n        const emailIn = String(body.email || \\\'\\\').trim();\\\\n\\\\n        if (!nameIn || !emailIn) return json({ error: \\\'Name and email are required\\\' }, 400);\\\\n\\\\n        // Basic normalization\\\\n        const email = emailIn.toLowerCase();\\\\n        const name = nameIn;\\\\n\\\\n        // One email = one session (reuse + cleanup)\\\\n        const canonical = await env.DB.prepare(\\\\n          `SELECT id, name, created_at\\\\n           FROM chat_sessions\\\\n           WHERE lower(email) = lower(?)\\\\n           ORDER BY datetime(created_at) ASC\\\\n           LIMIT 1`\\\\n        ).bind(email).first();\\\\n\\\\n        if (canonical?.id) {\\\\n          const canonicalId = String(canonical.id);\\\\n\\\\n          // Update name if it changed (optional but keeps admin tidy)\\\\n          if (name && canonical.name !== name) {\\\\n            await env.DB.prepare(\\\\n              `UPDATE chat_sessions SET name = ? WHERE id = ?`\\\\n            ).bind(name, canonicalId).run();\\\\n          }\\\\n\\\\n          // Migrate any stray sessions/messages for this email into the canonical session\\\\n          const others = await env.DB.prepare(\\\\n            `SELECT id FROM chat_sessions\\\\n             WHERE lower(email) = lower(?) AND id != ?`\\\\n          ).bind(email, canonicalId).all();\\\\n\\\\n          const otherIds = (others?.results || []).map(r => String(r.id));\\\\n          for (const sid of otherIds) {\\\\n            await env.DB.prepare(\\\\n              `UPDATE chat_messages SET session_id = ? WHERE session_id = ?`\\\\n            ).bind(canonicalId, sid).run();\\\\n\\\\n            await env.DB.prepare(\\\\n              `DELETE FROM chat_sessions WHERE id = ?`\\\\n            ).bind(sid).run();\\\\n          }\\\\n\\\\n          return json({ sessionId: canonicalId, reused: true });\\\\n        }\\\\n\\\\n        // Create new session\\\\n        const sessionId = crypto.randomUUID();\\\\n\\\\n        await env.DB.prepare(\\\\n          `INSERT INTO chat_sessions (id, name, email) VALUES (?, ?, ?)`\\\\n        ).bind(sessionId, escapeHtml(name), escapeHtml(email)).run();\\\\n\\\\n        return json({ sessionId, reused: false });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/chat/sync\\\' && method === \\\'GET\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        const sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n        const sinceIdRaw = url.searchParams.get(\\\'sinceId\\\') || \\\'0\\\';\\\\n        const sinceId = Number(sinceIdRaw) || 0;\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        const rows = await env.DB.prepare(\\\\n          `SELECT id, role, content, created_at\\\\n           FROM chat_messages\\\\n           WHERE session_id = ? AND id > ?\\\\n           ORDER BY id ASC\\\\n           LIMIT 100`\\\\n        ).bind(sessionId, sinceId).all();\\\\n\\\\n        const messages = rows?.results || [];\\\\n        const lastId = messages.length ? messages[messages.length - 1].id : sinceId;\\\\n\\\\n        return json({ messages, lastId });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/chat/send\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        const roleRaw = String(body.role || \\\'user\\\').trim().toLowerCase();\\\\n\\\\n        // accept content or message\\\\n        const rawContent = String(body.content ?? body.message ?? \\\'\\\');\\\\n\\\\n        const role = [\\\'user\\\', \\\'admin\\\', \\\'system\\\'].includes(roleRaw) ? roleRaw : \\\'user\\\';\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        // Strict blocking: do not allow blocked sessions to send customer messages\\\\n        const sess = await env.DB.prepare(\\\\n          `SELECT blocked FROM chat_sessions WHERE id = ?`\\\\n        ).bind(sessionId).first();\\\\n\\\\n        if (role === \\\'user\\\' && Number(sess?.blocked || 0) === 1) {\\\\n          return json({ success: false, error: \\\\"You have been blocked by support.\\\\" }, 403);\\\\n        }\\\\n\\\\n        const trimmed = rawContent.trim();\\\\n        if (!trimmed) return json({ error: \\\'content is required\\\' }, 400);\\\\n\\\\n        // 500 char limit (backend)\\\\n        if (trimmed.length > 500) return json({ error: \\\'Message too long (max 500 characters)\\\' }, 400);\\\\n\\\\n        // Rate limit customers only (1 msg/sec)\\\\n        try {\\\\n          if (role === \\\'user\\\') await enforceUserRateLimit(env, sessionId);\\\\n        } catch (e) {\\\\n          if (e?.status === 429) return json({ error: \\\'Too many messages. Please wait a moment.\\\' }, 429);\\\\n          throw e;\\\\n        }\\\\n\\\\n        // Determine if this is the user\\\'s first message BEFORE inserting\\\\n        let isFirstUserMessage = false;\\\\n        if (role === \\\'user\\\') {\\\\n          const countRow = await env.DB.prepare(\\\\n            `SELECT COUNT(*) as c\\\\n             FROM chat_messages\\\\n             WHERE session_id = ? AND role = \\\'user\\\'`\\\\n          ).bind(sessionId).first();\\\\n          isFirstUserMessage = Number(countRow?.c || 0) === 0;\\\\n        }\\\\n\\\\n        // XSS protection: escape before storing\\\\n        const safeContent = escapeHtml(trimmed);\\\\n\\\\n        const insertRes = await env.DB.prepare(\\\\n          `INSERT INTO chat_messages (session_id, role, content) VALUES (?, ?, ?)`\\\\n        ).bind(sessionId, role, safeContent).run();\\\\n\\\\n        // Update denormalized last-message fields for fast admin listing\\\\n        try {\\\\n          await env.DB.prepare(\\\\n            `UPDATE chat_sessions\\\\n             SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n             WHERE id = ?`\\\\n          ).bind(safeContent, sessionId).run();\\\\n        } catch (e) {\\\\n          console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n        }\\\\n\\\\n        // Trigger email alert webhook on first customer message\\\\n        if (isFirstUserMessage) {\\\\n          try {\\\\n            const setting = await env.DB.prepare(\\\\n              `SELECT value FROM settings WHERE key = ?`\\\\n            ).bind(\\\'GOOGLE_SCRIPT_URL\\\').first();\\\\n\\\\n            const scriptUrl = String(setting?.value || \\\'\\\').trim();\\\\n\\\\n            if (scriptUrl) {\\\\n              const session = await env.DB.prepare(\\\\n                `SELECT id, name, email, created_at FROM chat_sessions WHERE id = ?`\\\\n              ).bind(sessionId).first();\\\\n\\\\n              await fetch(scriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'first_customer_message\\\',\\\\n                  sessionId,\\\\n                  name: session?.name || null,\\\\n                  email: session?.email || null,\\\\n                  created_at: session?.created_at || null,\\\\n                  message: trimmed\\\\n                })\\\\n              });\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(\\\'Chat webhook trigger failed:\\\', e);\\\\n          }\\\\n        }\\\\n\\\\n        // ------------------------------\\\\n        // Smart Quick Action Auto-Replies\\\\n        // ------------------------------\\\\n        if (role === \\\'user\\\') {\\\\n          const normalized = normalizeQuickAction(trimmed);\\\\n          const session = await env.DB.prepare(\\\\n            `SELECT email FROM chat_sessions WHERE id = ?`\\\\n          ).bind(sessionId).first();\\\\n\\\\n          const email = String(session?.email || \\\'\\\').trim();\\\\n          const origin = new URL(req.url).origin;\\\\n\\\\n          // \\\\"My Order Status\\\\"\\\\n          if (normalized === \\\'my order status\\\') {\\\\n            let replyText = \\\\"We couldn\\\'t find any recent orders for this email.\\\\";\\\\n\\\\n            if (email) {\\\\n              const lastOrder = await getLatestOrderForEmail(env, email);\\\\n              if (lastOrder) {\\\\n                const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\\\\n                replyText = `Your last order #${lastOrder.order_id} is currently ${lastOrder.status || \\\'unknown\\\'}. Track it here: ${link}`;\\\\n              }\\\\n            }\\\\n\\\\n            const safeReply = escapeHtml(replyText);\\\\n            await env.DB.prepare(\\\\n              `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \\\'system\\\', ?)`\\\\n            ).bind(sessionId, safeReply).run();\\\\n\\\\n            // Update denormalized last-message fields\\\\n            try {\\\\n              await env.DB.prepare(\\\\n                `UPDATE chat_sessions\\\\n                 SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n                 WHERE id = ?`\\\\n              ).bind(safeReply, sessionId).run();\\\\n            } catch (e) {\\\\n              console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n            }\\\\n          }\\\\n\\\\n          // \\\\"Check Delivery Status\\\\"\\\\n          if (normalized === \\\'check delivery status\\\') {\\\\n            let replyText = \\\\"No recent orders found for this email.\\\\";\\\\n\\\\n            if (email) {\\\\n              const lastOrder = await getLatestOrderForEmail(env, email);\\\\n              if (lastOrder) {\\\\n                const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\\\\n                replyText = `Your last order is ${lastOrder.status || \\\'unknown\\\'}. View details here: ${link}`;\\\\n              }\\\\n            }\\\\n\\\\n            const safeReply = escapeHtml(replyText);\\\\n            await env.DB.prepare(\\\\n              `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \\\'system\\\', ?)`\\\\n            ).bind(sessionId, safeReply).run();\\\\n\\\\n            // Update denormalized last-message fields\\\\n            try {\\\\n              await env.DB.prepare(\\\\n                `UPDATE chat_sessions\\\\n                 SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\\\\n                 WHERE id = ?`\\\\n              ).bind(safeReply, sessionId).run();\\\\n            } catch (e) {\\\\n              console.error(\\\'Failed to update chat_sessions last-message fields:\\\', e);\\\\n            }\\\\n          }\\\\n        }\\\\n\\\\n        return json({ success: true, messageId: insertRes?.meta?.last_row_id || null });\\\\n      }\\\\n\\\\n      // ----- ADMIN CHAT API -----\\\\n      // ----- ADMIN CHAT API -----\\\\n      if (path === \\\'/api/admin/chats/block\\\' && method === \\\'POST\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let body;\\\\n        try { body = await req.json(); } catch { body = {}; }\\\\n\\\\n        const sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        const blocked = body.blocked === true || body.blocked === 1 || body.blocked === \\\'true\\\';\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        await env.DB.prepare(\\\\n          `UPDATE chat_sessions SET blocked = ? WHERE id = ?`\\\\n        ).bind(blocked ? 1 : 0, sessionId).run();\\\\n\\\\n        return json({ success: true, blocked: blocked ? 1 : 0 });\\\\n      }\\\\n\\\\n      if (path === \\\'/api/admin/chats/delete\\\' && method === \\\'DELETE\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        let sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n        if (!sessionId) {\\\\n          let body;\\\\n          try { body = await req.json(); } catch { body = {}; }\\\\n          sessionId = String(body.sessionId || \\\'\\\').trim();\\\\n        } else {\\\\n          sessionId = String(sessionId).trim();\\\\n        }\\\\n\\\\n        if (!sessionId) return json({ error: \\\'sessionId is required\\\' }, 400);\\\\n\\\\n        // Delete messages first, then session\\\\n        await env.DB.prepare(`DELETE FROM chat_messages WHERE session_id = ?`).bind(sessionId).run();\\\\n        await env.DB.prepare(`DELETE FROM chat_sessions WHERE id = ?`).bind(sessionId).run();\\\\n\\\\n        return json({ success: true });\\\\n      }\\\\n\\\\nif (path === \\\'/api/admin/chats/sessions\\\' && method === \\\'GET\\\') {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        // One row per email (canonical session = oldest created_at for that email)\\\\n        // Denormalized fields on chat_sessions let us avoid heavy subqueries.\\\\n        const rows = await env.DB.prepare(\\\\n          `SELECT\\\\n             s.id,\\\\n             s.name,\\\\n             s.email,\\\\n             s.blocked,\\\\n             s.last_message_at,\\\\n             s.last_message_content AS last_message,\\\\n             s.created_at\\\\n           FROM chat_sessions s\\\\n           JOIN (\\\\n             SELECT lower(email) AS em, MIN(datetime(created_at)) AS min_created\\\\n             FROM chat_sessions\\\\n             GROUP BY lower(email)\\\\n           ) x\\\\n             ON lower(s.email) = x.em AND datetime(s.created_at) = x.min_created\\\\n           ORDER BY COALESCE(s.last_message_at, s.created_at) DESC\\\\n           LIMIT 200`\\\\n        ).all();\\\\n\\\\n        return json({ sessions: rows?.results || [] });\\\\n      }\\\\n\\\\n\\\\n      if (path === \\\'/api/debug\\\') {\\\\n        return json({\\\\n          status: \\\'running\\\',\\\\n          bindings: {\\\\n            DB: !!env.DB,\\\\n            R2_BUCKET: !!env.R2_BUCKET,\\\\n            PRODUCT_MEDIA: !!env.PRODUCT_MEDIA,\\\\n            ASSETS: !!env.ASSETS\\\\n          },\\\\n          // Include the current version and a timestamp to assist with\\\\n          // debugging deployments.  The version is injected at build time\\\\n          // through the VERSION constant defined above.\\\\n          version: VERSION,\\\\n          timestamp: new Date().toISOString()\\\\n        });\\\\n      }\\\\n\\\\n      if (path.startsWith(\\\'/api/\\\')) {\\\\n        if (!env.DB) return json({ error: \\\'Database not configured\\\' }, 500);\\\\n        await initDB(env);\\\\n\\\\n        // ----- CACHE PURGE -----\\\\n        // Endpoint to purge Cloudflare cache via API.  Requires CF_ZONE_ID and CF_API_TOKEN\\\\n        // environment variables to be configured in wrangler.toml or via secrets.  The\\\\n        // route expects a POST request and will call the Cloudflare API to purge\\\\n        // everything for the configured zone.  This allows the admin UI to force\\\\n        // invalidation of stale static assets on demand.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/purge-cache\\\') {\\\\n          const zoneId = env.CF_ZONE_ID;\\\\n          const token = env.CF_API_TOKEN;\\\\n          if (!zoneId || !token) {\\\\n            return json({ error: \\\'CF_ZONE_ID or CF_API_TOKEN not configured\\\' }, 500);\\\\n          }\\\\n          try {\\\\n            const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\\\\n            const cfResp = await fetch(purgeUrl, {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${token}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify({ purge_everything: true })\\\\n            });\\\\n            const result = await cfResp.json();\\\\n            return json(result, cfResp.ok ? 200 : 500);\\\\n          } catch (e) {\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- PRODUCTS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text FROM products WHERE status = ? ORDER BY sort_order ASC, id DESC\\\'\\\\n          ).bind(\\\'active\\\').all();\\\\n          \\\\n          // Fetch review statistics for each product\\\\n          const products = r.results || [];\\\\n          const productsWithReviews = await Promise.all(products.map(async (product) => {\\\\n            const stats = await env.DB.prepare(\\\\n              \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n            ).bind(product.id, \\\'approved\\\').first();\\\\n            \\\\n            return {\\\\n              ...product,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 0\\\\n            };\\\\n          }));\\\\n          \\\\n          return json({ products: productsWithReviews });\\\\n        }\\\\n\\\\n        // ----- WHOP CHECKOUT -----\\\\n        // Create temporary Whop checkout session for a product\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/create-checkout\\\') {\\\\n          const body = await req.json();\\\\n          const { product_id } = body;\\\\n          \\\\n          if (!product_id) {\\\\n            return json({ error: \\\'Product ID required\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Get product details\\\\n          const product = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(product_id)).first();\\\\n          if (!product) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n\\\\n          // Get global Whop settings for fallback\\\\n          let globalSettings = {};\\\\n          try {\\\\n            const settingsRow = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n            if (settingsRow && settingsRow.value) {\\\\n              globalSettings = JSON.parse(settingsRow.value);\\\\n            }\\\\n          } catch (e) {\\\\n            console.error(\\\'Failed to load global settings:\\\', e);\\\\n          }\\\\n\\\\n          // Use product\\\'s whop_plan or fall back to global default\\\\n          let planId = product.whop_plan || globalSettings.default_plan_id || globalSettings.default_plan || \\\'\\\';\\\\n\\\\n          if (!planId) {\\\\n            return json({\\\\n              error: \\\'Whop not configured. Please set a plan for this product or configure a default plan in Settings.\\\'\\\\n            }, 400);\\\\n          }\\\\n\\\\n          // Extract Plan ID from link or use directly\\\\n          planId = planId.trim();\\\\n          \\\\n          // If it\\\'s a link, extract the plan ID\\\\n          if (planId.startsWith(\\\'http\\\')) {\\\\n            // Try to extract from various Whop URL formats\\\\n            // Format 1: https://whop.com/checkout/plan_xxxxx\\\\n            // Format 2: https://whop.com/product-name (contains plan in page)\\\\n            const planMatch = planId.match(/plan_[a-zA-Z0-9]+/);\\\\n            if (planMatch) {\\\\n              planId = planMatch[0];\\\\n            } else {\\\\n              // If no plan ID in URL, we need to fetch it (not ideal but works)\\\\n              // For now, show error - user should provide direct plan ID or proper link\\\\n              return json({ \\\\n                error: \\\'Could not extract Plan ID from link. Please use: https://whop.com/checkout/plan_XXXXX or just plan_XXXXX\\\' \\\\n              }, 400);\\\\n            }\\\\n          }\\\\n          \\\\n          // Validate Plan ID format\\\\n          if (!planId.startsWith(\\\'plan_\\\')) {\\\\n            return json({ error: \\\'Invalid Whop Plan ID format. Should start with plan_\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Get Whop API key from database or environment\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ error: \\\'Whop API key not configured. Please add it in admin Settings.\\\' }, 500);\\\\n          }\\\\n\\\\n          // Calculate expiry time (15 minutes from now)\\\\n          const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\\\\n\\\\n          // Create Whop checkout session\\\\n          try {\\\\n            const whopResponse = await fetch(\\\'https://api.whop.com/api/v2/checkout_sessions\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify({\\\\n                plan_id: planId,\\\\n                redirect_url: `${url.origin}/success.html?product=${product.id}`,\\\\n                metadata: {\\\\n                  product_id: product.id.toString(),\\\\n                  product_title: product.title,\\\\n                  created_at: new Date().toISOString(),\\\\n                  expires_at: expiryTime\\\\n                }\\\\n              })\\\\n            });\\\\n            \\\\n            if (!whopResponse.ok) {\\\\n              const errorText = await whopResponse.text();\\\\n              console.error(\\\'Whop API error:\\\', errorText);\\\\n              \\\\n              // Try to parse error message\\\\n              try {\\\\n                const errorData = JSON.parse(errorText);\\\\n                return json({ \\\\n                  error: errorData.message || errorData.error || \\\'Failed to create checkout\\\' \\\\n                }, whopResponse.status);\\\\n              } catch (e) {\\\\n                return json({ error: \\\'Failed to create checkout session\\\' }, whopResponse.status);\\\\n              }\\\\n            }\\\\n            \\\\n            const checkoutData = await whopResponse.json();\\\\n            \\\\n            // Store checkout for cleanup tracking (optional - for 15 min auto-delete)\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\\\\n                VALUES (?, ?, NULL, ?, \\\'pending\\\', datetime(\\\'now\\\'))\\\\n              `).bind(checkoutData.id, product.id, expiryTime).run();\\\\n            } catch (e) {\\\\n              // Table might not exist - that\\\'s okay, we\\\'ll still return the checkout\\\\n              console.log(\\\'Checkout tracking skipped:\\\', e.message);\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              checkout_id: checkoutData.id,\\\\n              checkout_url: checkoutData.purchase_url,\\\\n              expires_in: \\\'15 minutes\\\'\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Whop checkout error:\\\', e);\\\\n            return json({ error: e.message || \\\'Failed to create checkout\\\' }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- WHOP DYNAMIC PLAN + CHECKOUT -----\\\\n        // Create a temporary plan on Whop for the given product price and immediately\\\\n        // create a checkout session for that plan.  After payment, the webhook\\\\n        // handler will delete both the checkout session and the plan.  This can be\\\\n        // used when you need to charge custom one\\\\u2011time amounts per customer\\\\n        // without pre\\\\u2011creating plans in the Whop dashboard.  Requires\\\\n        // `plan:create` and `plan:delete` permissions on the API key as well as a\\\\n        // configured `WHOP_COMPANY_ID`.  Each product should store the\\\\n        // corresponding Whop `product_id` in the `whop_product_id` column.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/create-plan-checkout\\\') {\\\\n          const body = await req.json();\\\\n          const { product_id, amount, email, metadata } = body || {};\\\\n          if (!product_id) {\\\\n            return json({ error: \\\'Product ID required\\\' }, 400);\\\\n          }\\\\n          // Lookup product from database\\\\n          const product = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(product_id)).first();\\\\n          if (!product) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          // Determine the price to charge; prefer sale_price over normal_price\\\\n          const priceValue = (product.sale_price !== null && product.sale_price !== undefined && product.sale_price !== \\\'\\\')\\\\n            ? Number(product.sale_price)\\\\n            : Number(product.normal_price);\\\\n          // Allow $0 for testing, but reject negative prices\\\\n          if (isNaN(priceValue) || priceValue < 0) {\\\\n            return json({ error: \\\'Invalid price for product\\\' }, 400);\\\\n          }\\\\n          // Ensure we have the Whop product ID for attaching the plan to the correct product\\\\n          // Use the product\\\'s specific Whop product ID if available.\\\\n          const directProdId = (product.whop_product_id || \\\'\\\').trim();\\\\n          let finalProdId = directProdId;\\\\n          // If no product-specific ID, fallback to global default_product_id from settings\\\\n          if (!finalProdId) {\\\\n            try {\\\\n              const srow = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n              let settings = {};\\\\n              if (srow && srow.value) {\\\\n                try { settings = JSON.parse(srow.value); } catch (e) { settings = {}; }\\\\n              }\\\\n              if (settings && settings.default_product_id) {\\\\n                finalProdId = (settings.default_product_id || \\\'\\\').trim();\\\\n              }\\\\n            } catch (e) {\\\\n              console.log(\\\'Failed to load whop settings for default product ID:\\\', e);\\\\n            }\\\\n          }\\\\n          if (!finalProdId) {\\\\n            return json({ error: \\\'whop_product_id not configured for this product and no default_product_id set\\\' }, 400);\\\\n          }\\\\n          // Company ID must be provided via environment variables\\\\n          const companyId = env.WHOP_COMPANY_ID;\\\\n          if (!companyId) {\\\\n            return json({ error: \\\'WHOP_COMPANY_ID environment variable not set\\\' }, 500);\\\\n          }\\\\n          // Get API key from database or environment\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ error: \\\'Whop API key not configured. Please add it in admin Settings.\\\' }, 500);\\\\n          }\\\\n          // Derive currency from environment or fallback to USD\\\\n          const currency = env.WHOP_CURRENCY || \\\'usd\\\';\\\\n          // Prepare plan creation request for one-time payment (no renewal)\\\\n          // For one_time plans, we should NOT set renewal_price\\\\n          const planBody = {\\\\n            company_id: companyId,\\\\n            product_id: finalProdId,\\\\n            plan_type: \\\'one_time\\\',\\\\n            release_method: \\\'buy_now\\\',\\\\n            currency: currency,\\\\n            initial_price: priceValue,\\\\n            // Do NOT set renewal_price for one_time plans - it causes error\\\\n            // Provide a default title for the plan so the seller can see it in their dashboard\\\\n            title: `${product.title || \\\'One\\\\u2011time purchase\\\'} - $${priceValue}`,\\\\n            // Set unlimited stock to prevent \\\\"out of stock\\\\" errors\\\\n            stock: 999999,\\\\n            internal_notes: `Auto-generated for product ${product.id} - ${new Date().toISOString()}`\\\\n          };\\\\n          try {\\\\n            // Create the plan on Whop\\\\n            const planResp = await fetch(\\\'https://api.whop.com/api/v2/plans\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify(planBody)\\\\n            });\\\\n            if (!planResp.ok) {\\\\n              const errorText = await planResp.text();\\\\n              console.error(\\\'Whop plan create error:\\\', errorText);\\\\n              let msg = \\\'Failed to create plan\\\';\\\\n              try {\\\\n                const j = JSON.parse(errorText);\\\\n                msg = j.message || j.error || msg;\\\\n              } catch (_) {}\\\\n              return json({ error: msg }, planResp.status);\\\\n            }\\\\n            const planData = await planResp.json();\\\\n            const planId = planData.id;\\\\n            if (!planId) {\\\\n              return json({ error: \\\'Plan ID missing from Whop response\\\' }, 500);\\\\n            }\\\\n            // Compute expiry time (15 mins) for cleanup\\\\n            const expiryTime = new Date(Date.now() + 15 * 60 * 1000).toISOString();\\\\n\\\\n            // Store plan for cleanup, no checkout session needed for embedded flow\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                INSERT INTO checkout_sessions (checkout_id, product_id, plan_id, expires_at, status, created_at)\\\\n                VALUES (?, ?, ?, ?, \\\'pending\\\', datetime(\\\'now\\\'))\\\\n              `).bind(\\\'plan_\\\' + planId, product.id, planId, expiryTime).run();\\\\n            } catch (e) {\\\\n              console.log(\\\'Plan tracking insert failed:\\\', e.message);\\\\n            }\\\\n\\\\n            // Create checkout session with email prefill for better UX\\\\n            const checkoutBody = {\\\\n              plan_id: planId,\\\\n              redirect_url: `${url.origin}/success.html?product=${product.id}`,\\\\n              metadata: {\\\\n                product_id: product.id.toString(),\\\\n                product_title: product.title,\\\\n                addons: metadata?.addons || [],\\\\n                amount: amount || priceValue,\\\\n                created_at: new Date().toISOString()\\\\n              }\\\\n            };\\\\n\\\\n            // Add email prefill if provided\\\\n            if (email && email.includes(\\\'@\\\')) {\\\\n              checkoutBody.prefill = {\\\\n                email: email.trim()\\\\n              };\\\\n            }\\\\n\\\\n            const checkoutResp = await fetch(\\\'https://api.whop.com/api/v2/checkout_sessions\\\', {\\\\n              method: \\\'POST\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              },\\\\n              body: JSON.stringify(checkoutBody)\\\\n            });\\\\n\\\\n            if (!checkoutResp.ok) {\\\\n              const errorText = await checkoutResp.text();\\\\n              console.error(\\\'Whop checkout session error:\\\', errorText);\\\\n              // If checkout session fails, still return plan ID for fallback\\\\n              return json({\\\\n                success: true,\\\\n                plan_id: planId,\\\\n                product_id: product.id,\\\\n                email: email,\\\\n                metadata: {\\\\n                  product_id: product.id.toString(),\\\\n                  product_title: product.title,\\\\n                  addons: metadata?.addons || [],\\\\n                  amount: amount || priceValue\\\\n                },\\\\n                expires_in: \\\'15 minutes\\\',\\\\n                warning: \\\'Email prefill not available\\\'\\\\n              });\\\\n            }\\\\n\\\\n            const checkoutData = await checkoutResp.json();\\\\n\\\\n            // Update database record with checkout session ID\\\\n            try {\\\\n              await env.DB.prepare(`\\\\n                UPDATE checkout_sessions \\\\n                SET checkout_id = ?\\\\n                WHERE checkout_id = ?\\\\n              `).bind(checkoutData.id, \\\'plan_\\\' + planId).run();\\\\n            } catch (e) {\\\\n              console.log(\\\'Checkout session tracking update failed:\\\', e.message);\\\\n            }\\\\n\\\\n            // Return both plan ID and checkout URL with email prefill\\\\n            return json({\\\\n              success: true,\\\\n              plan_id: planId,\\\\n              checkout_id: checkoutData.id,\\\\n              checkout_url: checkoutData.purchase_url,\\\\n              product_id: product.id,\\\\n              email: email,\\\\n              metadata: {\\\\n                product_id: product.id.toString(),\\\\n                product_title: product.title,\\\\n                addons: metadata?.addons || [],\\\\n                amount: amount || priceValue\\\\n              },\\\\n              expires_in: \\\'15 minutes\\\',\\\\n              email_prefilled: !!(email && email.includes(\\\'@\\\'))\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Dynamic checkout error:\\\', e);\\\\n            return json({ error: e.message || \\\'Failed to create plan/checkout\\\' }, 500);\\\\n          }\\\\n        }\\\\n        \\\\n        // ----- WHOP WEBHOOK -----\\\\n        // Handle Whop payment webhooks\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/webhook\\\') {\\\\n          try {\\\\n            const webhookData = await req.json();\\\\n            const eventType = webhookData.type;\\\\n            \\\\n            console.log(\\\'Whop webhook received:\\\', eventType);\\\\n            \\\\n            // Handle payment success\\\\n            if (eventType === \\\'payment.succeeded\\\') {\\\\n              const checkoutSessionId = webhookData.data?.checkout_session_id;\\\\n              const membershipId = webhookData.data?.id;\\\\n              const metadata = webhookData.data?.metadata || {};\\\\n              \\\\n              console.log(\\\'Payment succeeded:\\\', {\\\\n                checkoutSessionId,\\\\n                membershipId,\\\\n                metadata\\\\n              });\\\\n              \\\\n              // Mark checkout as completed in database\\\\n              if (checkoutSessionId) {\\\\n                try {\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'completed\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkoutSessionId).run();\\\\n                } catch (e) {\\\\n                  console.log(\\\'Checkout tracking update skipped:\\\', e.message);\\\\n                }\\\\n              }\\\\n              \\\\n              // Delete the temporary checkout session from Whop\\\\n              if (checkoutSessionId && env.WHOP_API_KEY) {\\\\n                try {\\\\n                  await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkoutSessionId}`, {\\\\n                    method: \\\'DELETE\\\',\\\\n                    headers: {\\\\n                      \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}`\\\\n                    }\\\\n                  });\\\\n                  console.log(\\\'\\\\u2705 Checkout session deleted immediately after payment:\\\', checkoutSessionId);\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to delete checkout session:\\\', e);\\\\n                }\\\\n              }\\\\n              // If we created a dynamic plan for this checkout, delete the plan as well\\\\n              if (checkoutSessionId && env.WHOP_API_KEY) {\\\\n                try {\\\\n                  // Fetch plan_id from checkout_sessions table\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkoutSessionId).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Plan deleted immediately after payment:\\\', planId);\\\\n                  }\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to delete plan:\\\', e);\\\\n                }\\\\n              }\\\\n              \\\\n              // Create order in database (optional - for tracking)\\\\n              if (metadata.product_id) {\\\\n                try {\\\\n                  const orderId = `WHOP-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\\\n                  await env.DB.prepare(\\\\n                    \\\'INSERT INTO orders (order_id, product_id, status, created_at) VALUES (?, ?, ?, datetime(\\\\"now\\\\"))\\\'\\\\n                  ).bind(orderId, Number(metadata.product_id), \\\'completed\\\').run();\\\\n                  \\\\n                  console.log(\\\'Order created:\\\', orderId);\\\\n                } catch (e) {\\\\n                  console.error(\\\'Failed to create order:\\\', e);\\\\n                }\\\\n              }\\\\n            }\\\\n            \\\\n            // Handle membership validation\\\\n            if (eventType === \\\'membership.went_valid\\\') {\\\\n              console.log(\\\'Membership validated:\\\', webhookData.data?.id);\\\\n            }\\\\n            \\\\n            // Always return 200 to acknowledge webhook\\\\n            return json({ received: true });\\\\n          } catch (e) {\\\\n            console.error(\\\'Webhook error:\\\', e);\\\\n            return json({ error: \\\'Webhook processing failed\\\' }, 500);\\\\n          }\\\\n        }\\\\n        // ----- WHOP TEST API -----\\\\n        // Simple endpoint to verify Whop API connectivity and permissions.  This\\\\n        // GET call attempts to fetch the current company details using\\\\n        // WHOP_COMPANY_ID and WHOP_API_KEY.  A successful response means the\\\\n        // API key is valid and has at least `company:basic:read` permissions.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-api\\\') {\\\\n          const apiKey = await getWhopApiKey(env);\\\\n          if (!apiKey) {\\\\n            return json({ success: false, error: \\\'Whop API key not configured. Please add it in Settings.\\\' }, 500);\\\\n          }\\\\n          try {\\\\n            // Test API key by listing plans - this endpoint works with basic plan permissions\\\\n            // and doesn\\\'t require company ID or special permissions\\\\n            const resp = await fetch(\\\'https://api.whop.com/api/v2/plans?page=1&per=1\\\', {\\\\n              method: \\\'GET\\\',\\\\n              headers: {\\\\n                \\\'Authorization\\\': `Bearer ${apiKey}`,\\\\n                \\\'Content-Type\\\': \\\'application/json\\\'\\\\n              }\\\\n            });\\\\n\\\\n            // Return detailed error info for debugging\\\\n            if (!resp.ok) {\\\\n              const text = await resp.text();\\\\n              let errMsg = \\\'Whop API call failed\\\';\\\\n              let errorDetails = null;\\\\n              try {\\\\n                errorDetails = JSON.parse(text);\\\\n                errMsg = errorDetails.message || errorDetails.error || errMsg;\\\\n              } catch (_) {\\\\n                errMsg = text || errMsg;\\\\n              }\\\\n              return json({\\\\n                success: false,\\\\n                error: errMsg,\\\\n                status: resp.status,\\\\n                details: errorDetails,\\\\n                debug: {\\\\n                  apiKeyLength: apiKey?.length || 0,\\\\n                  apiKeyPrefix: apiKey?.substring(0, 10) + \\\'...\\\'\\\\n                }\\\\n              }, resp.status);\\\\n            }\\\\n\\\\n            const data = await resp.json();\\\\n            return json({\\\\n              success: true,\\\\n              message: \\\'API connection successful!\\\',\\\\n              plansCount: data.data?.length || 0,\\\\n              apiKeyValid: true\\\\n            });\\\\n          } catch (e) {\\\\n            return json({ success: false, error: e.message || \\\'API test error\\\' }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- WHOP TEST WEBHOOK -----\\\\n        // Endpoint to verify that the webhook endpoint is reachable.  This\\\\n        // simply returns a success object.  It does not call the external\\\\n        // Whop service.  Use this to check that your domain and Cloudflare\\\\n        // routing are configured correctly.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-webhook\\\') {\\\\n          return json({ success: true, message: \\\'Webhook endpoint reachable\\\' });\\\\n        }\\\\n        \\\\n        // ----- CLEANUP EXPIRED CHECKOUTS -----\\\\n        // Endpoint to cleanup expired checkout sessions (call this from a cron job)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/cleanup\\\') {\\\\n          if (!env.WHOP_API_KEY) {\\\\n            return json({ error: \\\'Whop API key not configured\\\' }, 500);\\\\n          }\\\\n          \\\\n          try {\\\\n            // Get expired checkouts from database\\\\n            const expiredCheckouts = await env.DB.prepare(`\\\\n              SELECT checkout_id, product_id, expires_at\\\\n              FROM checkout_sessions\\\\n              WHERE status = \\\'pending\\\' \\\\n              AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n              ORDER BY created_at ASC\\\\n              LIMIT 50\\\\n            `).all();\\\\n            \\\\n            let deleted = 0;\\\\n            let failed = 0;\\\\n            \\\\n            for (const checkout of (expiredCheckouts.results || [])) {\\\\n              try {\\\\n                // Delete the checkout session from Whop (ignore if already gone)\\\\n                const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n                  method: \\\'DELETE\\\',\\\\n                  headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                });\\\\n                // Attempt to delete the associated plan if one exists\\\\n                let planDeleted = false;\\\\n                try {\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkout.checkout_id).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    planDeleted = delPlanResp.ok || delPlanResp.status === 404;\\\\n                  }\\\\n                } catch (pe) {\\\\n                  console.error(\\\'Plan deletion error:\\\', pe);\\\\n                }\\\\n                if (deleteSessionResp.ok || deleteSessionResp.status === 404) {\\\\n                  // Mark as expired in database regardless of plan deletion outcome\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkout.checkout_id).run();\\\\n                  deleted++;\\\\n                  console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id, planDeleted ? \\\'and plan cleaned up\\\' : \\\'\\\');\\\\n                } else {\\\\n                  failed++;\\\\n                }\\\\n              } catch (e) {\\\\n                failed++;\\\\n                console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, e);\\\\n              }\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              deleted: deleted,\\\\n              failed: failed,\\\\n              message: `Cleaned up ${deleted} expired checkouts`\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Cleanup error:\\\', e);\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/product/\\\')) {\\\\n          const id = path.split(\\\'/\\\').pop();\\\\n          let row;\\\\n          if (isNaN(Number(id))) {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE slug = ?\\\').bind(id).first();\\\\n          } else {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          }\\\\n          if (!row) return json({ error: \\\'Product not found\\\' }, 404);\\\\n          \\\\n          let addons = [];\\\\n          try {\\\\n            addons = JSON.parse(row.addons_json || \\\'[]\\\');\\\\n          } catch(e) {\\\\n            console.error(\\\'Failed to parse addons_json for product\\\', row.id, \\\':\\\', e.message);\\\\n          }\\\\n          \\\\n          const stats = await env.DB.prepare(\\\\n            \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n          ).bind(row.id, \\\'approved\\\').first();\\\\n          \\\\n          // Fetch reviews for rich results schema (directly use review\\\'s own video URLs)\\\\n          const reviewsResult = await env.DB.prepare(\\\\n            `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n             FROM reviews \\\\n             LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n             WHERE reviews.product_id = ? AND reviews.status = ? \\\\n             ORDER BY reviews.created_at DESC`\\\\n          ).bind(row.id, \\\'approved\\\').all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (reviewsResult.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            if (review.updated_at && typeof review.updated_at === \\\'string\\\') {\\\\n              review.updated_at = review.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n          \\\\n          return json({\\\\n            product: {\\\\n              ...row,\\\\n              addons,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,\\\\n              reviews: reviews\\\\n            },\\\\n            addons\\\\n          });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/product/save\\\') {\\\\n          const body = await req.json();\\\\n          const title = (body.title || \\\'\\\').trim();\\\\n          if (!title) return json({ error: \\\'Title required\\\' }, 400);\\\\n          \\\\n          const slug = (body.slug || \\\'\\\').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const addonsJson = JSON.stringify(body.addons || []);\\\\n          \\\\n          if (body.id) {\\\\n            // Prepare gallery_images as JSON string if it\\\'s an array\\\\n            const galleryJson = Array.isArray(body.gallery_images) \\\\n              ? JSON.stringify(body.gallery_images) \\\\n              : (body.gallery_images || \\\'[]\\\');\\\\n            \\\\n            await env.DB.prepare(`\\\\n              UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\\\\n              instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\\\\n              gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\\\\n              whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?\\\\n            `).bind(\\\\n              title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n              body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n              body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n              body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n              body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\', Number(body.id)\\\\n            ).run();\\\\n            return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });\\\\n          }\\\\n          \\\\n          // Prepare gallery_images as JSON string if it\\\'s an array\\\\n          const galleryJson = Array.isArray(body.gallery_images) \\\\n            ? JSON.stringify(body.gallery_images) \\\\n            : (body.gallery_images || \\\'[]\\\');\\\\n          \\\\n          const r = await env.DB.prepare(`\\\\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\\\\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\\\\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \\\'active\\\', 0)\\\\n          `).bind(\\\\n            title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n            body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n            body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n            body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n            body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\'\\\\n          ).run();\\\\n          const newId = r.meta?.last_row_id;\\\\n          return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/product/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          if (!id) return json({ error: \\\'ID required\\\' }, 400);\\\\n          await env.DB.prepare(\\\'DELETE FROM products WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS LIST (admin) -----\\\\n        // Return all products regardless of status.  Used by the admin UI to\\\\n        // manage published and draft products.  Includes the status column to\\\\n        // drive publish/unpublish toggles.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products/list\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          return json({ products: r.results || [] });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS STATUS UPDATE -----\\\\n        // Update the status of a product (active for published, draft for draft).\\\\n        // Accepts JSON with `id` and `status`.  Status must be \\\'active\\\' or \\\'draft\\\'.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!id || !status) {\\\\n            return json({ error: \\\'id and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'active\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE products SET status = ? WHERE id = ?\\\').bind(status, Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS DUPLICATE -----\\\\n        // Duplicate an existing product.  Accepts JSON with `id`.  Copies\\\\n        // all fields and inserts a new product with slug suffixed by \\\'-copy\\\'\\\\n        // and status set to \\\'draft\\\'.  Ensures slug uniqueness by adding\\\\n        // numerical suffixes when needed.  Returns the new product id and slug.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          if (!id) {\\\\n            return json({ error: \\\'id required\\\' }, 400);\\\\n          }\\\\n          const row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Determine unique new slug\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          // Copy all relevant fields into a new product row\\\\n          const r = await env.DB.prepare(\\\\n            `INSERT INTO products (\\\\n              title, slug, description, normal_price, sale_price,\\\\n              instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n              addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n              whop_plan, whop_price_map, status, sort_order\\\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\\\\n          ).bind(\\\\n            (row.title || \\\'\\\') + \\\' Copy\\\',\\\\n            newSlug,\\\\n            row.description || \\\'\\\',\\\\n            row.normal_price || 0,\\\\n            row.sale_price || null,\\\\n            row.instant_delivery || 0,\\\\n            row.normal_delivery_text || \\\'\\\',\\\\n            row.thumbnail_url || \\\'\\\',\\\\n            row.video_url || \\\'\\\',\\\\n            row.addons_json || \\\'[]\\\',\\\\n            row.seo_title || \\\'\\\',\\\\n            row.seo_description || \\\'\\\',\\\\n            row.seo_keywords || \\\'\\\',\\\\n            row.seo_canonical || \\\'\\\',\\\\n            row.whop_plan || \\\'\\\',\\\\n            row.whop_price_map || \\\'\\\',\\\\n            \\\'draft\\\',\\\\n            0\\\\n          ).run();\\\\n          return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- ORDERS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/orders\\\') {\\\\n          const r = await env.DB.prepare(\\\'SELECT * FROM orders ORDER BY id DESC\\\').all();\\\\n          const orders = (r.results || []).map(row => {\\\\n            let email = \\\'\\\', amount = null, addons = [];\\\\n            try {\\\\n              if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n                const d = JSON.parse(row.encrypted_data);\\\\n                email = d.email || \\\'\\\';\\\\n                amount = d.amount;\\\\n                addons = d.addons || [];\\\\n              }\\\\n            } catch(e) {\\\\n              console.error(\\\'Failed to parse order encrypted_data for order:\\\', row.order_id, e.message);\\\\n            }\\\\n            return { ...row, email, amount, addons };\\\\n          });\\\\n          return json({ orders });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && (path === \\\'/api/order/create\\\' || path === \\\'/submit-order\\\')) {\\\\n          const body = await req.json();\\\\n          if (!body.productId) return json({ error: \\\'productId required\\\' }, 400);\\\\n          \\\\n          const orderId = body.orderId || crypto.randomUUID().split(\\\'-\\\')[0].toUpperCase();\\\\n          const data = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount,\\\\n            productId: body.productId,\\\\n            addons: body.addons || []\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(orderId, Number(body.productId), data, \\\'PAID\\\', Number(body.delive",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}