{'role': 'assistant', 'content': '\nNow let me create the chat controller in `src/controllers/chat.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/chat.js">\n// Chat API controller\nimport { json } from \'../utils/response.js\';\nimport { escapeHtml, enforceUserRateLimit, normalizeQuickAction, getLatestOrderForEmail, getGoogleScriptUrl } from \'../utils/helpers.js\';\n\n/**\n * Start a new chat session\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function startChat(env, body) {\n  const nameIn = String(body.name || \'\').trim();\n  const emailIn = String(body.email || \'\').trim();\n\n  if (!nameIn || !emailIn) return json({ error: \'Name and email are required\' }, 400);\n\n  // Basic normalization\n  const email = emailIn.toLowerCase();\n  const name = nameIn;\n\n  // One email = one session (reuse + cleanup)\n  const canonical = await env.DB.prepare(\n    `SELECT id, name, created_at\n     FROM chat_sessions\n     WHERE lower(email) = lower(?)\n     ORDER BY datetime(created_at) ASC\n     LIMIT 1`\n  ).bind(email).first();\n\n  if (canonical?.id) {\n    const canonicalId = String(canonical.id);\n\n    // Update name if it changed (optional but keeps admin tidy)\n    if (name && canonical.name !== name) {\n      await env.DB.prepare(\n        `UPDATE chat_sessions SET name = ? WHERE id = ?`\n      ).bind(name, canonicalId).run();\n    }\n\n    // Migrate any stray sessions/messages for this email into the canonical session\n    const others = await env.DB.prepare(\n      `SELECT id FROM chat_sessions\n       WHERE lower(email) = lower(?) AND id != ?`\n    ).bind(email, canonicalId).all();\n\n    const otherIds = (others?.results || []).map(r => String(r.id));\n    for (const sid of otherIds) {\n      await env.DB.prepare(\n        `UPDATE chat_messages SET session_id = ? WHERE session_id = ?`\n      ).bind(canonicalId, sid).run();\n\n      await env.DB.prepare(\n        `DELETE FROM chat_sessions WHERE id = ?`\n      ).bind(sid).run();\n    }\n\n    return json({ sessionId: canonicalId, reused: true });\n  }\n\n  // Create new session\n  const sessionId = crypto.randomUUID();\n\n  await env.DB.prepare(\n    `INSERT INTO chat_sessions (id, name, email) VALUES (?, ?, ?)`\n  ).bind(sessionId, escapeHtml(name), escapeHtml(email)).run();\n\n  return json({ sessionId, reused: false });\n}\n\n/**\n * Sync chat messages\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function syncChat(env, url) {\n  const sessionId = url.searchParams.get(\'sessionId\');\n  const sinceIdRaw = url.searchParams.get(\'sinceId\') || \'0\';\n  const sinceId = Number(sinceIdRaw) || 0;\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  const rows = await env.DB.prepare(\n    `SELECT id, role, content, created_at\n     FROM chat_messages\n     WHERE session_id = ? AND id > ?\n     ORDER BY id ASC\n     LIMIT 100`\n  ).bind(sessionId, sinceId).all();\n\n  const messages = rows?.results || [];\n  const lastId = messages.length ? messages[messages.length - 1].id : sinceId;\n\n  return json({ messages, lastId });\n}\n\n/**\n * Send a chat message\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function sendChat(env, req, body) {\n  const sessionId = String(body.sessionId || \'\').trim();\n  const roleRaw = String(body.role || \'user\').trim().toLowerCase();\n\n  // accept content or message\n  const rawContent = String(body.content ?? body.message ?? \'\');\n\n  const role = [\'user\', \'admin\', \'system\'].includes(roleRaw) ? roleRaw : \'user\';\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  // Strict blocking: do not allow blocked sessions to send customer messages\n  const sess = await env.DB.prepare(\n    `SELECT blocked FROM chat_sessions WHERE id = ?`\n  ).bind(sessionId).first();\n\n  if (role === \'user\' && Number(sess?.blocked || 0) === 1) {\n    return json({ success: false, error: "You have been blocked by support." }, 403);\n  }\n\n  const trimmed = rawContent.trim();\n  if (!trimmed) return json({ error: \'content is required\' }, 400);\n\n  // 500 char limit (backend)\n  if (trimmed.length > 500) return json({ error: \'Message too long (max 500 characters)\' }, 400);\n\n  // Rate limit customers only (1 msg/sec)\n  try {\n    if (role === \'user\') await enforceUserRateLimit(env, sessionId);\n  } catch (e) {\n    if (e?.status === 429) return json({ error: \'Too many messages. Please wait a moment.\' }, 429);\n    throw e;\n  }\n\n  // Determine if this is the user\'s first message BEFORE inserting\n  let isFirstUserMessage = false;\n  if (role === \'user\') {\n    const countRow = await env.DB.prepare(\n      `SELECT COUNT(*) as c\n       FROM chat_messages\n       WHERE session_id = ? AND role = \'user\'`\n    ).bind(sessionId).first();\n    isFirstUserMessage = Number(countRow?.c || 0) === 0;\n  }\n\n  // XSS protection: escape before storing\n  const safeContent = escapeHtml(trimmed);\n\n  const insertRes = await env.DB.prepare(\n    `INSERT INTO chat_messages (session_id, role, content) VALUES (?, ?, ?)`\n  ).bind(sessionId, role, safeContent).run();\n\n  // Update denormalized last-message fields for fast admin listing\n  try {\n    await env.DB.prepare(\n      `UPDATE chat_sessions\n       SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n       WHERE id = ?`\n    ).bind(safeContent, sessionId).run();\n  } catch (e) {\n    console.error(\'Failed to update chat_sessions last-message fields:\', e);\n  }\n\n  // Trigger email alert webhook on first customer message\n  if (isFirstUserMessage) {\n    try {\n      const setting = await env.DB.prepare(\n        `SELECT value FROM settings WHERE key = ?`\n      ).bind(\'GOOGLE_SCRIPT_URL\').first();\n\n      const scriptUrl = String(setting?.value || \'\').trim();\n\n      if (scriptUrl) {\n        const session = await env.DB.prepare(\n          `SELECT id, name, email, created_at FROM chat_sessions WHERE id = ?`\n        ).bind(sessionId).first();\n\n        await fetch(scriptUrl, {\n          method: \'POST\',\n          headers: { \'Content-Type\': \'application/json\' },\n          body: JSON.stringify({\n            event: \'first_customer_message\',\n            sessionId,\n            name: session?.name || null,\n            email: session?.email || null,\n            created_at: session?.created_at || null,\n            message: trimmed\n          })\n        });\n      }\n    } catch (e) {\n      console.error(\'Chat webhook trigger failed:\', e);\n    }\n  }\n\n  // ------------------------------\n  // Smart Quick Action Auto-Replies\n  // ------------------------------\n  if (role === \'user\') {\n    const normalized = normalizeQuickAction(trimmed);\n    const session = await env.DB.prepare(\n      `SELECT email FROM chat_sessions WHERE id = ?`\n    ).bind(sessionId).first();\n\n    const email = String(session?.email || \'\').trim();\n    const origin = new URL(req.url).origin;\n\n    // "My Order Status"\n    if (normalized === \'my order status\') {\n      let replyText = "We couldn\'t find any recent orders for this email.";\n\n      if (email) {\n        const lastOrder = await getLatestOrderForEmail(env, email);\n        if (lastOrder) {\n          const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\n          replyText = `Your last order #${lastOrder.order_id} is currently ${lastOrder.status || \'unknown\'}. Track it here: ${link}`;\n        }\n      }\n\n      const safeReply = escapeHtml(replyText);\n      await env.DB.prepare(\n        `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \'system\', ?)`\n      ).bind(sessionId, safeReply).run();\n\n      // Update denormalized last-message fields\n      try {\n        await env.DB.prepare(\n          `UPDATE chat_sessions\n           SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n           WHERE id = ?`\n        ).bind(safeReply, sessionId).run();\n      } catch (e) {\n        console.error(\'Failed to update chat_sessions last-message fields:\', e);\n      }\n    }\n\n    // "Check Delivery Status"\n    if (normalized === \'check delivery status\') {\n      let replyText = "No recent orders found for this email.";\n\n      if (email) {\n        const lastOrder = await getLatestOrderForEmail(env, email);\n        if (lastOrder) {\n          const link = `${origin}/buyer-order.html?id=${encodeURIComponent(lastOrder.order_id)}`;\n          replyText = `Your last order is ${lastOrder.status || \'unknown\'}. View details here: ${link}`;\n        }\n      }\n\n      const safeReply = escapeHtml(replyText);\n      await env.DB.prepare(\n        `INSERT INTO chat_messages (session_id, role, content) VALUES (?, \'system\', ?)`\n      ).bind(sessionId, safeReply).run();\n\n      // Update denormalized last-message fields\n      try {\n        await env.DB.prepare(\n          `UPDATE chat_sessions\n           SET last_message_content = ?, last_message_at = CURRENT_TIMESTAMP\n           WHERE id = ?`\n        ).bind(safeReply, sessionId).run();\n      } catch (e) {\n        console.error(\'Failed to update chat_sessions last-message fields:\', e);\n      }\n    }\n  }\n\n  return json({ success: true, messageId: insertRes?.meta?.last_row_id || null });\n}\n\n/**\n * Get all chat sessions for admin\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getChatSessions(env) {\n  // One row per email (canonical session = oldest created_at for that email)\n  // Denormalized fields on chat_sessions let us avoid heavy subqueries.\n  const rows = await env.DB.prepare(\n    `SELECT\n       s.id,\n       s.name,\n       s.email,\n       s.blocked,\n       s.last_message_at,\n       s.last_message_content AS last_message,\n       s.created_at\n     FROM chat_sessions s\n     JOIN (\n       SELECT lower(email) AS em, MIN(datetime(created_at)) AS min_created\n       FROM chat_sessions\n       GROUP BY lower(email)\n     ) x\n       ON lower(s.email) = x.em AND datetime(s.created_at) = x.min_created\n     ORDER BY COALESCE(s.last_message_at, s.created_at) DESC\n     LIMIT 200`\n  ).all();\n\n  return json({ sessions: rows?.results || [] });\n}\n\n/**\n * Block/unblock a chat session\n * @param {Object} env - Environment bindings\n * @param {Object} body - Request body\n * @returns {Promise<Response>}\n */\nexport async function blockChatSession(env, body) {\n  const sessionId = String(body.sessionId || \'\').trim();\n  const blocked = body.blocked === true || body.blocked === 1 || body.blocked === \'true\';\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  await env.DB.prepare(\n    `UPDATE chat_sessions SET blocked = ? WHERE id = ?`\n  ).bind(blocked ? 1 : 0, sessionId).run();\n\n  return json({ success: true, blocked: blocked ? 1 : 0 });\n}\n\n/**\n * Delete a chat session and its messages\n * @param {Object} env - Environment bindings\n * @param {string} sessionId - Session ID (from query or body)\n * @param {Object} body - Optional request body\n * @returns {Promise<Response>}\n */\nexport async function deleteChatSession(env, sessionId, body = {}) {\n  if (!sessionId) {\n    sessionId = String(body.sessionId || \'\').trim();\n  }\n\n  if (!sessionId) return json({ error: \'sessionId is required\' }, 400);\n\n  // Delete messages first, then session\n  await env.DB.prepare(`DELETE FROM chat_messages WHERE session_id = ?`).bind(sessionId).run();\n  await env.DB.prepare(`DELETE FROM chat_sessions WHERE id = ?`).bind(sessionId).run();\n\n  return json({ success: true });\n}\n</create-file>\n</function_calls>'}