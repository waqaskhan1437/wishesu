{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "          }\\\\n        }\\\\n\\\\n        // ----- WHOP TEST WEBHOOK -----\\\\n        // Endpoint to verify that the webhook endpoint is reachable.  This\\\\n        // simply returns a success object.  It does not call the external\\\\n        // Whop service.  Use this to check that your domain and Cloudflare\\\\n        // routing are configured correctly.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/whop/test-webhook\\\') {\\\\n          return json({ success: true, message: \\\'Webhook endpoint reachable\\\' });\\\\n        }\\\\n        \\\\n        // ----- CLEANUP EXPIRED CHECKOUTS -----\\\\n        // Endpoint to cleanup expired checkout sessions (call this from a cron job)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/cleanup\\\') {\\\\n          if (!env.WHOP_API_KEY) {\\\\n            return json({ error: \\\'Whop API key not configured\\\' }, 500);\\\\n          }\\\\n          \\\\n          try {\\\\n            // Get expired checkouts from database\\\\n            const expiredCheckouts = await env.DB.prepare(`\\\\n              SELECT checkout_id, product_id, expires_at\\\\n              FROM checkout_sessions\\\\n              WHERE status = \\\'pending\\\' \\\\n              AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n              ORDER BY created_at ASC\\\\n              LIMIT 50\\\\n            `).all();\\\\n            \\\\n            let deleted = 0;\\\\n            let failed = 0;\\\\n            \\\\n            for (const checkout of (expiredCheckouts.results || [])) {\\\\n              try {\\\\n                // Delete the checkout session from Whop (ignore if already gone)\\\\n                const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n                  method: \\\'DELETE\\\',\\\\n                  headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                });\\\\n                // Attempt to delete the associated plan if one exists\\\\n                let planDeleted = false;\\\\n                try {\\\\n                  const row = await env.DB.prepare(\\\'SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?\\\').bind(checkout.checkout_id).first();\\\\n                  const planId = row && row.plan_id;\\\\n                  if (planId) {\\\\n                    const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {\\\\n                      method: \\\'DELETE\\\',\\\\n                      headers: { \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}` }\\\\n                    });\\\\n                    planDeleted = delPlanResp.ok || delPlanResp.status === 404;\\\\n                  }\\\\n                } catch (pe) {\\\\n                  console.error(\\\'Plan deletion error:\\\', pe);\\\\n                }\\\\n                if (deleteSessionResp.ok || deleteSessionResp.status === 404) {\\\\n                  // Mark as expired in database regardless of plan deletion outcome\\\\n                  await env.DB.prepare(`\\\\n                    UPDATE checkout_sessions \\\\n                    SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n                    WHERE checkout_id = ?\\\\n                  `).bind(checkout.checkout_id).run();\\\\n                  deleted++;\\\\n                  console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id, planDeleted ? \\\'and plan cleaned up\\\' : \\\'\\\');\\\\n                } else {\\\\n                  failed++;\\\\n                }\\\\n              } catch (e) {\\\\n                failed++;\\\\n                console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, e);\\\\n              }\\\\n            }\\\\n            \\\\n            return json({\\\\n              success: true,\\\\n              deleted: deleted,\\\\n              failed: failed,\\\\n              message: `Cleaned up ${deleted} expired checkouts`\\\\n            });\\\\n          } catch (e) {\\\\n            console.error(\\\'Cleanup error:\\\', e);\\\\n            return json({ error: e.message }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/product/\\\')) {\\\\n          const id = path.split(\\\'/\\\').pop();\\\\n          let row;\\\\n          if (isNaN(Number(id))) {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE slug = ?\\\').bind(id).first();\\\\n          } else {\\\\n            row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          }\\\\n          if (!row) return json({ error: \\\'Product not found\\\' }, 404);\\\\n          \\\\n          let addons = [];\\\\n          try {\\\\n            addons = JSON.parse(row.addons_json || \\\'[]\\\');\\\\n          } catch(e) {\\\\n            console.error(\\\'Failed to parse addons_json for product\\\', row.id, \\\':\\\', e.message);\\\\n          }\\\\n          \\\\n          const stats = await env.DB.prepare(\\\\n            \\\'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?\\\'\\\\n          ).bind(row.id, \\\'approved\\\').first();\\\\n          \\\\n          // Fetch reviews for rich results schema (directly use review\\\'s own video URLs)\\\\n          const reviewsResult = await env.DB.prepare(\\\\n            `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n             FROM reviews \\\\n             LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n             WHERE reviews.product_id = ? AND reviews.status = ? \\\\n             ORDER BY reviews.created_at DESC`\\\\n          ).bind(row.id, \\\'approved\\\').all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (reviewsResult.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            if (review.updated_at && typeof review.updated_at === \\\'string\\\') {\\\\n              review.updated_at = review.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n          \\\\n          return json({\\\\n            product: {\\\\n              ...row,\\\\n              addons,\\\\n              review_count: stats?.cnt || 0,\\\\n              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,\\\\n              reviews: reviews\\\\n            },\\\\n            addons\\\\n          });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/product/save\\\') {\\\\n          const body = await req.json();\\\\n          const title = (body.title || \\\'\\\').trim();\\\\n          if (!title) return json({ error: \\\'Title required\\\' }, 400);\\\\n          \\\\n          const slug = (body.slug || \\\'\\\').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const addonsJson = JSON.stringify(body.addons || []);\\\\n          \\\\n          if (body.id) {\\\\n            // Prepare gallery_images as JSON string if it\\\'s an array\\\\n            const galleryJson = Array.isArray(body.gallery_images) \\\\n              ? JSON.stringify(body.gallery_images) \\\\n              : (body.gallery_images || \\\'[]\\\');\\\\n            \\\\n            await env.DB.prepare(`\\\\n              UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\\\\n              instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\\\\n              gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\\\\n              whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?\\\\n            `).bind(\\\\n              title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n              body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n              body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n              body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n              body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\', Number(body.id)\\\\n            ).run();\\\\n            return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });\\\\n          }\\\\n          \\\\n          // Prepare gallery_images as JSON string if it\\\'s an array\\\\n          const galleryJson = Array.isArray(body.gallery_images) \\\\n            ? JSON.stringify(body.gallery_images) \\\\n            : (body.gallery_images || \\\'[]\\\');\\\\n          \\\\n          const r = await env.DB.prepare(`\\\\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\\\\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\\\\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \\\'active\\\', 0)\\\\n          `).bind(\\\\n            title, slug, body.description || \\\'\\\', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,\\\\n            body.instant_delivery ? 1 : 0, body.normal_delivery_text || \\\'\\\',\\\\n            body.thumbnail_url || \\\'\\\', body.video_url || \\\'\\\', galleryJson, addonsJson,\\\\n            body.seo_title || \\\'\\\', body.seo_description || \\\'\\\', body.seo_keywords || \\\'\\\', body.seo_canonical || \\\'\\\',\\\\n            body.whop_plan || \\\'\\\', body.whop_price_map || \\\'\\\', body.whop_product_id || \\\'\\\'\\\\n          ).run();\\\\n          const newId = r.meta?.last_row_id;\\\\n          return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/product/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          if (!id) return json({ error: \\\'ID required\\\' }, 400);\\\\n          await env.DB.prepare(\\\'DELETE FROM products WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS LIST (admin) -----\\\\n        // Return all products regardless of status.  Used by the admin UI to\\\\n        // manage published and draft products.  Includes the status column to\\\\n        // drive publish/unpublish toggles.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/products/list\\\') {\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          return json({ products: r.results || [] });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS STATUS UPDATE -----\\\\n        // Update the status of a product (active for published, draft for draft).\\\\n        // Accepts JSON with `id` and `status`.  Status must be \\\'active\\\' or \\\'draft\\\'.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!id || !status) {\\\\n            return json({ error: \\\'id and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'active\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE products SET status = ? WHERE id = ?\\\').bind(status, Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PRODUCTS DUPLICATE -----\\\\n        // Duplicate an existing product.  Accepts JSON with `id`.  Copies\\\\n        // all fields and inserts a new product with slug suffixed by \\\'-copy\\\'\\\\n        // and status set to \\\'draft\\\'.  Ensures slug uniqueness by adding\\\\n        // numerical suffixes when needed.  Returns the new product id and slug.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/products/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const id = body.id;\\\\n          if (!id) {\\\\n            return json({ error: \\\'id required\\\' }, 400);\\\\n          }\\\\n          const row = await env.DB.prepare(\\\'SELECT * FROM products WHERE id = ?\\\').bind(Number(id)).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Product not found\\\' }, 404);\\\\n          }\\\\n          const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Determine unique new slug\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM products WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          // Copy all relevant fields into a new product row\\\\n          const r = await env.DB.prepare(\\\\n            `INSERT INTO products (\\\\n              title, slug, description, normal_price, sale_price,\\\\n              instant_delivery, normal_delivery_text, thumbnail_url, video_url,\\\\n              addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\\\\n              whop_plan, whop_price_map, status, sort_order\\\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\\\\n          ).bind(\\\\n            (row.title || \\\'\\\') + \\\' Copy\\\',\\\\n            newSlug,\\\\n            row.description || \\\'\\\',\\\\n            row.normal_price || 0,\\\\n            row.sale_price || null,\\\\n            row.instant_delivery || 0,\\\\n            row.normal_delivery_text || \\\'\\\',\\\\n            row.thumbnail_url || \\\'\\\',\\\\n            row.video_url || \\\'\\\',\\\\n            row.addons_json || \\\'[]\\\',\\\\n            row.seo_title || \\\'\\\',\\\\n            row.seo_description || \\\'\\\',\\\\n            row.seo_keywords || \\\'\\\',\\\\n            row.seo_canonical || \\\'\\\',\\\\n            row.whop_plan || \\\'\\\',\\\\n            row.whop_price_map || \\\'\\\',\\\\n            \\\'draft\\\',\\\\n            0\\\\n          ).run();\\\\n          return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- ORDERS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/orders\\\') {\\\\n          const r = await env.DB.prepare(\\\'SELECT * FROM orders ORDER BY id DESC\\\').all();\\\\n          const orders = (r.results || []).map(row => {\\\\n            let email = \\\'\\\', amount = null, addons = [];\\\\n            try {\\\\n              if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n                const d = JSON.parse(row.encrypted_data);\\\\n                email = d.email || \\\'\\\';\\\\n                amount = d.amount;\\\\n                addons = d.addons || [];\\\\n              }\\\\n            } catch(e) {\\\\n              console.error(\\\'Failed to parse order encrypted_data for order:\\\', row.order_id, e.message);\\\\n            }\\\\n            return { ...row, email, amount, addons };\\\\n          });\\\\n          return json({ orders });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && (path === \\\'/api/order/create\\\' || path === \\\'/submit-order\\\')) {\\\\n          const body = await req.json();\\\\n          if (!body.productId) return json({ error: \\\'productId required\\\' }, 400);\\\\n          \\\\n          const orderId = body.orderId || crypto.randomUUID().split(\\\'-\\\')[0].toUpperCase();\\\\n          const data = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount,\\\\n            productId: body.productId,\\\\n            addons: body.addons || []\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(orderId, Number(body.productId), data, \\\'PAID\\\', Number(body.deliveryTime) || 60).run();\\\\n          \\\\n          return json({ success: true, orderId });\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/order/buyer/\\\')) {\\\\n           const orderId = path.split(\\\'/\\\').pop();\\\\n           const row = await env.DB.prepare(\\\\n             \\\'SELECT o.*, p.title as product_title, p.thumbnail_url as product_thumbnail FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\\\'\\\\n           ).bind(orderId).first();\\\\n\\\\n           if (!row) return json({ error: \\\'Order not found\\\' }, 404);\\\\n\\\\n           // Check if review already exists for this order\\\\n           const reviewCheck = await env.DB.prepare(\\\\n             \\\'SELECT id FROM reviews WHERE order_id = ? LIMIT 1\\\'\\\\n           ).bind(orderId).first();\\\\n           const hasReview = !!reviewCheck;\\\\n\\\\n           let addons = [], email = \\\'\\\', amount = null;\\\\n           try {\\\\n             if (row.encrypted_data && row.encrypted_data[0] === \\\'{\\\') {\\\\n               const d = JSON.parse(row.encrypted_data);\\\\n               addons = d.addons || [];\\\\n               email = d.email || \\\'\\\';\\\\n               amount = d.amount;\\\\n             }\\\\n           } catch(e) {\\\\n             console.error(\\\'Failed to parse order encrypted_data for buyer order:\\\', orderId, e.message);\\\\n           }\\\\n\\\\n           // Convert SQLite datetime to ISO 8601 format with Z suffix for UTC\\\\n           const orderData = { ...row, addons, email, amount, has_review: hasReview };\\\\n           if (orderData.created_at && typeof orderData.created_at === \\\'string\\\') {\\\\n             // SQLite format: YYYY-MM-DD HH:MM:SS -> ISO 8601: YYYY-MM-DDTHH:MM:SSZ\\\\n             orderData.created_at = orderData.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n\\\\n           return json({ order: orderData });\\\\n         }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/order/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM orders WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // Update order (status, delivery time, etc.)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/update\\\') {\\\\n          const body = await req.json();\\\\n          const orderId = body.orderId;\\\\n          \\\\n          if (!orderId) return json({ error: \\\'orderId required\\\' }, 400);\\\\n          \\\\n          const updates = [];\\\\n          const values = [];\\\\n          \\\\n          if (body.status !== undefined) {\\\\n            updates.push(\\\'status = ?\\\');\\\\n            values.push(body.status);\\\\n          }\\\\n          if (body.delivery_time_minutes !== undefined) {\\\\n            updates.push(\\\'delivery_time_minutes = ?\\\');\\\\n            values.push(Number(body.delivery_time_minutes));\\\\n          }\\\\n          \\\\n          if (updates.length === 0) {\\\\n            return json({ error: \\\'No fields to update\\\' }, 400);\\\\n          }\\\\n          \\\\n          values.push(orderId);\\\\n          await env.DB.prepare(`UPDATE orders SET ${updates.join(\\\', \\\')} WHERE order_id = ?`).bind(...values).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // Create order manually (admin)\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/create\\\') {\\\\n          const body = await req.json();\\\\n          \\\\n          if (!body.productId || !body.email) {\\\\n            return json({ error: \\\'productId and email required\\\' }, 400);\\\\n          }\\\\n          \\\\n          // Generate unique order ID\\\\n          const orderId = \\\'MO\\\' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 6).toUpperCase();\\\\n          \\\\n          // Store order data\\\\n          const encryptedData = JSON.stringify({\\\\n            email: body.email,\\\\n            amount: body.amount || 0,\\\\n            addons: body.notes ? [{ field: \\\'Admin Notes\\\', value: body.notes }] : [],\\\\n            manualOrder: true\\\\n          });\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(\\\\n            orderId,\\\\n            Number(body.productId),\\\\n            encryptedData,\\\\n            body.status || \\\'paid\\\',\\\\n            Number(body.deliveryTime) || 60\\\\n          ).run();\\\\n          \\\\n          return json({ success: true, orderId });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/deliver\\\') {\\\\n                  const body = await req.json();\\\\n                  if (!body.orderId || !body.videoUrl) return json({ error: \\\'orderId and videoUrl required\\\' }, 400);\\\\n\\\\n                  // Get order data before updating\\\\n                  const orderResult = await env.DB.prepare(\\\\n                    \\\'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\\\'\\\\n                  ).bind(body.orderId).first();\\\\n\\\\n                  // Prepare additional metadata for delivered videos (Archive.org + subtitles, etc)\\\\n                  const deliveredVideoMetadata = JSON.stringify({\\\\n                    embedUrl: body.embedUrl,\\\\n                    itemId: body.itemId,\\\\n                    subtitlesUrl: body.subtitlesUrl,\\\\n                    tracks: Array.isArray(body.tracks) ? body.tracks : undefined,\\\\n                    deliveredAt: new Date().toISOString()\\\\n                  });\\\\n\\\\n                  await env.DB.prepare(\\\\n                    \\\'UPDATE orders SET delivered_video_url=?, delivered_thumbnail_url=?, status=?, delivered_at=CURRENT_TIMESTAMP, delivered_video_metadata=? WHERE order_id=?\\\'\\\\n                  ).bind(body.videoUrl, body.thumbnailUrl || null, \\\'delivered\\\', deliveredVideoMetadata, body.orderId).run();\\\\n          \\\\n          // Trigger email webhook if configured\\\\n          try {\\\\n            const googleScriptUrl = await getGoogleScriptUrl(env);\\\\n            if (googleScriptUrl && orderResult) {\\\\n              // Extract email from encrypted data\\\\n              let customerEmail = \\\'\\\';\\\\n              try {\\\\n                const decrypted = JSON.parse(orderResult.encrypted_data);\\\\n                customerEmail = decrypted.email || \\\'\\\';\\\\n              } catch (e) {\\\\n                console.warn(\\\'Could not decrypt order data for email\\\');\\\\n              }\\\\n              \\\\n              // Send delivery notification webhook\\\\n              await fetch(googleScriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'order.delivered\\\',\\\\n                  order: {\\\\n                    order_id: body.orderId,\\\\n                    product_title: orderResult.product_title || \\\'Your Order\\\',\\\\n                    email: customerEmail,\\\\n                    delivered_video_url: body.videoUrl,\\\\n                    status: \\\'delivered\\\'\\\\n                  }\\\\n                })\\\\n              }).catch(err => console.error(\\\'Failed to send delivery webhook:\\\', err));\\\\n            }\\\\n          } catch (err) {\\\\n            console.error(\\\'Error triggering delivery webhook:\\\', err);\\\\n          }\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/revision\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.orderId) return json({ error: \\\'orderId required\\\' }, 400);\\\\n          \\\\n          // Get order data before updating\\\\n          const orderResult = await env.DB.prepare(\\\\n            \\\'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\\\'\\\\n          ).bind(body.orderId).first();\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'UPDATE orders SET revision_requested=1, revision_count=revision_count+1, status=? WHERE order_id=?\\\'\\\\n          ).bind(\\\'revision\\\', body.orderId).run();\\\\n          \\\\n          // Trigger revision notification webhook if configured\\\\n          try {\\\\n            const googleScriptUrl = await getGoogleScriptUrl(env);\\\\n            if (googleScriptUrl && orderResult) {\\\\n              // Extract email from encrypted data\\\\n              let customerEmail = \\\'\\\';\\\\n              try {\\\\n                const decrypted = JSON.parse(orderResult.encrypted_data);\\\\n                customerEmail = decrypted.email || \\\'\\\';\\\\n              } catch (e) {\\\\n                console.warn(\\\'Could not decrypt order data for email\\\');\\\\n              }\\\\n              \\\\n              // Send revision notification webhook\\\\n              await fetch(googleScriptUrl, {\\\\n                method: \\\'POST\\\',\\\\n                headers: { \\\'Content-Type\\\': \\\'application/json\\\' },\\\\n                body: JSON.stringify({\\\\n                  event: \\\'order.revision_requested\\\',\\\\n                  order: {\\\\n                    order_id: body.orderId,\\\\n                    product_title: orderResult.product_title || \\\'Your Order\\\',\\\\n                    email: customerEmail,\\\\n                    revision_reason: body.reason || \\\'No reason provided\\\',\\\\n                    revision_count: (orderResult.revision_count || 0) + 1,\\\\n                    status: \\\'revision\\\'\\\\n                  }\\\\n                })\\\\n              }).catch(err => console.error(\\\'Failed to send revision webhook:\\\', err));\\\\n            }\\\\n          } catch (err) {\\\\n            console.error(\\\'Error triggering revision webhook:\\\', err);\\\\n          }\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/portfolio\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\\n            \\\'UPDATE orders SET portfolio_enabled=? WHERE order_id=?\\\'\\\\n          ).bind(body.portfolioEnabled ? 1 : 0, body.orderId).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/archive-link\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\'UPDATE orders SET archive_url=? WHERE order_id=?\\\').bind(body.archiveUrl, body.orderId).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- REVIEWS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/reviews\\\') {\\\\n          // Support filtering by productId(s), ids and rating via query parameters.\\\\n          const params = url.searchParams;\\\\n          const rating = params.get(\\\'rating\\\');\\\\n          const productId = params.get(\\\'productId\\\');\\\\n          const productIds = params.get(\\\'productIds\\\');\\\\n          const ids = params.get(\\\'ids\\\');\\\\n          let sql = \\\'SELECT r.*, p.title as product_title FROM reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.status = ?\\\';\\\\n          /**\\\\n           * Bind values can be strings or numbers.  TypeScript incorrectly infers\\\\n           * this array as `string[]` because the first value is a string, which causes\\\\n           * type errors when numbers are pushed.  Annotate the type explicitly to\\\\n           * avoid type errors in the Cloudflare editor.\\\\n           * @type {(string|number)[]}\\\\n           */\\\\n          const binds = [\\\'approved\\\'];\\\\n          // Filter by rating\\\\n          if (rating) {\\\\n            sql += \\\' AND r.rating = ?\\\';\\\\n            binds.push(Number(rating));\\\\n          }\\\\n          // Filter by single product\\\\n          if (productId) {\\\\n            sql += \\\' AND r.product_id = ?\\\';\\\\n            binds.push(Number(productId));\\\\n          }\\\\n          // Filter by multiple products\\\\n          if (productIds) {\\\\n            const idsArr = productIds.split(\\\',\\\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\\\\n            if (idsArr.length > 0) {\\\\n              sql += ` AND r.product_id IN (${idsArr.map(() => \\\'?\\\').join(\\\',\\\')})`;\\\\n              binds.push(...idsArr);\\\\n            }\\\\n          }\\\\n          // Filter by specific review IDs\\\\n          if (ids) {\\\\n            const idsArr2 = ids.split(\\\',\\\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\\\\n            if (idsArr2.length > 0) {\\\\n              sql += ` AND r.id IN (${idsArr2.map(() => \\\'?\\\').join(\\\',\\\')})`;\\\\n              binds.push(...idsArr2);\\\\n            }\\\\n          }\\\\n          sql += \\\' ORDER BY r.created_at DESC\\\';\\\\n          const stmt = await env.DB.prepare(sql);\\\\n          const r = await stmt.bind(...binds).all();\\\\n\\\\n          // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n          const reviews = (r.results || []).map(review => {\\\\n            if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n              review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return review;\\\\n          });\\\\n\\\\n          return json({ reviews });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/reviews/add\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.productId || !body.rating) return json({ error: \\\'productId and rating required\\\' }, 400);\\\\n          \\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO reviews (product_id, author_name, rating, comment, status, order_id, show_on_product) VALUES (?, ?, ?, ?, ?, ?, ?)\\\'\\\\n          ).bind(Number(body.productId), body.author || \\\'Customer\\\', Number(body.rating), body.comment || \\\'\\\', \\\'approved\\\', body.orderId || null, body.showOnProduct !== undefined ? (body.showOnProduct ? 1 : 0) : 1).run();\\\\n          \\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/reviews/\\\')) {\\\\n           const productId = path.split(\\\'/\\\').pop();\\\\n           const r = await env.DB.prepare(\\\\n             `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \\\\n              FROM reviews \\\\n              LEFT JOIN orders ON reviews.order_id = orders.order_id \\\\n              WHERE reviews.product_id = ? AND reviews.status = ? \\\\n              ORDER BY reviews.created_at DESC`\\\\n           ).bind(Number(productId), \\\'approved\\\').all();\\\\n\\\\n           // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n           const reviews = (r.results || []).map(review => {\\\\n             if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n               review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             return review;\\\\n           });\\\\n\\\\n           return json({ reviews });\\\\n         }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/reviews/update\\\') {\\\\n          const body = await req.json();\\\\n          const id = Number(body.id);\\\\n          \\\\n          // Build dynamic update query based on provided fields\\\\n          const updates = [];\\\\n          const values = [];\\\\n          \\\\n          if (body.status !== undefined) {\\\\n            updates.push(\\\'status = ?\\\');\\\\n            values.push(body.status);\\\\n          }\\\\n          if (body.author_name !== undefined) {\\\\n            updates.push(\\\'author_name = ?\\\');\\\\n            values.push(body.author_name);\\\\n          }\\\\n          if (body.rating !== undefined) {\\\\n            updates.push(\\\'rating = ?\\\');\\\\n            values.push(Number(body.rating));\\\\n          }\\\\n          if (body.comment !== undefined) {\\\\n            updates.push(\\\'comment = ?\\\');\\\\n            values.push(body.comment);\\\\n          }\\\\n          if (body.show_on_product !== undefined) {\\\\n            updates.push(\\\'show_on_product = ?\\\');\\\\n            values.push(Number(body.show_on_product));\\\\n          }\\\\n          \\\\n          if (updates.length === 0) {\\\\n            return json({ error: \\\'No fields to update\\\' }, 400);\\\\n          }\\\\n          \\\\n          values.push(id);\\\\n          await env.DB.prepare(`UPDATE reviews SET ${updates.join(\\\', \\\')} WHERE id = ?`).bind(...values).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n\\\\n        // REMOVED: Review migration endpoint no longer needed with JOIN-based fetching\\\\n        // Migration endpoint removed as reviews now fetch delivery URLs dynamically from orders table\\\\n\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/reviews/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM reviews WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- SETTINGS -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/settings/whop\\\') {\\\\n          const row = await env.DB.prepare(\\\'SELECT value FROM settings WHERE key = ?\\\').bind(\\\'whop\\\').first();\\\\n          let settings = {};\\\\n          try { if (row?.value) settings = JSON.parse(row.value); } catch(e) {}\\\\n          return json({ settings });\\\\n        }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/settings/whop\\\') {\\\\n          const body = await req.json();\\\\n          await env.DB.prepare(\\\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\\\').bind(\\\'whop\\\', JSON.stringify(body)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n\\\\n        // ----- PAGES -----\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages\\\') {\\\\n           const r = await env.DB.prepare(\\\'SELECT id, slug, title, status, created_at, updated_at FROM pages ORDER BY id DESC\\\').all();\\\\n\\\\n           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\\\\n           const pages = (r.results || []).map(page => {\\\\n             if (page.created_at && typeof page.created_at === \\\'string\\\') {\\\\n               page.created_at = page.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             if (page.updated_at && typeof page.updated_at === \\\'string\\\') {\\\\n               page.updated_at = page.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n             }\\\\n             return page;\\\\n           });\\\\n\\\\n           return json({ pages });\\\\n         }\\\\n\\\\n        if (method === \\\'GET\\\' && path.startsWith(\\\'/api/page/\\\')) {\\\\n           const slug = path.split(\\\'/\\\').pop();\\\\n           const row = await env.DB.prepare(\\\'SELECT * FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n           if (!row) return json({ error: \\\'Page not found\\\' }, 404);\\\\n\\\\n           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC\\\\n           if (row.created_at && typeof row.created_at === \\\'string\\\') {\\\\n             row.created_at = row.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n           if (row.updated_at && typeof row.updated_at === \\\'string\\\') {\\\\n             row.updated_at = row.updated_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n           }\\\\n\\\\n           return json({ page: row });\\\\n         }\\\\n\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/page/save\\\') {\\\\n          const body = await req.json();\\\\n          if (!body.slug || !body.title) return json({ error: \\\'slug and title required\\\' }, 400);\\\\n          \\\\n          if (body.id) {\\\\n            await env.DB.prepare(\\\\n              \\\'UPDATE pages SET slug=?, title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?\\\'\\\\n            ).bind(body.slug, body.title, body.content || \\\'\\\', body.meta_description || \\\'\\\', body.status || \\\'published\\\', Number(body.id)).run();\\\\n            return json({ success: true, id: body.id });\\\\n          }\\\\n          \\\\n          const r = await env.DB.prepare(\\\\n            \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(body.slug, body.title, body.content || \\\'\\\', body.meta_description || \\\'\\\', body.status || \\\'published\\\').run();\\\\n          return json({ success: true, id: r.meta?.last_row_id });\\\\n        }\\\\n\\\\n        if (method === \\\'DELETE\\\' && path === \\\'/api/page/delete\\\') {\\\\n          const id = url.searchParams.get(\\\'id\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM pages WHERE id = ?\\\').bind(Number(id)).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- R2 UPLOAD -----\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/upload/temp-file\\\') {\\\\n          try {\\\\n            if (!env.R2_BUCKET) {\\\\n              console.error(\\\'R2_BUCKET not configured\\\');\\\\n              return json({ error: \\\'R2 storage not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            const sessionId = url.searchParams.get(\\\'sessionId\\\');\\\\n            const filename = url.searchParams.get(\\\'filename\\\');\\\\n\\\\n            if (!sessionId || !filename) {\\\\n              console.error(\\\'Missing sessionId or filename\\\');\\\\n              return json({ error: \\\'sessionId and filename required\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'Uploading file:\\\', filename, \\\'for session:\\\', sessionId);\\\\n\\\\n            const buf = await req.arrayBuffer();\\\\n\\\\n            // Validate file size (max 500MB for videos, 10MB for other files)\\\\n            const isVideo = filename.toLowerCase().match(/\\\\\\\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);\\\\n            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024; // 500MB for videos, 10MB for others\\\\n            const maxSizeLabel = isVideo ? \\\'500MB\\\' : \\\'10MB\\\';\\\\n            \\\\n            if (buf.byteLength > maxSize) {\\\\n              console.error(\\\'File too large:\\\', buf.byteLength, \\\'bytes (max\\\', maxSizeLabel, \\\')\\\');\\\\n              return json({\\\\n                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \\\'videos\\\' : \\\'files\\\'}.`,\\\\n                fileSize: buf.byteLength,\\\\n                maxSize: maxSize,\\\\n                fileType: isVideo ? \\\'video\\\' : \\\'file\\\'\\\\n              }, 400);\\\\n            }\\\\n\\\\n            if (!buf || buf.byteLength === 0) {\\\\n              console.error(\\\'Empty file buffer\\\');\\\\n              return json({ error: \\\'Empty file - please select a valid file\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'File size:\\\', (buf.byteLength / 1024 / 1024).toFixed(2), \\\'MB\\\');\\\\n\\\\n            const key = `temp/${sessionId}/${filename}`;\\\\n\\\\n            await env.R2_BUCKET.put(key, buf, {\\\\n              httpMetadata: { contentType: req.headers.get(\\\'content-type\\\') || \\\'application/octet-stream\\\' }\\\\n            });\\\\n\\\\n            console.log(\\\'File uploaded successfully:\\\', key);\\\\n\\\\n            return json({ success: true, tempUrl: `r2://${key}` });\\\\n          } catch (err) {\\\\n            console.error(\\\'Upload error:\\\', err);\\\\n            return json({\\\\n              error: \\\'Upload failed: \\\' + err.message,\\\\n              details: err.stack\\\\n            }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/r2/file\\\') {\\\\n          if (!env.R2_BUCKET) return json({ error: \\\'R2 not configured\\\' }, 500);\\\\n          \\\\n          const key = url.searchParams.get(\\\'key\\\');\\\\n          if (!key) return json({ error: \\\'key required\\\' }, 400);\\\\n          \\\\n          const obj = await env.R2_BUCKET.get(key);\\\\n          if (!obj) return json({ error: \\\'File not found\\\' }, 404);\\\\n          \\\\n          return new Response(obj.body, {\\\\n            headers: {\\\\n              \\\'Content-Type\\\': obj.httpMetadata?.contentType || \\\'application/octet-stream\\\',\\\\n              \\\'Cache-Control\\\': \\\'public, max-age=3600\\\'\\\\n            }\\\\n          });\\\\n        }\\\\n\\\\n        // ----- DELIVERY VIDEO UPLOAD -----\\\\n        // Two-stage upload process:\\\\n        // 1. Upload to R2 temp bucket for verification\\\\n        // 2. Upload to Archive.org for public access\\\\n        // 3. Verify both uploads succeeded before returning URL\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/upload/customer-file\\\') {\\\\n          try {\\\\n            if (!env.R2_BUCKET) {\\\\n              console.error(\\\'R2_BUCKET not configured\\\');\\\\n              return json({ error: \\\'R2 storage not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {\\\\n              console.error(\\\'Archive.org credentials not configured\\\');\\\\n              return json({ error: \\\'Archive.org credentials not configured\\\' }, 500);\\\\n            }\\\\n\\\\n            const itemId = (url.searchParams.get(\\\'itemId\\\') || \\\'\\\').replace(/[^a-zA-Z0-9_.-]/g, \\\'-\\\');\\\\n            const filename = (url.searchParams.get(\\\'filename\\\') || \\\'\\\').replace(/[^a-zA-Z0-9_.-]/g, \\\'-\\\');\\\\n            const originalFilename = url.searchParams.get(\\\'originalFilename\\\');\\\\n\\\\n            if (!itemId || !filename) {\\\\n              console.error(\\\'Missing itemId or filename\\\');\\\\n              return json({ error: \\\'itemId and filename required\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'Starting two-stage upload:\\\', filename, \\\'Item:\\\', itemId);\\\\n\\\\n            const buf = await req.arrayBuffer();\\\\n\\\\n            // Validate file size (max 500MB for videos, 10MB for other files)\\\\n            const videoExtensions = /\\\\\\\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;\\\\n            const isVideo = videoExtensions.test(filename);\\\\n            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;\\\\n            const maxSizeLabel = isVideo ? \\\'500MB\\\' : \\\'10MB\\\';\\\\n            \\\\n            if (buf.byteLength > maxSize) {\\\\n              console.error(\\\'File too large:\\\', buf.byteLength, \\\'bytes (max\\\', maxSizeLabel, \\\')\\\');\\\\n              return json({\\\\n                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \\\'videos\\\' : \\\'files\\\'}.`,\\\\n                fileSize: buf.byteLength,\\\\n                maxSize: maxSize,\\\\n                fileType: isVideo ? \\\'video\\\' : \\\'file\\\'\\\\n              }, 400);\\\\n            }\\\\n\\\\n            if (buf.byteLength === 0) {\\\\n              console.error(\\\'Empty file\\\');\\\\n              return json({ error: \\\'Empty file - please select a valid file\\\' }, 400);\\\\n            }\\\\n\\\\n            console.log(\\\'File size:\\\', (buf.byteLength / 1024 / 1024).toFixed(2), \\\'MB\\\');\\\\n\\\\n            // Force video MIME type for video files\\\\n            const contentType = isVideo \\\\n              ? (getMimeTypeFromFilename(filename) || \\\'video/mp4\\\')\\\\n              : resolveContentType(req, filename);\\\\n            const isVideoUpload = isVideo;\\\\n\\\\n            // STAGE 1: Upload to R2 temp bucket for verification\\\\n            console.log(\\\'STAGE 1: Uploading to R2 temp bucket...\\\');\\\\n            const r2TempKey = `temp/${itemId}/${filename}`;\\\\n            try {\\\\n              await env.R2_BUCKET.put(r2TempKey, buf, {\\\\n                httpMetadata: { contentType: contentType }\\\\n              });\\\\n              console.log(\\\'R2 temp upload successful:\\\', r2TempKey);\\\\n            } catch (r2Err) {\\\\n              console.error(\\\'R2 temp upload failed:\\\', r2Err);\\\\n              return json({\\\\n                error: \\\'Failed to upload to temp storage: \\\' + r2Err.message,\\\\n                stage: \\\'r2-temp\\\',\\\\n                details: r2Err.stack\\\\n              }, 500);\\\\n            }\\\\n\\\\n            // Verify R2 file exists\\\\n            console.log(\\\'Verifying R2 temp upload...\\\');\\\\n            let r2File;\\\\n            try {\\\\n              r2File = await env.R2_BUCKET.get(r2TempKey);\\\\n              if (!r2File) {\\\\n                throw new Error(\\\'File not found in R2 after upload\\\');\\\\n              }\\\\n              console.log(\\\'R2 verification successful\\\');\\\\n            } catch (verifyErr) {\\\\n              console.error(\\\'R2 verification failed:\\\', verifyErr);\\\\n              return json({\\\\n                error: \\\'R2 upload verification failed: \\\' + verifyErr.message,\\\\n                stage: \\\'r2-verify\\\',\\\\n                details: verifyErr.stack\\\\n              }, 500);\\\\n            }\\\\n\\\\n            // Get order details for Archive.org metadata\\\\n            const orderIdFromQuery = url.searchParams.get(\\\'orderId\\\');\\\\n            let resolvedOrderId = orderIdFromQuery;\\\\n            if (!resolvedOrderId) {\\\\n              const match = itemId.match(/^delivery_(.+?)_\\\\\\\\d+$/);\\\\n              if (match) {\\\\n                resolvedOrderId = match[1];\\\\n              }\\\\n            }\\\\n\\\\n            let archiveDescription = \\\'\\\';\\\\n            if (resolvedOrderId) {\\\\n              try {\\\\n                const orderRow = await env.DB.prepare(\\\\n                  \\\'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\\\'\\\\n                ).bind(resolvedOrderId).first();\\\\n\\\\n                if (orderRow) {\\\\n                  const productTitle = orderRow.product_title || \\\'\\\';\\\\n                  const productDescription = orderRow.product_description || \\\'\\\';\\\\n\\\\n                  if (productDescription) {\\\\n                    archiveDescription = productTitle\\\\n                      ? `${productTitle} - ${productDescription}`\\\\n                      : productDescription;\\\\n                  } else {\\\\n                    archiveDescription = `Order #${orderRow.order_id} - ${productTitle || \\\'Video Delivery\\\'}`;\\\\n                  }\\\\n                } else {\\\\n                  archiveDescription = `Order #${resolvedOrderId} video delivery`;\\\\n                }\\\\n              } catch (dbErr) {\\\\n                console.warn(\\\'Could not fetch order details:\\\', dbErr);\\\\n                archiveDescription = `Order #${resolvedOrderId} video delivery`;\\\\n              }\\\\n            } else {\\\\n              archiveDescription = `${isVideoUpload ? \\\'Video\\\' : \\\'File\\\'} uploaded via order delivery system`;\\\\n            }\\\\n\\\\n            const archiveHeaders = {\\\\n              Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,\\\\n              \\\'Content-Type\\\': contentType,\\\\n              \\\'x-archive-auto-make-bucket\\\': \\\'1\\\',\\\\n              \\\'x-archive-meta-mediatype\\\': isVideoUpload ? \\\'movies\\\' : \\\'data\\\',\\\\n              \\\'x-archive-meta-collection\\\': isVideoUpload ? \\\'opensource_movies\\\' : \\\'opensource\\\',\\\\n              \\\'x-archive-meta-title\\\': normalizeArchiveMetaValue(originalFilename || filename),\\\\n              \\\'x-archive-meta-description\\\': normalizeArchiveMetaValue(archiveDescription),\\\\n              \\\'x-archive-meta-subject\\\': \\\'video; delivery\\\',\\\\n              \\\'x-archive-meta-language\\\': \\\'eng\\\'\\\\n            };\\\\n\\\\n            console.log(\\\'Archive.org Upload Metadata:\\\', {\\\\n              isVideo: isVideo,\\\\n              isVideoUpload: isVideoUpload,\\\\n              contentType: contentType,\\\\n              mediatype: archiveHeaders[\\\'x-archive-meta-mediatype\\\'],\\\\n              filename: filename,\\\\n              itemId: itemId\\\\n            });\\\\n\\\\n            // STAGE 2: Upload to Archive.org\\\\n            console.log(\\\'STAGE 2: Uploading to Archive.org...\\\');\\\\n            const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;\\\\n            let archiveResp;\\\\n            try {\\\\n              archiveResp = await fetch(archiveUrl, {\\\\n                method: \\\'PUT\\\',\\\\n                headers: archiveHeaders,\\\\n                body: buf\\\\n              });\\\\n\\\\n              if (!archiveResp.ok) {\\\\n                const errorText = await archiveResp.text().catch(() => \\\'Unknown error\\\');\\\\n                console.error(\\\'Archive.org upload failed:\\\', archiveResp.status, errorText);\\\\n                return json({\\\\n                  error: \\\'Archive.org upload failed\\\',\\\\n                  status: archiveResp.status,\\\\n                  details: errorText,\\\\n                  stage: \\\'archive-upload\\\',\\\\n                  r2Uploaded: true\\\\n                }, 502);\\\\n              }\\\\n              console.log(\\\'Archive.org upload successful, status:\\\', archiveResp.status);\\\\n            } catch (archiveErr) {\\\\n              console.error(\\\'Archive.org upload network error:\\\', archiveErr);\\\\n              return json({\\\\n                error: \\\'Failed to connect to Archive.org: \\\' + archiveErr.message,\\\\n                stage: \\\'archive-connect\\\',\\\\n                details: archiveErr.message,\\\\n                r2Uploaded: true\\\\n              }, 502);\\\\n            }\\\\n\\\\n            // STAGE 3: Wait for Archive.org to index the file\\\\n            console.log(\\\'STAGE 3: Waiting for Archive.org indexing...\\\');\\\\n            await new Promise(resolve => setTimeout(resolve, 3000));\\\\n\\\\n            // STAGE 4: Verify Archive.org file is accessible\\\\n            console.log(\\\'STAGE 4: Verifying Archive.org file...\\\');\\\\n            const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;\\\\n            const embedUrl = `https://archive.org/details/${itemId}`;\\\\n            \\\\n            let verifyAttempts = 0;\\\\n            const maxVerifyAttempts = 3;\\\\n            let archiveVerified = false;\\\\n\\\\n            while (verifyAttempts < maxVerifyAttempts && !archiveVerified) {\\\\n              verifyAttempts++;\\\\n              try {\\\\n                const verifyResp = await fetch(downloadUrl, { method: \\\'HEAD\\\' });\\\\n                if (verifyResp.ok) {\\\\n                  console.log(\\\'Archive.org file verified at attempt\\\', verifyAttempts);\\\\n                  archiveVerified = true;\\\\n                  break;\\\\n                } else if (verifyResp.status === 404 && verifyAttempts < maxVerifyAttempts) {\\\\n                  console.log(`Archive.org file not yet available (attempt ${verifyAttempts}/${maxVerifyAttempts}), waiting...`);\\\\n                  await new Promise(resolve => setTimeout(resolve, 2000));\\\\n                } else {\\\\n                  console.warn(`Archive.org verification returned status ${verifyResp.status}`);\\\\n                  break;\\\\n                }\\\\n              } catch (verifyErr) {\\\\n                console.warn(`Archive.org verification attempt ${verifyAttempts} failed:`, verifyErr.message);\\\\n                if (verifyAttempts < maxVerifyAttempts) {\\\\n                  await new Promise(resolve => setTimeout(resolve, 2000));\\\\n                }\\\\n              }\\\\n            }\\\\n\\\\n            if (!archiveVerified) {\\\\n              console.warn(\\\'Archive.org file could not be verified, but upload was successful\\\');\\\\n            }\\\\n\\\\n            console.log(\\\'Upload complete - both R2 and Archive.org successful\\\');\\\\n            return json({ \\\\n              success: true, \\\\n              url: downloadUrl,\\\\n              embedUrl: embedUrl,\\\\n              itemId: itemId,\\\\n              filename: filename,\\\\n              r2Verified: true,\\\\n              archiveVerified: archiveVerified,\\\\n              isVideo: isVideoUpload\\\\n            });\\\\n\\\\n          } catch (err) {\\\\n            console.error(\\\'Customer file upload error:\\\', err);\\\\n            return json({\\\\n              error: \\\'Upload failed: \\\' + err.message,\\\\n              details: err.stack,\\\\n              stage: \\\'unknown\\\'\\\\n            }, 500);\\\\n          }\\\\n        }\\\\n\\\\n        // ----- ORDER ENCRYPTED FILE UPLOAD -----\\\\n        // This endpoint allows the admin UI to upload a file for a specific order.\\\\n        // The file will be stored in the configured R2 bucket and the order record\\\\n        // can be updated with a link to the uploaded file. This mirrors the\\\\n        // expectation of the admin/orders.js front\\\\u2011end which calls\\\\n        // `/api/order/upload-encrypted-file`.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/order/upload-encrypted-file\\\') {\\\\n          if (!env.R2_BUCKET) {\\\\n            return json({ error: \\\'R2 not configured\\\' }, 500);\\\\n          }\\\\n          const orderId = url.searchParams.get(\\\'orderId\\\');\\\\n          const itemId = url.searchParams.get(\\\'itemId\\\');\\\\n          const filename = url.searchParams.get(\\\'filename\\\');\\\\n          if (!orderId || !itemId || !filename) {\\\\n            return json({ error: \\\'orderId, itemId and filename required\\\' }, 400);\\\\n          }\\\\n          // Read the request body into a buffer\\\\n          const fileBuf = await req.arrayBuffer();\\\\n          const key = `orders/${orderId}/${itemId}/${filename}`;\\\\n          await env.R2_BUCKET.put(key, fileBuf, {\\\\n            httpMetadata: { contentType: req.headers.get(\\\'content-type\\\') || \\\'application/octet-stream\\\' }\\\\n          });\\\\n          // You could update the orders table with the uploaded file key or URL here.\\\\n          // We return the R2 key so the caller can take further action if needed.\\\\n          return json({ success: true, r2Key: key });\\\\n        }\\\\n\\\\n        // ----- PAGE BUILDER SAVE (plural) -----\\\\n        // The page builder UI posts to /api/pages/save with a JSON body containing a\\\\n        // `name` (used as slug/title) and `html` (the full HTML document). Because the\\\\n        // existing API only exposes singular `/api/page/save`, we implement this\\\\n        // convenience endpoint here. If a page with the same slug already exists,\\\\n        // it is updated instead of inserted. The HTML is stored verbatim in the\\\\n        // pages table\\\'s content column.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/save\\\') {\\\\n          const body = await req.json();\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          const html = (body.html || \\\'\\\').trim();\\\\n          if (!name || !html) {\\\\n            return json({ error: \\\'name and html required\\\' }, 400);\\\\n          }\\\\n          // Sanitize the slug: lower\\\\u2011case and replace non\\\\u2011alphanumeric characters with dashes\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          // Check if page already exists\\\\n          const existing = await env.DB.prepare(\\\'SELECT id FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (existing) {\\\\n            await env.DB.prepare(\\\\n              \\\'UPDATE pages SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?\\\'\\\\n            ).bind(name, html, existing.id).run();\\\\n          } else {\\\\n            await env.DB.prepare(\\\\n              \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n            ).bind(slug, name, html, \\\'\\\', \\\'published\\\').run();\\\\n          }\\\\n          return json({ success: true, slug });\\\\n        }\\\\n\\\\n        // ----- PAGES LIST (plural) -----\\\\n        // Returns a list of pages stored in the pages table, formatted for the\\\\n        // admin UI. Each entry includes a `name` (slug), `url` (path to the\\\\n        // generated static file), `uploaded` timestamp, and estimated `size`\\\\n        // (length of the HTML content). This endpoint exists to support\\\\n        // admin/pages.html which expects `/api/pages/list`.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages/list\\\') {\\\\n          // Return all pages with their publish status. The admin UI uses this to\\\\n          // display published/draft pages and provide actions.  Selecting the\\\\n          // status column allows distinguishing between published and draft.\\\\n          const r = await env.DB.prepare(\\\\n            \\\'SELECT slug, title, content, created_at, status FROM pages ORDER BY id DESC\\\'\\\\n          ).all();\\\\n          const pages = (r.results || []).map(p => {\\\\n            const size = p.content ? p.content.length : 0;\\\\n            // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n            let createdAt = p.created_at;\\\\n            if (createdAt && typeof createdAt === \\\'string\\\') {\\\\n              createdAt = createdAt.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n            }\\\\n            return {\\\\n              name: p.slug,\\\\n              slug: p.slug,\\\\n              title: p.title,\\\\n              url: `/${p.slug}.html`,\\\\n              uploaded: createdAt,\\\\n              size: size,\\\\n              status: p.status || \\\'published\\\'\\\\n            };\\\\n          });\\\\n          return json({ success: true, pages });\\\\n        }\\\\n\\\\n        // ----- PAGES DELETE (plural) -----\\\\n        // Deletes a page by slug/name. Accepts a JSON body with a `name` field.\\\\n        // Returns success if the page was removed. This mirrors the admin UI\\\\n        // expectation that deletion happens via POST to `/api/pages/delete`.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/delete\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          await env.DB.prepare(\\\'DELETE FROM pages WHERE slug = ?\\\').bind(slug).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PAGES STATUS UPDATE -----\\\\n        // Update the publish status of a page. Accepts JSON with `name` (slug)\\\\n        // and `status` (\\\'published\\\' or \\\'draft\\\'). Updates the status column\\\\n        // accordingly. Returns an error if the page does not exist.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/status\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          const status = (body.status || \\\'\\\').trim().toLowerCase();\\\\n          if (!name || !status) {\\\\n            return json({ error: \\\'name and status required\\\' }, 400);\\\\n          }\\\\n          if (status !== \\\'published\\\' && status !== \\\'draft\\\') {\\\\n            return json({ error: \\\'invalid status\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const existing = await env.DB.prepare(\\\'SELECT id FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (!existing) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          await env.DB.prepare(\\\'UPDATE pages SET status = ? WHERE slug = ?\\\').bind(status, slug).run();\\\\n          return json({ success: true });\\\\n        }\\\\n\\\\n        // ----- PAGES DUPLICATE -----\\\\n        // Duplicate an existing page into a draft. Accepts JSON with `name`\\\\n        // (slug of the existing page). Copies title, content and meta description,\\\\n        // derives a new slug by appending \\\'-copy\\\' and ensures uniqueness.\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/pages/duplicate\\\') {\\\\n          const body = await req.json().catch(() => ({}));\\\\n          const name = (body.name || \\\'\\\').trim();\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const baseSlug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const row = await env.DB.prepare(\\\'SELECT title, content, meta_description FROM pages WHERE slug = ?\\\').bind(baseSlug).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          // Determine new slug by adding \\\'-copy\\\' and ensuring uniqueness\\\\n          let newSlug = baseSlug + \\\'-copy\\\';\\\\n          let idx = 1;\\\\n          let exists = await env.DB.prepare(\\\'SELECT slug FROM pages WHERE slug = ?\\\').bind(newSlug).first();\\\\n          while (exists) {\\\\n            newSlug = `${baseSlug}-copy${idx}`;\\\\n            idx++;\\\\n            exists = await env.DB.prepare(\\\'SELECT slug FROM pages WHERE slug = ?\\\').bind(newSlug).first();\\\\n          }\\\\n          const newTitle = (row.title || baseSlug) + \\\' Copy\\\';\\\\n          const metaDesc = row.meta_description || \\\'\\\';\\\\n          await env.DB.prepare(\\\\n            \\\'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)\\\'\\\\n          ).bind(newSlug, newTitle, row.content || \\\'\\\', metaDesc, \\\'draft\\\').run();\\\\n          return json({ success: true, slug: newSlug });\\\\n        }\\\\n\\\\n        // ----- PAGE BUILDER LOAD (plural) -----\\\\n        // Fetch and parse a saved landing page for editing in the builder. The\\\\n        // builder expects separate `html` (the body content) and `css` (style) fields.\\\\n        if (method === \\\'GET\\\' && path === \\\'/api/pages/load\\\') {\\\\n          const name = url.searchParams.get(\\\'name\\\');\\\\n          if (!name) {\\\\n            return json({ error: \\\'name required\\\' }, 400);\\\\n          }\\\\n          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, \\\'-\\\').replace(/^-|-$/g, \\\'\\\');\\\\n          const row = await env.DB.prepare(\\\'SELECT content FROM pages WHERE slug = ?\\\').bind(slug).first();\\\\n          if (!row) {\\\\n            return json({ error: \\\'Page not found\\\' }, 404);\\\\n          }\\\\n          let full = row.content || \\\'\\\';\\\\n          let css = \\\'\\\';\\\\n          let htmlBody = \\\'\\\';\\\\n          try {\\\\n            // Extract CSS between <style> tags\\\\n            const styleMatch = full.match(/<style[^>]*>([\\\\\\\\s\\\\\\\\S]*?)<\\\\\\\\/style>/i);\\\\n            if (styleMatch) {\\\\n              css = styleMatch[1];\\\\n            }\\\\n            // Extract body content between <body> tags\\\\n            const bodyMatch = full.match(/<body[^>]*>([\\\\\\\\s\\\\\\\\S]*?)<\\\\\\\\/body>/i);\\\\n            htmlBody = bodyMatch ? bodyMatch[1] : full;\\\\n          } catch (e) {\\\\n            htmlBody = full;\\\\n          }\\\\n          return json({ success: true, html: htmlBody.trim(), css: css.trim() });\\\\n        }\\\\n\\\\n        // ----- WEBHOOK -----\\\\n        if (method === \\\'POST\\\' && path === \\\'/api/whop/webhook\\\') {\\\\n          const body = await req.text();\\\\n          console.log(\\\'Webhook received:\\\', body.substring(0, 200));\\\\n          return new Response(\\\'OK\\\', { status: 200 });\\\\n        }\\\\n\\\\n        return json({ error: \\\'API endpoint not found\\\', path, method }, 404);\\\\n      }\\\\n\\\\n      // ===== SECURE DOWNLOAD =====\\\\n      if (path.startsWith(\\\'/download/\\\')) {\\\\n        const orderId = path.split(\\\'/\\\').pop();\\\\n        const order = await env.DB.prepare(\\\\n          \\\'SELECT archive_url, delivered_video_url FROM orders WHERE order_id = ?\\\'\\\\n        ).bind(orderId).first();\\\\n\\\\n        const sourceUrl = (order?.delivered_video_url || order?.archive_url || \\\'\\\').toString().trim();\\\\n\\\\n        if (!sourceUrl) {\\\\n          return new Response(\\\'Download link expired or not found\\\', { status: 404 });\\\\n        }\\\\n\\\\n        const lowered = sourceUrl.toLowerCase();\\\\n        const openOnly =\\\\n          lowered.includes(\\\'youtube.com\\\') ||\\\\n          lowered.includes(\\\'youtu.be\\\') ||\\\\n          lowered.includes(\\\'vimeo.com\\\') ||\\\\n          lowered.includes(\\\'iframe.mediadelivery.net/embed/\\\') ||\\\\n          lowered.includes(\\\'video.bunnycdn.com/play/\\\') ||\\\\n          (lowered.includes(\\\'archive.org/details/\\\') && !lowered.includes(\\\'/download/\\\'));\\\\n\\\\n        if (openOnly) {\\\\n          return Response.redirect(sourceUrl, 302);\\\\n        }\\\\n\\\\n        const fileResp = await fetch(sourceUrl);\\\\n        if (!fileResp.ok) {\\\\n          return new Response(\\\'File not available\\\', { status: 404 });\\\\n        }\\\\n\\\\n        const srcUrl = new URL(sourceUrl, url.origin);\\\\n        let filename = srcUrl.pathname.split(\\\'/\\\').pop() || \\\'video.mp4\\\';\\\\n        try {\\\\n          filename = decodeURIComponent(filename);\\\\n        } catch (_) {}\\\\n        filename = filename.replace(/\\\\"/g, \\\'\\\');\\\\n\\\\n        const contentTypeHeader = (fileResp.headers.get(\\\'content-type\\\') || \\\'\\\').split(\\\';\\\')[0].trim();\\\\n        const contentType = contentTypeHeader || getMimeTypeFromFilename(filename) || \\\'application/octet-stream\\\';\\\\n\\\\n        const headers = new Headers({ ...CORS });\\\\n        headers.set(\\\'Content-Type\\\', contentType);\\\\n        headers.set(\\\'Content-Disposition\\\', `attachment; filename=\\\\"${filename}\\\\"`);\\\\n\\\\n        const contentLength = fileResp.headers.get(\\\'content-length\\\');\\\\n        if (contentLength) {\\\\n          headers.set(\\\'Content-Length\\\', contentLength);\\\\n        }\\\\n\\\\n        return new Response(fileResp.body, {\\\\n          status: 200,\\\\n          headers\\\\n        });\\\\n      }\\\\n\\\\n      // ===== ADMIN SPA ROUTING =====\\\\n      // All /admin/* routes (except API endpoints) serve the unified dashboard.html\\\\n      // This enables the Single Page Application (SPA) structure for the admin panel\\\\n      if (path.startsWith(\\\'/admin/\\\') && !path.startsWith(\\\'/api/\\\')) {\\\\n        // Special handling for standalone pages that remain separate\\\\n        if (path.endsWith(\\\'/page-builder.html\\\') || \\\\n            path.endsWith(\\\'/landing-builder.html\\\') ||\\\\n            path.endsWith(\\\'/product-form.html\\\')) {\\\\n          // These pages are served directly as they are complex standalone apps\\\\n          // Let them fall through to the asset serving logic below\\\\n        } else if (path === \\\'/admin/\\\' || path === \\\'/admin\\\' || path.endsWith(\\\'/dashboard.html\\\')) {\\\\n          // Serve the main dashboard.html for root admin path\\\\n          if (env.ASSETS) {\\\\n            const assetResp = await env.ASSETS.fetch(new Request(new URL(\\\'/admin/dashboard.html\\\', req.url)));\\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n          }\\\\n        } else if (path.endsWith(\\\'.html\\\')) {\\\\n          // For any other /admin/*.html requests, redirect to dashboard.html\\\\n          // This ensures all old fragmented pages load as the unified dashboard\\\\n          if (env.ASSETS) {\\\\n            const assetResp = await env.ASSETS.fetch(new Request(new URL(\\\'/admin/dashboard.html\\\', req.url)));\\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      // ===== DYNAMIC PAGES =====\\\\n      // Serve saved landing pages from the pages table. If the request path ends\\\\n      // with `.html` and a corresponding page exists in the database, return its\\\\n      // HTML content. This allows pages saved via the page builder to be\\\\n      // accessed at `/{slug}.html`.\\\\n      if (path.endsWith(\\\'.html\\\') && !path.includes(\\\'/admin/\\\')) {\\\\n        const slug = path.slice(1).replace(/\\\\\\\\.html$/, \\\'\\\');\\\\n        try {\\\\n          const row = await env.DB.prepare(\\\'SELECT content FROM pages WHERE slug = ? AND status = ?\\\').bind(slug, \\\'published\\\').first();\\\\n          if (row && row.content) {\\\\n            return new Response(row.content, {\\\\n              headers: { \\\'Content-Type\\\': \\\'text/html; charset=utf-8\\\' }\\\\n            });\\\\n          }\\\\n        } catch (e) {\\\\n          // continue to static assets\\\\n        }\\\\n      }\\\\n\\\\n      // ===== STATIC ASSETS WITH SERVER-SIDE SCHEMA INJECTION =====\\\\n      if (env.ASSETS) {\\\\n        /*\\\\n         * Serve static assets from the bound ASSETS namespace.  We wrap the\\\\n         * returned response to add headers that prevent stale caching on the\\\\n         * Cloudflare edge and include a custom version header.  Without these\\\\n         * headers it is possible for older builds to persist at the edge or in\\\\n         * the browser cache.  See https://developers.cloudflare.com/workers/\\\\n         * for guidance on controlling caching behavior.\\\\n         */\\\\n        // Support pretty product URLs: /product/<slug>\\\\n        let assetReq = req;\\\\n        let assetPath = path;\\\\n        let schemaProductId = null;\\\\n\\\\n        // Canonical product URLs: /product-<id>/<slug>\\\\n        // Render without redirecting (page JS reads the id from the querystring).\\\\n        if ((method === \\\'GET\\\' || method === \\\'HEAD\\\')) {\\\\n          const canonicalMatch = assetPath.match(/^\\\\\\\\/product-(\\\\\\\\d+)\\\\\\\\/(.+)$/);\\\\n          if (canonicalMatch) {\\\\n            const pid = Number(canonicalMatch[1]);\\\\n            if (!Number.isNaN(pid)) {\\\\n              schemaProductId = pid;\\\\n              const rewritten = new URL(req.url);\\\\n              rewritten.pathname = \\\'/_product_template.tpl\\\';\\\\n              rewritten.searchParams.set(\\\'id\\\', String(schemaProductId));\\\\n              assetReq = new Request(rewritten.toString(), req);\\\\n              assetPath = \\\'/_product_template.tpl\\\';\\\\n            }\\\\n          }\\\\n        }\\\\n\\\\n        const assetResp = await env.ASSETS.fetch(assetReq);\\\\n        \\\\n        // For HTML pages with schema placeholders, inject server-side schemas\\\\n        const contentType = assetResp.headers.get(\\\'content-type\\\') || \\\'\\\';\\\\n        // The product template is stored as a .tpl asset to avoid Clean URL redirects.\\\\n        // ASSETS may serve unknown extensions as application/octet-stream, which makes\\\\n        // browsers download it instead of rendering. Treat the template as HTML.\\\\n        const isHTML = contentType.includes(\\\'text/html\\\') || assetPath === \\\'/_product_template.tpl\\\';\\\\n        const isSuccess = assetResp.status === 200;\\\\n        \\\\n        if (isHTML && isSuccess) {\\\\n          try {\\\\n            const baseUrl = url.origin;\\\\n            let html = await assetResp.text();\\\\n            \\\\n            // Product detail page - inject individual product schema\\\\n            if (assetPath === \\\'/_product_template.tpl\\\' || assetPath === \\\'/product.html\\\' || assetPath === \\\'/product\\\') {\\\\n              const productId = schemaProductId ? String(schemaProductId) : url.searchParams.get(\\\'id\\\');\\\\n              if (productId && env.DB) {\\\\n                await initDB(env);\\\\n                const product = await env.DB.prepare(`\\\\n                  SELECT p.*, \\\\n                    COUNT(r.id) as review_count, \\\\n                    AVG(r.rating) as rating_average\\\\n                  FROM products p\\\\n                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = \\\'approved\\\'\\\\n                  WHERE p.id = ?\\\\n                  GROUP BY p.id\\\\n                `).bind(Number(productId)).first();\\\\n                \\\\n                if (product) {\\\\n                  // Fetch individual reviews for schema\\\\n                  const reviewsResult = await env.DB.prepare(`\\\\n                    SELECT * FROM reviews\\\\n                    WHERE product_id = ? AND status = \\\'approved\\\'\\\\n                    ORDER BY created_at DESC\\\\n                    LIMIT 5\\\\n                  `).bind(Number(productId)).all();\\\\n                  let reviews = reviewsResult.results || [];\\\\n\\\\n                  // Convert created_at to ISO 8601 format with Z suffix for UTC\\\\n                  reviews = reviews.map(review => {\\\\n                    if (review.created_at && typeof review.created_at === \\\'string\\\') {\\\\n                      review.created_at = review.created_at.replace(\\\' \\\', \\\'T\\\') + \\\'Z\\\';\\\\n                    }\\\\n                    return review;\\\\n                  });\\\\n\\\\n                  const schemaJson = generateProductSchema(product, baseUrl, reviews);\\\\n                  html = injectSchemaIntoHTML(html, \\\'product-schema\\\', schemaJson);\\\\n                }\\\\n              }\\\\n            }\\\\n            // Product listing pages - inject collection schema\\\\n            else if (path === \\\'/index.html\\\' || path === \\\'/\\\' || \\\\n                     path === \\\'/products-grid.html\\\' ||\\\\n                     path === \\\'/all-products\\\' || path === \\\'/all-products.html\\\') {\\\\n              if (env.DB) {\\\\n                await initDB(env);\\\\n                const result = await env.DB.prepare(`\\\\n                  SELECT p.id, p.title, p.slug, p.description, \\\\n                    p.thumbnail_url, p.normal_price, p.sale_price,\\\\n                    COUNT(r.id) as review_count, \\\\n                    AVG(r.rating) as rating_average\\\\n                  FROM products p\\\\n                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = \\\'approved\\\'\\\\n                  WHERE p.status = \\\'active\\\'\\\\n                  GROUP BY p.id\\\\n                  ORDER BY p.sort_order ASC, p.id DESC\\\\n                  LIMIT 50\\\\n                `).all();\\\\n                \\\\n                const products = result.results || [];\\\\n                if (products.length > 0) {\\\\n                  const schemaJson = generateCollectionSchema(products, baseUrl);\\\\n                  html = injectSchemaIntoHTML(html, \\\'collection-schema\\\', schemaJson);\\\\n                }\\\\n              }\\\\n            }\\\\n            \\\\n            const headers = new Headers(assetResp.headers);\\\\n            headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n            headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n            headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n            headers.set(\\\'Content-Type\\\', \\\'text/html; charset=utf-8\\\');\\\\n            headers.set(\\\'Content-Disposition\\\', \\\'inline\\\');\\\\n            \\\\n            return new Response(html, {\\\\n              status: assetResp.status,\\\\n              headers\\\\n            });\\\\n          } catch (err) {\\\\n            console.error(\\\'Schema injection error:\\\', err);\\\\n            // Fall through to default asset serving on error\\\\n          }\\\\n        }\\\\n        \\\\n        // For non-HTML assets or on error, serve normally\\\\n        const headers = new Headers(assetResp.headers);\\\\n        headers.set(\\\'Cache-Control\\\', \\\'no-store, no-cache, must-revalidate\\\');\\\\n        headers.set(\\\'Pragma\\\', \\\'no-cache\\\');\\\\n        headers.set(\\\'X-Worker-Version\\\', VERSION);\\\\n        // Safety: if the product template ever falls through here (e.g. schema injection error),\\\\n        // ensure the browser renders it instead of downloading.\\\\n        if (assetPath === \\\'/_product_template.tpl\\\') {\\\\n          headers.set(\\\'Content-Type\\\', \\\'text/html; charset=utf-8\\\');\\\\n          headers.set(\\\'Content-Disposition\\\', \\\'inline\\\');\\\\n        }\\\\n        return new Response(assetResp.body, { status: assetResp.status, headers });\\\\n      }\\\\n\\\\n      return new Response(\\\'Worker is running\\\', { headers: { \\\'Content-Type\\\': \\\'text/plain\\\' } });\\\\n\\\\n    } catch (err) {\\\\n      console.error(\\\'Worker error:\\\', err);\\\\n      return json({ error: err.message, stack: err.stack }, 500);\\\\n    }\\\\n  },\\\\n\\\\n  // Scheduled handler for Cloudflare Cron Triggers\\\\n  // This runs automatically based on cron schedule in wrangler.toml\\\\n  async scheduled(event, env, ctx) {\\\\n    console.log(\\\'\\\\ud83d\\\\udd52 Scheduled cleanup running...\\\');\\\\n    \\\\n    try {\\\\n      // Initialize database\\\\n      await initDB(env);\\\\n      \\\\n      if (!env.WHOP_API_KEY) {\\\\n        console.error(\\\'WHOP_API_KEY not configured, skipping cleanup\\\');\\\\n        return;\\\\n      }\\\\n      \\\\n      // Get expired checkouts\\\\n      const expiredCheckouts = await env.DB.prepare(`\\\\n        SELECT checkout_id, product_id, expires_at\\\\n        FROM checkout_sessions\\\\n        WHERE status = \\\'pending\\\' \\\\n        AND datetime(expires_at) < datetime(\\\'now\\\')\\\\n        ORDER BY created_at ASC\\\\n        LIMIT 50\\\\n      `).all();\\\\n      \\\\n      let deleted = 0;\\\\n      let failed = 0;\\\\n      \\\\n      for (const checkout of (expiredCheckouts.results || [])) {\\\\n        try {\\\\n          // Delete from Whop\\\\n          const deleteResponse = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {\\\\n            method: \\\'DELETE\\\',\\\\n            headers: {\\\\n              \\\'Authorization\\\': `Bearer ${env.WHOP_API_KEY}`\\\\n            }\\\\n          });\\\\n          \\\\n          if (deleteResponse.ok || deleteResponse.status === 404) {\\\\n            // Mark as expired in database\\\\n            await env.DB.prepare(`\\\\n              UPDATE checkout_sessions \\\\n              SET status = \\\'expired\\\', completed_at = datetime(\\\'now\\\')\\\\n              WHERE checkout_id = ?\\\\n            `).bind(checkout.checkout_id).run();\\\\n            \\\\n            deleted++;\\\\n            console.log(\\\'\\\\ud83d\\\\uddd1\\\\ufe0f Expired checkout deleted:\\\', checkout.checkout_id);\\\\n          } else {\\\\n            failed++;\\\\n            console.error(\\\'Failed to delete checkout:\\\', checkout.checkout_id, deleteResponse.status);\\\\n          }\\\\n        } catch (e) {\\\\n          failed++;\\\\n          console.error(\\\'Error deleting checkout:\\\', checkout.checkout_id, e.message);\\\\n        }\\\\n      }\\\\n      \\\\n      console.log(`\\\\u2705 Cleanup complete: ${deleted} deleted, ${failed} failed`);\\\\n    } catch (err) {\\\\n      console.error(\\\'Scheduled cleanup error:\\\', err);\\\\n    }\\\\n  }\\\\n};\\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace"\\n}\') </execute-command> </tool_result>'}