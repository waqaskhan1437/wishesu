{'role': 'assistant', 'content': '\nNow let me create the helper functions in `src/utils/helpers.js`:\n\n<function_calls>\n<create-file file_path="src/utils/helpers.js">\n// Helper functions for Cloudflare Workers\n\n/**\n * Escape HTML to prevent XSS attacks\n * @param {string} input - Input string\n * @returns {string} Escaped HTML string\n */\nexport function escapeHtml(input) {\n  return String(input ?? \'\')\n    .replaceAll(\'&\', \'&amp;\')\n    .replaceAll(\'<\', \'&lt;\')\n    .replaceAll(\'>\', \'&gt;\')\n    .replaceAll(\'"\', \'&quot;\')\n    .replaceAll("\'", \'&#39;\');\n}\n\n/**\n * Normalize quick action text for comparison\n * @param {string} text - Input text\n * @returns {string} Normalized text\n */\nexport function normalizeQuickAction(text) {\n  return String(text || \'\')\n    .trim()\n    .replace(/\\s+/g, \' \')\n    .toLowerCase();\n}\n\n/**\n * Get MIME type from filename extension\n * @param {string} filename - Filename\n * @returns {string} MIME type\n */\nexport function getMimeTypeFromFilename(filename) {\n  const ext = (filename || \'\').split(\'.\').pop()?.toLowerCase();\n  switch (ext) {\n    case \'mp4\':\n      return \'video/mp4\';\n    case \'webm\':\n      return \'video/webm\';\n    case \'mov\':\n      return \'video/quicktime\';\n    case \'m4v\':\n      return \'video/x-m4v\';\n    case \'mkv\':\n      return \'video/x-matroska\';\n    case \'avi\':\n      return \'video/x-msvideo\';\n    case \'wmv\':\n      return \'video/x-ms-wmv\';\n    case \'flv\':\n      return \'video/x-flv\';\n    case \'jpg\':\n    case \'jpeg\':\n      return \'image/jpeg\';\n    case \'png\':\n      return \'image/png\';\n    case \'gif\':\n      return \'image/gif\';\n    case \'webp\':\n      return \'image/webp\';\n    case \'svg\':\n      return \'image/svg+xml\';\n    case \'pdf\':\n      return \'application/pdf\';\n    case \'zip\':\n      return \'application/zip\';\n    default:\n      return \'\';\n  }\n}\n\n/**\n * Resolve content type from request headers and filename\n * @param {Request} req - Request object\n * @param {string} filename - Filename\n * @returns {string} Content type\n */\nexport function resolveContentType(req, filename) {\n  const headerContentType = (req.headers.get(\'content-type\') || \'\').split(\';\')[0].trim().toLowerCase();\n  if (headerContentType && headerContentType !== \'application/octet-stream\') {\n    return headerContentType;\n  }\n  return getMimeTypeFromFilename(filename) || headerContentType || \'application/octet-stream\';\n}\n\n/**\n * Normalize archive metadata value\n * @param {string} value - Metadata value\n * @returns {string} Normalized value\n */\nexport function normalizeArchiveMetaValue(value) {\n  return (value || \'\').toString().replace(/[\\r\\n\\t]+/g, \' \').trim();\n}\n\n/**\n * Slugify string for URLs\n * @param {string} input - Input string\n * @returns {string} Slugified string\n */\nexport function slugifyStr(input) {\n  return String(input || \'\')\n    .toLowerCase()\n    .trim()\n    .replace(/[\'"`]/g, \'\')\n    .replace(/[^a-z0-9]+/g, \'-\')\n    .replace(/^-+|-+$/g, \'\')\n    .replace(/-+/g, \'-\');\n}\n\n/**\n * Generate canonical product path\n * @param {Object} product - Product object\n * @returns {string} Canonical path\n */\nexport function canonicalProductPath(product) {\n  const id = product && product.id != null ? String(product.id) : \'\';\n  const slug = (product && product.slug) ? String(product.slug) : slugifyStr(product && product.title ? product.title : \'product\');\n  return `/product-${id}/${encodeURIComponent(slug)}`;\n}\n\n/**\n * Enforce user rate limit (1 message per second)\n * @param {Object} env - Environment bindings\n * @param {string} sessionId - Chat session ID\n * @returns {Promise<void>}\n */\nexport async function enforceUserRateLimit(env, sessionId) {\n  const row = await env.DB.prepare(\n    `SELECT strftime(\'%s\', created_at) AS ts\n     FROM chat_messages\n     WHERE session_id = ? AND role = \'user\'\n     ORDER BY id DESC\n     LIMIT 1`\n  ).bind(sessionId).first();\n\n  if (!row?.ts) return;\n\n  const lastTs = Number(row.ts) || 0;\n  const nowTs = Math.floor(Date.now() / 1000);\n\n  if (nowTs - lastTs < 1) {\n    const err = new Error(\'Rate limited\');\n    err.status = 429;\n    throw err;\n  }\n}\n\n/**\n * Get latest order for email\n * @param {Object} env - Environment bindings\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} Latest order or null\n */\nexport async function getLatestOrderForEmail(env, email) {\n  const candidates = await env.DB.prepare(\n    `SELECT order_id, status, archive_url, encrypted_data, created_at\n     FROM orders\n     ORDER BY datetime(created_at) DESC\n     LIMIT 80`\n  ).all();\n\n  const list = candidates?.results || [];\n  const target = String(email || \'\').trim().toLowerCase();\n  if (!target) return null;\n\n  for (const o of list) {\n    try {\n      if (!o.encrypted_data) continue;\n      const data = JSON.parse(o.encrypted_data);\n      const e = String(data.email || \'\').trim().toLowerCase();\n      if (e && e === target) {\n        return {\n          order_id: o.order_id,\n          status: o.status,\n          trackLink: `/buyer-order.html?id=${encodeURIComponent(o.order_id)}`\n        };\n      }\n    } catch {}\n  }\n  return null;\n}\n\n/**\n * Get Whop API key from database or environment\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} API key or null\n */\nexport async function getWhopApiKey(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.api_key) {\n          return settings.api_key;\n        }\n      }\n    }\n  } catch (e) {\n    console.error(\'Error reading API key from database:\', e);\n  }\n  // Fallback to environment variable\n  return env.WHOP_API_KEY || null;\n}\n\n/**\n * Get Whop webhook secret from database or environment\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} Webhook secret or null\n */\nexport async function getWhopWebhookSecret(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.webhook_secret) {\n          return settings.webhook_secret;\n        }\n      }\n    }\n  } catch (e) {\n    console.error(\'Error reading webhook secret from database:\', e);\n  }\n  // Fallback to environment variable\n  return env.WHOP_WEBHOOK_SECRET || null;\n}\n\n/**\n * Get Google Apps Script URL from database settings\n * @param {Object} env - Environment bindings\n * @returns {Promise<string|null>} Script URL or null\n */\nexport async function getGoogleScriptUrl(env) {\n  try {\n    if (env.DB) {\n      const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n      if (row && row.value) {\n        const settings = JSON.parse(row.value);\n        if (settings.google_webapp_url) {\n          return settings.google_webapp_url;\n        }\n      }\n    }\n  } catch (e) {\n    console.warn(\'Error reading Google Script URL from database:\', e);\n  }\n  return null;\n}\n\n/**\n * Helper function to generate Offer object for Product schemas\n * @param {Object} product - Product data\n * @param {string} baseUrl - Site base URL\n * @returns {Object} Offer schema\n */\nexport function generateOfferObject(product, baseUrl) {\n  const price = parseFloat(product.sale_price || product.normal_price || 0);\n  const date = new Date();\n  date.setFullYear(date.getFullYear() + 1);\n  const priceValidUntil = date.toISOString().split(\'T\')[0];\n  \n  // Check if product is digital (instant_delivery = 1 means digital/no shipping)\n  const isDigital = product.instant_delivery === 1;\n\n  const offer = {\n    "@type": "Offer",\n    "url": `${baseUrl}${canonicalProductPath(product)}`,\n    "priceCurrency": "USD",\n    "price": price.toString(),\n    "availability": "https://schema.org/InStock",\n    "itemCondition": "https://schema.org/NewCondition",\n    "priceValidUntil": priceValidUntil,\n    "seller": {\n      "@type": "Organization",\n      "name": "WishVideo"\n    }\n  };\n\n  // Only add shipping details for physical products (non-digital)\n  if (!isDigital) {\n    offer.shippingDetails = {\n      "@type": "OfferShippingDetails",\n      "shippingDestination": [\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "US"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "GB"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "CA"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "AU"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "DE"\n        },\n        {\n          "@type": "DefinedRegion",\n          "addressCountry": "FR"\n        }\n      ],\n      "shippingRate": {\n        "@type": "MonetaryAmount",\n        "currency": "USD",\n        "value": "0"\n      },\n      "deliveryTime": {\n        "@type": "ShippingDeliveryTime",\n        "handlingTime": {\n          "@type": "QuantitativeValue",\n          "minValue": 0,\n          "maxValue": 1,\n          "unitCode": "DAY"\n        },\n        "transitTime": {\n          "@type": "QuantitativeValue",\n          "minValue": 1,\n          "maxValue": 3,\n          "unitCode": "DAY"\n        }\n      }\n    };\n    \n    offer.hasMerchantReturnPolicy = {\n      "@type": "MerchantReturnPolicy",\n      "applicableCountry": "US",\n      "returnPolicyCategory": "MerchantReturnNotPermitted",\n      "merchantReturnDays": 0\n    };\n  }\n\n  return offer;\n}\n\n/**\n * Generate Product schema for individual product pages\n * @param {Object} product - Product data from database\n * @param {string} baseUrl - Site base URL\n * @param {Array} reviews - Individual reviews for this product\n * @returns {string} JSON-LD schema as string\n */\nexport function generateProductSchema(product, baseUrl, reviews = []) {\n  const sku = product.slug ? `WV-${product.id}-${product.slug.toUpperCase().replace(/-/g, \'\')}` : `WV-${product.id}`;\n\n  const schema = {\n    "@context": "https://schema.org/",\n    "@type": "Product",\n    "@id": `${baseUrl}${canonicalProductPath(product)}`,\n    "name": product.title,\n    "description": product.seo_description || product.description || product.title,\n    "sku": sku,\n    "mpn": sku,\n    "image": product.thumbnail_url ? [product.thumbnail_url] : [],\n    "brand": {\n      "@type": "Brand",\n      "name": "WishVideo",\n      "logo": `${baseUrl}/favicon.ico`\n    },\n    "manufacturer": {\n      "@type": "Organization",\n      "name": "WishVideo",\n      "url": baseUrl\n    },\n    "category": "Digital Goods > Personalized Videos",\n    "offers": generateOfferObject(product, baseUrl)\n  };\n\n   // Add aggregateRating (always present, even with 0 reviews for better Rich Results)\n   schema.aggregateRating = {\n     "@type": "AggregateRating",\n     "ratingValue": parseFloat(product.rating_average) || 5.0,\n     "reviewCount": Math.max(1, parseInt(product.review_count) || 1),\n     "bestRating": 5,\n     "worstRating": 1\n   };\n\n   // Add individual reviews (first 5 for Rich Results)\n   if (reviews && reviews.length > 0) {\n     const limitedReviews = reviews.slice(0, 5);\n     schema.review = limitedReviews.map(review => ({\n      "@type": "Review",\n      "reviewRating": {\n        "@type": "Rating",\n        "ratingValue": review.rating,\n        "bestRating": 5,\n        "worstRating": 1\n      },\n      "author": {\n        "@type": "Person",\n        "name": review.author_name || "Customer"\n      },\n      "reviewBody": review.comment || "",\n      "datePublished": review.created_at ? new Date(review.created_at).toISOString().split(\'T\')[0] : new Date().toISOString().split(\'T\')[0]\n    }));\n  }\n\n  return JSON.stringify(schema);\n}\n\n/**\n * Generate ItemList schema for product collection pages\n * @param {Array} products - Array of product data\n * @param {string} baseUrl - Site base URL\n * @returns {string} JSON-LD schema as string\n */\nexport function generateCollectionSchema(products, baseUrl) {\n  if (!products || products.length === 0) {\n    return \'{}\';\n  }\n\n  const itemListElement = products.map((product, index) => {\n    const item = {\n      "@type": "ListItem",\n      "position": index + 1,\n      "url": `${baseUrl}${canonicalProductPath(product)}`,\n      "item": {\n        "@type": "Product",\n        "@id": `${baseUrl}${canonicalProductPath(product)}`,\n        "name": product.title,\n        "description": product.description || product.title,\n        "image": product.thumbnail_url || `${baseUrl}/placeholder.jpg`,\n        "brand": {\n          "@type": "Brand",\n          "name": "WishVideo"\n        },\n        "offers": generateOfferObject(product, baseUrl)\n      }\n    };\n\n    // Add aggregateRating (always present for better Rich Results)\n    item.item.aggregateRating = {\n      "@type": "AggregateRating",\n      "ratingValue": parseFloat(product.rating_average) || 5.0,\n      "reviewCount": Math.max(1, parseInt(product.review_count) || 1),\n      "bestRating": 5,\n      "worstRating": 1\n    };\n\n    return item;\n  });\n\n  const schema = {\n    "@context": "https://schema.org/",\n    "@type": "ItemList",\n    "itemListElement": itemListElement\n  };\n\n  return JSON.stringify(schema);\n}\n\n/**\n * Inject schema into HTML by replacing placeholder\n * @param {string} html - Original HTML content\n * @param {string} schemaId - ID of schema tag (product-schema or collection-schema)\n * @param {string} schemaJson - JSON-LD schema string\n * @returns {string} Modified HTML with schema injected\n */\nexport function injectSchemaIntoHTML(html, schemaId, schemaJson) {\n  // Replace empty schema placeholder with actual data\n  const placeholder = `<script type="application/ld+json" id="${schemaId}">{}</script>`;\n  const replacement = `<script type="application/ld+json" id="${schemaId}">${schemaJson}</script>`;\n  return html.replace(placeholder, replacement);\n}\n</create-file>\n</function_calls>'}