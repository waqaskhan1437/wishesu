{'role': 'assistant', 'content': '\nNow let me create the reviews controller in `src/controllers/reviews.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/reviews.js">\n// Reviews API controller\nimport { json } from \'../utils/response.js\';\n\n/**\n * Get all reviews with optional filtering\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function getReviews(env, url) {\n  // Support filtering by productId(s), ids and rating via query parameters.\n  const params = url.searchParams;\n  const rating = params.get(\'rating\');\n  const productId = params.get(\'productId\');\n  const productIds = params.get(\'productIds\');\n  const ids = params.get(\'ids\');\n  let sql = \'SELECT r.*, p.title as product_title FROM reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.status = ?\';\n  /**\n   * Bind values can be strings or numbers.  TypeScript incorrectly infers\n   * this array as `string[]` because the first value is a string, which causes\n   * type errors when numbers are pushed.  Annotate the type explicitly to\n   * avoid type errors in the Cloudflare editor.\n   * @type {(string|number)[]}\n   */\n  const binds = [\'approved\'];\n  // Filter by rating\n  if (rating) {\n    sql += \' AND r.rating = ?\';\n    binds.push(Number(rating));\n  }\n  // Filter by single product\n  if (productId) {\n    sql += \' AND r.product_id = ?\';\n    binds.push(Number(productId));\n  }\n  // Filter by multiple products\n  if (productIds) {\n    const idsArr = productIds.split(\',\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\n    if (idsArr.length > 0) {\n      sql += ` AND r.product_id IN (${idsArr.map(() => \'?\').join(\',\')})`;\n      binds.push(...idsArr);\n    }\n  }\n  // Filter by specific review IDs\n  if (ids) {\n    const idsArr2 = ids.split(\',\').map(id => parseInt(id, 10)).filter(n => !isNaN(n));\n    if (idsArr2.length > 0) {\n      sql += ` AND r.id IN (${idsArr2.map(() => \'?\').join(\',\')})`;\n      binds.push(...idsArr2);\n    }\n  }\n  sql += \' ORDER BY r.created_at DESC\';\n  const stmt = await env.DB.prepare(sql);\n  const r = await stmt.bind(...binds).all();\n\n  // Convert created_at to ISO 8601 format with Z suffix for UTC\n  const reviews = (r.results || []).map(review => {\n    if (review.created_at && typeof review.created_at === \'string\') {\n      review.created_at = review.created_at.replace(\' \', \'T\') + \'Z\';\n    }\n    return review;\n  });\n\n  return json({ reviews });\n}\n\n/**\n * Get reviews for a specific product\n * @param {Object} env - Environment bindings\n * @param {string} productId - Product ID\n * @returns {Promise<Response>}\n */\nexport async function getProductReviews(env, productId) {\n   const r = await env.DB.prepare(\n     `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url \n      FROM reviews \n      LEFT JOIN orders ON reviews.order_id = orders.order_id \n      WHERE reviews.product_id = ? AND reviews.status = ? \n      ORDER BY reviews.created_at DESC`\n   ).bind(Number(productId), \'approved\').all();\n\n   // Convert created_at to ISO 8601 format with Z suffix for UTC\n   const reviews = (r.results || []).map(review => {\n     if (review.created_at && typeof review.created_at === \'string\') {\n       review.created_at = review.created_at.replace(\' \', \'T\') + \'Z\';\n     }\n     return review;\n   });\n\n   return json({ reviews });\n}\n\n/**\n * Add a new review\n * @param {Object} env - Environment bindings\n * @param {Object} body - Review data\n * @returns {Promise<Response>}\n */\nexport async function addReview(env, body) {\n  if (!body.productId || !body.rating) return json({ error: \'productId and rating required\' }, 400);\n  \n  await env.DB.prepare(\n    \'INSERT INTO reviews (product_id, author_name, rating, comment, status, order_id, show_on_product) VALUES (?, ?, ?, ?, ?, ?, ?)\'\n  ).bind(Number(body.productId), body.author || \'Customer\', Number(body.rating), body.comment || \'\', \'approved\', body.orderId || null, body.showOnProduct !== undefined ? (body.showOnProduct ? 1 : 0) : 1).run();\n  \n  return json({ success: true });\n}\n\n/**\n * Update a review\n * @param {Object} env - Environment bindings\n * @param {Object} body - Update data\n * @returns {Promise<Response>}\n */\nexport async function updateReview(env, body) {\n  const id = Number(body.id);\n  \n  // Build dynamic update query based on provided fields\n  const updates = [];\n  const values = [];\n  \n  if (body.status !== undefined) {\n    updates.push(\'status = ?\');\n    values.push(body.status);\n  }\n  if (body.author_name !== undefined) {\n    updates.push(\'author_name = ?\');\n    values.push(body.author_name);\n  }\n  if (body.rating !== undefined) {\n    updates.push(\'rating = ?\');\n    values.push(Number(body.rating));\n  }\n  if (body.comment !== undefined) {\n    updates.push(\'comment = ?\');\n    values.push(body.comment);\n  }\n  if (body.show_on_product !== undefined) {\n    updates.push(\'show_on_product = ?\');\n    values.push(Number(body.show_on_product));\n  }\n  \n  if (updates.length === 0) {\n    return json({ error: \'No fields to update\' }, 400);\n  }\n  \n  values.push(id);\n  await env.DB.prepare(`UPDATE reviews SET ${updates.join(\', \')} WHERE id = ?`).bind(...values).run();\n  return json({ success: true });\n}\n\n/**\n * Delete a review\n * @param {Object} env - Environment bindings\n * @param {string} id - Review ID\n * @returns {Promise<Response>}\n */\nexport async function deleteReview(env, id) {\n  await env.DB.prepare(\'DELETE FROM reviews WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n</create-file>\n</function_calls>'}