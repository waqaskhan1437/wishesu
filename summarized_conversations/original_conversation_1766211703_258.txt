{'role': 'assistant', 'content': '\nNow let me create the upload controller in `src/controllers/upload.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/upload.js">\n// Upload API controller\nimport { json } from \'../utils/response.js\';\nimport { getMimeTypeFromFilename, resolveContentType, normalizeArchiveMetaValue } from \'../utils/helpers.js\';\n\n/**\n * Upload temporary file to R2\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadTempFile(env, req, url) {\n  try {\n    if (!env.R2_BUCKET) {\n      console.error(\'R2_BUCKET not configured\');\n      return json({ error: \'R2 storage not configured\' }, 500);\n    }\n\n    const sessionId = url.searchParams.get(\'sessionId\');\n    const filename = url.searchParams.get(\'filename\');\n\n    if (!sessionId || !filename) {\n      console.error(\'Missing sessionId or filename\');\n      return json({ error: \'sessionId and filename required\' }, 400);\n    }\n\n    console.log(\'Uploading file:\', filename, \'for session:\', sessionId);\n\n    const buf = await req.arrayBuffer();\n\n    // Validate file size (max 500MB for videos, 10MB for other files)\n    const isVideo = filename.toLowerCase().match(/\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);\n    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024; // 500MB for videos, 10MB for others\n    const maxSizeLabel = isVideo ? \'500MB\' : \'10MB\';\n    \n    if (buf.byteLength > maxSize) {\n      console.error(\'File too large:\', buf.byteLength, \'bytes (max\', maxSizeLabel, \')\');\n      return json({\n        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \'videos\' : \'files\'}.`,\n        fileSize: buf.byteLength,\n        maxSize: maxSize,\n        fileType: isVideo ? \'video\' : \'file\'\n      }, 400);\n    }\n\n    if (!buf || buf.byteLength === 0) {\n      console.error(\'Empty file buffer\');\n      return json({ error: \'Empty file - please select a valid file\' }, 400);\n    }\n\n    console.log(\'File size:\', (buf.byteLength / 1024 / 1024).toFixed(2), \'MB\');\n\n    const key = `temp/${sessionId}/${filename}`;\n\n    await env.R2_BUCKET.put(key, buf, {\n      httpMetadata: { contentType: req.headers.get(\'content-type\') || \'application/octet-stream\' }\n    });\n\n    console.log(\'File uploaded successfully:\', key);\n\n    return json({ success: true, tempUrl: `r2://${key}` });\n  } catch (err) {\n    console.error(\'Upload error:\', err);\n    return json({\n      error: \'Upload failed: \' + err.message,\n      details: err.stack\n    }, 500);\n  }\n}\n\n/**\n * Get file from R2\n * @param {Object} env - Environment bindings\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function getR2File(env, url) {\n  if (!env.R2_BUCKET) return json({ error: \'R2 not configured\' }, 500);\n  \n  const key = url.searchParams.get(\'key\');\n  if (!key) return json({ error: \'key required\' }, 400);\n  \n  const obj = await env.R2_BUCKET.get(key);\n  if (!obj) return json({ error: \'File not found\' }, 404);\n  \n  return new Response(obj.body, {\n    headers: {\n      \'Content-Type\': obj.httpMetadata?.contentType || \'application/octet-stream\',\n      \'Cache-Control\': \'public, max-age=3600\'\n    }\n  });\n}\n\n/**\n * Upload customer file (delivery video) with two-stage process\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {URL} url - Request URL with query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadCustomerFile(env, req, url) {\n  try {\n    if (!env.R2_BUCKET) {\n      console.error(\'R2_BUCKET not configured\');\n      return json({ error: \'R2 storage not configured\' }, 500);\n    }\n\n    if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {\n      console.error(\'Archive.org credentials not configured\');\n      return json({ error: \'Archive.org credentials not configured\' }, 500);\n    }\n\n    const itemId = (url.searchParams.get(\'itemId\') || \'\').replace(/[^a-zA-Z0-9_.-]/g, \'-\');\n    const filename = (url.searchParams.get(\'filename\') || \'\').replace(/[^a-zA-Z0-9_.-]/g, \'-\');\n    const originalFilename = url.searchParams.get(\'originalFilename\');\n\n    if (!itemId || !filename) {\n      console.error(\'Missing itemId or filename\');\n      return json({ error: \'itemId and filename required\' }, 400);\n    }\n\n    console.log(\'Starting two-stage upload:\', filename, \'Item:\', itemId);\n\n    const buf = await req.arrayBuffer();\n\n    // Validate file size (max 500MB for videos, 10MB for other files)\n    const videoExtensions = /\\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;\n    const isVideo = videoExtensions.test(filename);\n    const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;\n    const maxSizeLabel = isVideo ? \'500MB\' : \'10MB\';\n    \n    if (buf.byteLength > maxSize) {\n      console.error(\'File too large:\', buf.byteLength, \'bytes (max\', maxSizeLabel, \')\');\n      return json({\n        error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? \'videos\' : \'files\'}.`,\n        fileSize: buf.byteLength,\n        maxSize: maxSize,\n        fileType: isVideo ? \'video\' : \'file\'\n      }, 400);\n    }\n\n    if (buf.byteLength === 0) {\n      console.error(\'Empty file\');\n      return json({ error: \'Empty file - please select a valid file\' }, 400);\n    }\n\n    console.log(\'File size:\', (buf.byteLength / 1024 / 1024).toFixed(2), \'MB\');\n\n    // Force video MIME type for video files\n    const contentType = isVideo \n      ? (getMimeTypeFromFilename(filename) || \'video/mp4\')\n      : resolveContentType(req, filename);\n    const isVideoUpload = isVideo;\n\n    // STAGE 1: Upload to R2 temp bucket for verification\n    console.log(\'STAGE 1: Uploading to R2 temp bucket...\');\n    const r2TempKey = `temp/${itemId}/${filename}`;\n    try {\n      await env.R2_BUCKET.put(r2TempKey, buf, {\n        httpMetadata: { contentType: contentType }\n      });\n      console.log(\'R2 temp upload successful:\', r2TempKey);\n    } catch (r2Err) {\n      console.error(\'R2 temp upload failed:\', r2Err);\n      return json({\n        error: \'Failed to upload to temp storage: \' + r2Err.message,\n        stage: \'r2-temp\',\n        details: r2Err.stack\n      }, 500);\n    }\n\n    // Verify R2 file exists\n    console.log(\'Verifying R2 temp upload...\');\n    let r2File;\n    try {\n      r2File = await env.R2_BUCKET.get(r2TempKey);\n      if (!r2File) {\n        throw new Error(\'File not found in R2 after upload\');\n      }\n      console.log(\'R2 verification successful\');\n    } catch (verifyErr) {\n      console.error(\'R2 verification failed:\', verifyErr);\n      return json({\n        error: \'R2 upload verification failed: \' + verifyErr.message,\n        stage: \'r2-verify\',\n        details: verifyErr.stack\n      }, 500);\n    }\n\n    // Get order details for Archive.org metadata\n    const orderIdFromQuery = url.searchParams.get(\'orderId\');\n    let resolvedOrderId = orderIdFromQuery;\n    if (!resolvedOrderId) {\n      const match = itemId.match(/^delivery_(.+?)_\\d+$/);\n      if (match) {\n        resolvedOrderId = match[1];\n      }\n    }\n\n    let archiveDescription = \'\';\n    if (resolvedOrderId) {\n      try {\n        const orderRow = await env.DB.prepare(\n          \'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\'\n        ).bind(resolvedOrderId).first();\n\n        if (orderRow) {\n          const productTitle = orderRow.product_title || \'\';\n          const productDescription = orderRow.product_description || \'\';\n\n          if (productDescription) {\n            archiveDescription = productTitle\n              ? `${productTitle} - ${productDescription}`\n              : productDescription;\n          } else {\n            archiveDescription = `Order #${orderRow.order_id} - ${productTitle || \'Video Delivery\'}`;\n          }\n        } else {\n          archiveDescription = `Order #${resolvedOrderId} video delivery`;\n        }\n      } catch (dbErr) {\n        console.warn(\'Could not fetch order details:\', dbErr);\n        archiveDescription = `Order #${resolvedOrderId} video delivery`;\n      }\n    } else {\n      archiveDescription = `${isVideoUpload ? \'Video\' : \'File\'} uploaded via order delivery system`;\n    }\n\n    const archiveHeaders = {\n      Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,\n      \'Content-Type\': contentType,\n      \'x-archive-auto-make-bucket\': \'1\',\n      \'x-archive-meta-mediatype\': isVideoUpload ? \'movies\' : \'data\',\n      \'x-archive-meta-collection\': isVideoUpload ? \'opensource_movies\' : \'opensource\',\n      \'x-archive-meta-title\': normalizeArchiveMetaValue(originalFilename || filename),\n      \'x-archive-meta-description\': normalizeArchiveMetaValue(archiveDescription),\n      \'x-archive-meta-subject\': \'video; delivery\',\n      \'x-archive-meta-language\': \'eng\'\n    };\n\n    console.log(\'Archive.org Upload Metadata:\', {\n      isVideo: isVideo,\n      isVideoUpload: isVideoUpload,\n      contentType: contentType,\n      mediatype: archiveHeaders[\'x-archive-meta-mediatype\'],\n      filename: filename,\n      itemId: itemId\n    });\n\n    // STAGE 2: Upload to Archive.org\n    console.log(\'STAGE 2: Uploading to Archive.org...\');\n    const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;\n    let archiveResp;\n    try {\n      archiveResp = await fetch(archiveUrl, {\n        method: \'PUT\',\n        headers: archiveHeaders,\n        body: buf\n      });\n\n      if (!archiveResp.ok) {\n        const errorText = await archiveResp.text().catch(() => \'Unknown error\');\n        console.error(\'Archive.org upload failed:\', archiveResp.status, errorText);\n        return json({\n          error: \'Archive.org upload failed\',\n          status: archiveResp.status,\n          details: errorText,\n          stage: \'archive-upload\',\n          r2Uploaded: true\n        }, 502);\n      }\n      console.log(\'Archive.org upload successful, status:\', archiveResp.status);\n    } catch (archiveErr) {\n      console.error(\'Archive.org upload network error:\', archiveErr);\n      return json({\n        error: \'Failed to connect to Archive.org: \' + archiveErr.message,\n        stage: \'archive-connect\',\n        details: archiveErr.message,\n        r2Uploaded: true\n      }, 502);\n    }\n\n    // STAGE 3: Wait for Archive.org to index the file\n    console.log(\'STAGE 3: Waiting for Archive.org indexing...\');\n    await new Promise(resolve => setTimeout(resolve, 3000));\n\n    // STAGE 4: Verify Archive.org file is accessible\n    console.log(\'STAGE 4: Verifying Archive.org file...\');\n    const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;\n    const embedUrl = `https://archive.org/details/${itemId}`;\n    \n    let verifyAttempts = 0;\n    const maxVerifyAttempts = 3;\n    let archiveVerified = false;\n\n    while (verifyAttempts < maxVerifyAttempts && !archiveVerified) {\n      verifyAttempts++;\n      try {\n        const verifyResp = await fetch(downloadUrl, { method: \'HEAD\' });\n        if (verifyResp.ok) {\n          console.log(\'Archive.org file verified at attempt\', verifyAttempts);\n          archiveVerified = true;\n          break;\n        } else if (verifyResp.status === 404 && verifyAttempts < maxVerifyAttempts) {\n          console.log(`Archive.org file not yet available (attempt ${verifyAttempts}/${maxVerifyAttempts}), waiting...`);\n          await new Promise(resolve => setTimeout(resolve, 2000));\n        } else {\n          console.warn(`Archive.org verification returned status ${verifyResp.status}`);\n          break;\n        }\n      } catch (verifyErr) {\n        console.warn(`Archive.org verification attempt ${verifyAttempts} failed:`, verifyErr.message);\n        if (verifyAttempts < maxVerifyAttempts) {\n          await new Promise(resolve => setTimeout(resolve, 2000));\n        }\n      }\n    }\n\n    if (!archiveVerified) {\n      console.warn(\'Archive.org file could not be verified, but upload was successful\');\n    }\n\n    console.log(\'Upload complete - both R2 and Archive.org successful\');\n    return json({ \n      success: true, \n      url: downloadUrl,\n      embedUrl: embedUrl,\n      itemId: itemId,\n      filename: filename,\n      r2Verified: true,\n      archiveVerified: archiveVerified,\n      isVideo: isVideoUpload\n    });\n\n  } catch (err) {\n    console.error(\'Customer file upload error:\', err);\n    return json({\n      error: \'Upload failed: \' + err.message,\n      details: err.stack,\n      stage: \'unknown\'\n    }, 500);\n  }\n}\n</create-file>\n</function_calls>'}