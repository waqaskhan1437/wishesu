{'role': 'assistant', 'content': '\nNow let me create the orders controller in `src/controllers/orders.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/orders.js">\n// Orders API controller\nimport { json } from \'../utils/response.js\';\nimport { getGoogleScriptUrl } from \'../utils/helpers.js\';\n\n/**\n * Get all orders\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getOrders(env) {\n  const r = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n  const orders = (r.results || []).map(row => {\n    let email = \'\', amount = null, addons = [];\n    try {\n      if (row.encrypted_data && row.encrypted_data[0] === \'{\') {\n        const d = JSON.parse(row.encrypted_data);\n        email = d.email || \'\';\n        amount = d.amount;\n        addons = d.addons || [];\n      }\n    } catch(e) {\n      console.error(\'Failed to parse order encrypted_data for order:\', row.order_id, e.message);\n    }\n    return { ...row, email, amount, addons };\n  });\n  return json({ orders });\n}\n\n/**\n * Create a new order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Order data\n * @returns {Promise<Response>}\n */\nexport async function createOrder(env, body) {\n  if (!body.productId) return json({ error: \'productId required\' }, 400);\n  \n  const orderId = body.orderId || crypto.randomUUID().split(\'-\')[0].toUpperCase();\n  const data = JSON.stringify({\n    email: body.email,\n    amount: body.amount,\n    productId: body.productId,\n    addons: body.addons || []\n  });\n  \n  await env.DB.prepare(\n    \'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(orderId, Number(body.productId), data, \'PAID\', Number(body.deliveryTime) || 60).run();\n  \n  return json({ success: true, orderId });\n}\n\n/**\n * Get buyer order details\n * @param {Object} env - Environment bindings\n * @param {string} orderId - Order ID\n * @returns {Promise<Response>}\n */\nexport async function getBuyerOrder(env, orderId) {\n   const row = await env.DB.prepare(\n     \'SELECT o.*, p.title as product_title, p.thumbnail_url as product_thumbnail FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?\'\n   ).bind(orderId).first();\n\n   if (!row) return json({ error: \'Order not found\' }, 404);\n\n   // Check if review already exists for this order\n   const reviewCheck = await env.DB.prepare(\n     \'SELECT id FROM reviews WHERE order_id = ? LIMIT 1\'\n   ).bind(orderId).first();\n   const hasReview = !!reviewCheck;\n\n   let addons = [], email = \'\', amount = null;\n   try {\n     if (row.encrypted_data && row.encrypted_data[0] === \'{\') {\n       const d = JSON.parse(row.encrypted_data);\n       addons = d.addons || [];\n       email = d.email || \'\';\n       amount = d.amount;\n     }\n   } catch(e) {\n     console.error(\'Failed to parse order encrypted_data for buyer order:\', orderId, e.message);\n   }\n\n   // Convert SQLite datetime to ISO 8601 format with Z suffix for UTC\n   const orderData = { ...row, addons, email, amount, has_review: hasReview };\n   if (orderData.created_at && typeof orderData.created_at === \'string\') {\n     // SQLite format: YYYY-MM-DD HH:MM:SS -> ISO 8601: YYYY-MM-DDTHH:MM:SSZ\n     orderData.created_at = orderData.created_at.replace(\' \', \'T\') + \'Z\';\n   }\n\n   return json({ order: orderData });\n}\n\n/**\n * Delete an order\n * @param {Object} env - Environment bindings\n * @param {string} id - Order ID\n * @returns {Promise<Response>}\n */\nexport async function deleteOrder(env, id) {\n  await env.DB.prepare(\'DELETE FROM orders WHERE id = ?\').bind(Number(id)).run();\n  return json({ success: true });\n}\n\n/**\n * Update an order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Update data\n * @returns {Promise<Response>}\n */\nexport async function updateOrder(env, body) {\n  const orderId = body.orderId;\n  \n  if (!orderId) return json({ error: \'orderId required\' }, 400);\n  \n  const updates = [];\n  const values = [];\n  \n  if (body.status !== undefined) {\n    updates.push(\'status = ?\');\n    values.push(body.status);\n  }\n  if (body.delivery_time_minutes !== undefined) {\n    updates.push(\'delivery_time_minutes = ?\');\n    values.push(Number(body.delivery_time_minutes));\n  }\n  \n  if (updates.length === 0) {\n    return json({ error: \'No fields to update\' }, 400);\n  }\n  \n  values.push(orderId);\n  await env.DB.prepare(`UPDATE orders SET ${updates.join(\', \')} WHERE order_id = ?`).bind(...values).run();\n  return json({ success: true });\n}\n\n/**\n * Create manual order (admin)\n * @param {Object} env - Environment bindings\n * @param {Object} body - Order data\n * @returns {Promise<Response>}\n */\nexport async function createManualOrder(env, body) {\n  if (!body.productId || !body.email) {\n    return json({ error: \'productId and email required\' }, 400);\n  }\n  \n  // Generate unique order ID\n  const orderId = \'MO\' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 6).toUpperCase();\n  \n  // Store order data\n  const encryptedData = JSON.stringify({\n    email: body.email,\n    amount: body.amount || 0,\n    addons: body.notes ? [{ field: \'Admin Notes\', value: body.notes }] : [],\n    manualOrder: true\n  });\n  \n  await env.DB.prepare(\n    \'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)\'\n  ).bind(\n    orderId,\n    Number(body.productId),\n    encryptedData,\n    body.status || \'paid\',\n    Number(body.deliveryTime) || 60\n  ).run();\n  \n  return json({ success: true, orderId });\n}\n\n/**\n * Deliver video to order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Delivery data\n * @returns {Promise<Response>}\n */\nexport async function deliverOrder(env, body) {\n  if (!body.orderId || !body.videoUrl) return json({ error: \'orderId and videoUrl required\' }, 400);\n\n  // Get order data before updating\n  const orderResult = await env.DB.prepare(\n    \'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\'\n  ).bind(body.orderId).first();\n\n  // Prepare additional metadata for delivered videos (Archive.org + subtitles, etc)\n  const deliveredVideoMetadata = JSON.stringify({\n    embedUrl: body.embedUrl,\n    itemId: body.itemId,\n    subtitlesUrl: body.subtitlesUrl,\n    tracks: Array.isArray(body.tracks) ? body.tracks : undefined,\n    deliveredAt: new Date().toISOString()\n  });\n\n  await env.DB.prepare(\n    \'UPDATE orders SET delivered_video_url=?, delivered_thumbnail_url=?, status=?, delivered_at=CURRENT_TIMESTAMP, delivered_video_metadata=? WHERE order_id=?\'\n  ).bind(body.videoUrl, body.thumbnailUrl || null, \'delivered\', deliveredVideoMetadata, body.orderId).run();\n  \n  // Trigger email webhook if configured\n  try {\n    const googleScriptUrl = await getGoogleScriptUrl(env);\n    if (googleScriptUrl && orderResult) {\n      // Extract email from encrypted data\n      let customerEmail = \'\';\n      try {\n        const decrypted = JSON.parse(orderResult.encrypted_data);\n        customerEmail = decrypted.email || \'\';\n      } catch (e) {\n        console.warn(\'Could not decrypt order data for email\');\n      }\n      \n      // Send delivery notification webhook\n      await fetch(googleScriptUrl, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify({\n          event: \'order.delivered\',\n          order: {\n            order_id: body.orderId,\n            product_title: orderResult.product_title || \'Your Order\',\n            email: customerEmail,\n            delivered_video_url: body.videoUrl,\n            status: \'delivered\'\n          }\n        })\n      }).catch(err => console.error(\'Failed to send delivery webhook:\', err));\n    }\n  } catch (err) {\n    console.error(\'Error triggering delivery webhook:\', err);\n  }\n  \n  return json({ success: true });\n}\n\n/**\n * Request revision for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Revision data\n * @returns {Promise<Response>}\n */\nexport async function requestRevision(env, body) {\n  if (!body.orderId) return json({ error: \'orderId required\' }, 400);\n  \n  // Get order data before updating\n  const orderResult = await env.DB.prepare(\n    \'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?\'\n  ).bind(body.orderId).first();\n  \n  await env.DB.prepare(\n    \'UPDATE orders SET revision_requested=1, revision_count=revision_count+1, status=? WHERE order_id=?\'\n  ).bind(\'revision\', body.orderId).run();\n  \n  // Trigger revision notification webhook if configured\n  try {\n    const googleScriptUrl = await getGoogleScriptUrl(env);\n    if (googleScriptUrl && orderResult) {\n      // Extract email from encrypted data\n      let customerEmail = \'\';\n      try {\n        const decrypted = JSON.parse(orderResult.encrypted_data);\n        customerEmail = decrypted.email || \'\';\n      } catch (e) {\n        console.warn(\'Could not decrypt order data for email\');\n      }\n      \n      // Send revision notification webhook\n      await fetch(googleScriptUrl, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify({\n          event: \'order.revision_requested\',\n          order: {\n            order_id: body.orderId,\n            product_title: orderResult.product_title || \'Your Order\',\n            email: customerEmail,\n            revision_reason: body.reason || \'No reason provided\',\n            revision_count: (orderResult.revision_count || 0) + 1,\n            status: \'revision\'\n          }\n        })\n      }).catch(err => console.error(\'Failed to send revision webhook:\', err));\n    }\n  } catch (err) {\n    console.error(\'Error triggering revision webhook:\', err);\n  }\n  \n  return json({ success: true });\n}\n\n/**\n * Update portfolio settings for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Portfolio data\n * @returns {Promise<Response>}\n */\nexport async function updatePortfolio(env, body) {\n  await env.DB.prepare(\n    \'UPDATE orders SET portfolio_enabled=? WHERE order_id=?\'\n  ).bind(body.portfolioEnabled ? 1 : 0, body.orderId).run();\n  return json({ success: true });\n}\n\n/**\n * Update archive URL for order\n * @param {Object} env - Environment bindings\n * @param {Object} body - Archive data\n * @returns {Promise<Response>}\n */\nexport async function updateArchiveUrl(env, body) {\n  await env.DB.prepare(\'UPDATE orders SET archive_url=? WHERE order_id=?\').bind(body.archiveUrl, body.orderId).run();\n  return json({ success: true });\n}\n\n/**\n * Upload encrypted file for order\n * @param {Object} env - Environment bindings\n * @param {Request} req - Request object\n * @param {Object} queryParams - Query parameters\n * @returns {Promise<Response>}\n */\nexport async function uploadEncryptedFile(env, req, queryParams) {\n  if (!env.R2_BUCKET) {\n    return json({ error: \'R2 not configured\' }, 500);\n  }\n  const orderId = queryParams.get(\'orderId\');\n  const itemId = queryParams.get(\'itemId\');\n  const filename = queryParams.get(\'filename\');\n  if (!orderId || !itemId || !filename) {\n    return json({ error: \'orderId, itemId and filename required\' }, 400);\n  }\n  // Read the request body into a buffer\n  const fileBuf = await req.arrayBuffer();\n  const key = `orders/${orderId}/${itemId}/${filename}`;\n  await env.R2_BUCKET.put(key, fileBuf, {\n    httpMetadata: { contentType: req.headers.get(\'content-type\') || \'application/octet-stream\' }\n  });\n  // You could update the orders table with the uploaded file key or URL here.\n  // We return the R2 key so the caller can take further action if needed.\n  return json({ success: true, r2Key: key });\n}\n</create-file>\n</function_calls>'}