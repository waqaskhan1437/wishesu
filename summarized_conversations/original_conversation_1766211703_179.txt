{'role': 'assistant', 'content': '\nNow let me create the admin controller in `src/controllers/admin.js`:\n\n<function_calls>\n<create-file file_path="src/controllers/admin.js">\n// Admin dashboard API controller\nimport { json } from \'../utils/response.js\';\n\n/**\n * Purge Cloudflare cache\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function purgeCache(env) {\n  const zoneId = env.CF_ZONE_ID;\n  const token = env.CF_API_TOKEN;\n  if (!zoneId || !token) {\n    return json({ error: \'CF_ZONE_ID or CF_API_TOKEN not configured\' }, 500);\n  }\n  try {\n    const purgeUrl = `https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`;\n    const cfResp = await fetch(purgeUrl, {\n      method: \'POST\',\n      headers: {\n        \'Authorization\': `Bearer ${token}`,\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify({ purge_everything: true })\n    });\n    const result = await cfResp.json();\n    return json(result, cfResp.ok ? 200 : 500);\n  } catch (e) {\n    return json({ error: e.message }, 500);\n  }\n}\n\n/**\n * Get Whop settings from database\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getWhopSettings(env) {\n  const row = await env.DB.prepare(\'SELECT value FROM settings WHERE key = ?\').bind(\'whop\').first();\n  let settings = {};\n  try { if (row?.value) settings = JSON.parse(row.value); } catch(e) {}\n  return json({ settings });\n}\n\n/**\n * Save Whop settings to database\n * @param {Object} env - Environment bindings\n * @param {Object} body - Settings data\n * @returns {Promise<Response>}\n */\nexport async function saveWhopSettings(env, body) {\n  await env.DB.prepare(\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\').bind(\'whop\', JSON.stringify(body)).run();\n  return json({ success: true });\n}\n\n/**\n * Export data (products, orders, reviews)\n * @param {Object} env - Environment bindings\n * @param {string} type - Export type (\'products\', \'orders\', \'reviews\', \'all\')\n * @returns {Promise<Response>}\n */\nexport async function exportData(env, type) {\n  try {\n    let data = {};\n    \n    switch (type) {\n      case \'products\':\n        const products = await env.DB.prepare(\'SELECT * FROM products ORDER BY id DESC\').all();\n        data.products = products.results || [];\n        break;\n        \n      case \'orders\':\n        const orders = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n        data.orders = orders.results || [];\n        break;\n        \n      case \'reviews\':\n        const reviews = await env.DB.prepare(\'SELECT * FROM reviews ORDER BY id DESC\').all();\n        data.reviews = reviews.results || [];\n        break;\n        \n      case \'all\':\n      default:\n        const allProducts = await env.DB.prepare(\'SELECT * FROM products ORDER BY id DESC\').all();\n        const allOrders = await env.DB.prepare(\'SELECT * FROM orders ORDER BY id DESC\').all();\n        const allReviews = await env.DB.prepare(\'SELECT * FROM reviews ORDER BY id DESC\').all();\n        const allPages = await env.DB.prepare(\'SELECT * FROM pages ORDER BY id DESC\').all();\n        const allSettings = await env.DB.prepare(\'SELECT * FROM settings ORDER BY key\').all();\n        \n        data = {\n          products: allProducts.results || [],\n          orders: allOrders.results || [],\n          reviews: allReviews.results || [],\n          pages: allPages.results || [],\n          settings: allSettings.results || [],\n          exported_at: new Date().toISOString(),\n          version: \'1.0\'\n        };\n        break;\n    }\n    \n    // Add metadata\n    data.exported_at = new Date().toISOString();\n    data.export_type = type;\n    data.total_records = Object.keys(data).reduce((sum, key) => {\n      if (key !== \'exported_at\' && key !== \'export_type\' && key !== \'total_records\' && key !== \'version\') {\n        return sum + (Array.isArray(data[key]) ? data[key].length : 0);\n      }\n      return sum;\n    }, 0);\n    \n    return json(data);\n  } catch (e) {\n    console.error(\'Export error:\', e);\n    return json({ error: \'Export failed: \' + e.message }, 500);\n  }\n}\n\n/**\n * Import data (products, orders, reviews)\n * @param {Object} env - Environment bindings\n * @param {Object} importData - Import data\n * @returns {Promise<Response>}\n */\nexport async function importData(env, importData) {\n  try {\n    const results = {\n      products: { imported: 0, errors: [] },\n      orders: { imported: 0, errors: [] },\n      reviews: { imported: 0, errors: [] },\n      pages: { imported: 0, errors: [] },\n      settings: { imported: 0, errors: [] }\n    };\n    \n    // Import products\n    if (importData.products && Array.isArray(importData.products)) {\n      for (const product of importData.products) {\n        try {\n          // Remove ID for new insertion, or update if ID exists\n          if (product.id) {\n            const existing = await env.DB.prepare(\'SELECT id FROM products WHERE id = ?\').bind(product.id).first();\n            if (existing) {\n              // Update existing product\n              await env.DB.prepare(`\n                UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,\n                instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,\n                gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,\n                whop_plan=?, whop_price_map=?, whop_product_id=?, status=?, sort_order=? WHERE id=?\n              `).bind(\n                product.title || \'\', product.slug || \'\', product.description || \'\',\n                product.normal_price || 0, product.sale_price || null,\n                product.instant_delivery || 0, product.normal_delivery_text || \'\',\n                product.thumbnail_url || \'\', product.video_url || \'\',\n                product.gallery_images || \'[]\', product.addons_json || \'[]\',\n                product.seo_title || \'\', product.seo_description || \'\', product.seo_keywords || \'\', product.seo_canonical || \'\',\n                product.whop_plan || \'\', product.whop_price_map || \'\', product.whop_product_id || \'\',\n                product.status || \'active\', product.sort_order || 0, product.id\n              ).run();\n              results.products.imported++;\n              continue;\n            }\n          }\n          \n          // Insert new product (without ID to avoid conflicts)\n          await env.DB.prepare(`\n            INSERT INTO products (title, slug, description, normal_price, sale_price,\n            instant_delivery, normal_delivery_text, thumbnail_url, video_url,\n            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,\n            whop_plan, whop_price_map, whop_product_id, status, sort_order)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            product.title || \'\', product.slug || \'\', product.description || \'\',\n            product.normal_price || 0, product.sale_price || null,\n            product.instant_delivery || 0, product.normal_delivery_text || \'\',\n            product.thumbnail_url || \'\', product.video_url || \'\',\n            product.gallery_images || \'[]\', product.addons_json || \'[]\',\n            product.seo_title || \'\', product.seo_description || \'\', product.seo_keywords || \'\', product.seo_canonical || \'\',\n            product.whop_plan || \'\', product.whop_price_map || \'\', product.whop_product_id || \'\',\n            product.status || \'active\', product.sort_order || 0\n          ).run();\n          results.products.imported++;\n        } catch (e) {\n          results.products.errors.push(`Product "${product.title || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import orders\n    if (importData.orders && Array.isArray(importData.orders)) {\n      for (const order of importData.orders) {\n        try {\n          // Check if order already exists by order_id\n          const existing = await env.DB.prepare(\'SELECT id FROM orders WHERE order_id = ?\').bind(order.order_id).first();\n          if (existing) continue; // Skip existing orders\n          \n          await env.DB.prepare(`\n            INSERT INTO orders (order_id, product_id, encrypted_data, iv, archive_url, archive_data,\n            status, created_at, delivered_video_url, delivered_thumbnail_url, delivered_video_metadata,\n            portfolio_enabled, delivered_at, delivery_time_minutes, revision_count, revision_requested)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            order.order_id, order.product_id || null, order.encrypted_data || \'{}\', order.iv || null,\n            order.archive_url || null, order.archive_data || null, order.status || \'pending\',\n            order.created_at || new Date().toISOString(), order.delivered_video_url || null,\n            order.delivered_thumbnail_url || null, order.delivered_video_metadata || null,\n            order.portfolio_enabled || 1, order.delivered_at || null, order.delivery_time_minutes || 60,\n            order.revision_count || 0, order.revision_requested || 0\n          ).run();\n          results.orders.imported++;\n        } catch (e) {\n          results.orders.errors.push(`Order "${order.order_id || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import reviews\n    if (importData.reviews && Array.isArray(importData.reviews)) {\n      for (const review of importData.reviews) {\n        try {\n          await env.DB.prepare(`\n            INSERT INTO reviews (product_id, author_name, rating, comment, status, created_at,\n            order_id, show_on_product, delivered_video_url, delivered_thumbnail_url)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            review.product_id, review.author_name || \'Customer\', review.rating || 5,\n            review.comment || \'\', review.status || \'approved\', review.created_at || new Date().toISOString(),\n            review.order_id || null, review.show_on_product !== undefined ? review.show_on_product : 1,\n            review.delivered_video_url || null, review.delivered_thumbnail_url || null\n          ).run();\n          results.reviews.imported++;\n        } catch (e) {\n          results.reviews.errors.push(`Review for product ${review.product_id || \'Unknown\'}: ${e.message}`);\n        }\n      }\n    }\n    \n    // Import pages\n    if (importData.pages && Array.isArray(importData.pages)) {\n      for (const page of importData.pages) {\n        try {\n          // Check if page already exists by slug\n          const existing = await env.DB.prepare(\'SELECT id FROM pages WHERE slug = ?\').bind(page.slug).first();\n          if (existing) {\n            // Update existing page\n            await env.DB.prepare(`\n              UPDATE pages SET title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?\n            `).bind(\n              page.title || \'\', page.content || \'\', page.meta_description || \'\',\n              page.status || \'published\', existing.id\n            ).run();\n          } else {\n            // Insert new page\n            await env.DB.prepare(`\n              INSERT INTO pages (slug, title, content, meta_description, status, created_at, updated_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?)\n            `).bind(\n              page.slug || \'\', page.title || \'\', page.content || \'\',\n              page.meta_description || \'\', page.status || \'published\',\n              page.created_at || new Date().toISOString(), page.updated_at || new Date().toISOString()\n            ).run();\n          }\n          results.pages.imported++;\n        } catch (e) {\n          results.pages.errors.push(`Page "${page.title || page.slug || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Import settings\n    if (importData.settings && Array.isArray(importData.settings)) {\n      for (const setting of importData.settings) {\n        try {\n          await env.DB.prepare(\'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)\')\n            .bind(setting.key, setting.value || \'\').run();\n          results.settings.imported++;\n        } catch (e) {\n          results.settings.errors.push(`Setting "${setting.key || \'Unknown\'}": ${e.message}`);\n        }\n      }\n    }\n    \n    // Calculate totals\n    const totalImported = Object.values(results).reduce((sum, result) => sum + result.imported, 0);\n    const totalErrors = Object.values(results).reduce((sum, result) => sum + result.errors.length, 0);\n    \n    return json({\n      success: true,\n      results,\n      summary: {\n        total_imported: totalImported,\n        total_errors: totalErrors,\n        import_time: new Date().toISOString()\n      }\n    });\n  } catch (e) {\n    console.error(\'Import error:\', e);\n    return json({ error: \'Import failed: \' + e.message }, 500);\n  }\n}\n\n/**\n * Get system statistics\n * @param {Object} env - Environment bindings\n * @returns {Promise<Response>}\n */\nexport async function getSystemStats(env) {\n  try {\n    const stats = {};\n    \n    // Product stats\n    const productCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM products\').first();\n    const activeProducts = await env.DB.prepare(\'SELECT COUNT(*) as count FROM products WHERE status = ?\', \'active\').first();\n    stats.products = {\n      total: productCount?.count || 0,\n      active: activeProducts?.count || 0,\n      draft: (productCount?.count || 0) - (activeProducts?.count || 0)\n    };\n    \n    // Order stats\n    const orderCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders\').first();\n    const deliveredOrders = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders WHERE status = ?\', \'delivered\').first();\n    const pendingOrders = await env.DB.prepare(\'SELECT COUNT(*) as count FROM orders WHERE status IN (?, ?, ?)\', \'pending\', \'PAID\', \'revision\').first();\n    stats.orders = {\n      total: orderCount?.count || 0,\n      delivered: deliveredOrders?.count || 0,\n      pending: pendingOrders?.count || 0\n    };\n    \n    // Review stats\n    const reviewCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM reviews\').first();\n    const approvedReviews = await env.DB.prepare(\'SELECT COUNT(*) as count FROM reviews WHERE status = ?\', \'approved\').first();\n    stats.reviews = {\n      total: reviewCount?.count || 0,\n      approved: approvedReviews?.count || 0,\n      pending: (reviewCount?.count || 0) - (approvedReviews?.count || 0)\n    };\n    \n    // Page stats\n    const pageCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM pages\').first();\n    const publishedPages = await env.DB.prepare(\'SELECT COUNT(*) as count FROM pages WHERE status = ?\', \'published\').first();\n    stats.pages = {\n      total: pageCount?.count || 0,\n      published: publishedPages?.count || 0,\n      draft: (pageCount?.count || 0) - (publishedPages?.count || 0)\n    };\n    \n    // Chat stats\n    const sessionCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM chat_sessions\').first();\n    const messageCount = await env.DB.prepare(\'SELECT COUNT(*) as count FROM chat_messages\').first();\n    stats.chat = {\n      sessions: sessionCount?.count || 0,\n      messages: messageCount?.count || 0\n    };\n    \n    // Revenue stats (basic)\n    const revenueResult = await env.DB.prepare(`\n      SELECT COUNT(*) as count, \n             AVG(CASE \n               WHEN json_extract(encrypted_data, \'$.amount\') IS NOT NULL \n               THEN json_extract(encrypted_data, \'$.amount\') \n               ELSE 0 \n             END) as avg_amount\n      FROM orders \n      WHERE status != \'pending\'\n    `).first();\n    stats.revenue = {\n      orders_processed: revenueResult?.count || 0,\n      average_order_value: revenueResult?.avg_amount || 0\n    };\n    \n    return json({ success: true, stats, generated_at: new Date().toISOString() });\n  } catch (e) {\n    console.error(\'Stats error:\', e);\n    return json({ error: \'Failed to generate stats: \' + e.message }, 500);\n  }\n}\n</create-file>\n</function_calls>'}