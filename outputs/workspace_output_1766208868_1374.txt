          }
        }

        // ----- WHOP TEST WEBHOOK -----
        // Endpoint to verify that the webhook endpoint is reachable.  This
        // simply returns a success object.  It does not call the external
        // Whop service.  Use this to check that your domain and Cloudflare
        // routing are configured correctly.
        if (method === 'GET' && path === '/api/whop/test-webhook') {
          return json({ success: true, message: 'Webhook endpoint reachable' });
        }
        
        // ----- CLEANUP EXPIRED CHECKOUTS -----
        // Endpoint to cleanup expired checkout sessions (call this from a cron job)
        if (method === 'POST' && path === '/api/whop/cleanup') {
          if (!env.WHOP_API_KEY) {
            return json({ error: 'Whop API key not configured' }, 500);
          }
          
          try {
            // Get expired checkouts from database
            const expiredCheckouts = await env.DB.prepare(`
              SELECT checkout_id, product_id, expires_at
              FROM checkout_sessions
              WHERE status = 'pending' 
              AND datetime(expires_at) < datetime('now')
              ORDER BY created_at ASC
              LIMIT 50
            `).all();
            
            let deleted = 0;
            let failed = 0;
            
            for (const checkout of (expiredCheckouts.results || [])) {
              try {
                // Delete the checkout session from Whop (ignore if already gone)
                const deleteSessionResp = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {
                  method: 'DELETE',
                  headers: { 'Authorization': `Bearer ${env.WHOP_API_KEY}` }
                });
                // Attempt to delete the associated plan if one exists
                let planDeleted = false;
                try {
                  const row = await env.DB.prepare('SELECT plan_id FROM checkout_sessions WHERE checkout_id = ?').bind(checkout.checkout_id).first();
                  const planId = row && row.plan_id;
                  if (planId) {
                    const delPlanResp = await fetch(`https://api.whop.com/api/v2/plans/${planId}`, {
                      method: 'DELETE',
                      headers: { 'Authorization': `Bearer ${env.WHOP_API_KEY}` }
                    });
                    planDeleted = delPlanResp.ok || delPlanResp.status === 404;
                  }
                } catch (pe) {
                  console.error('Plan deletion error:', pe);
                }
                if (deleteSessionResp.ok || deleteSessionResp.status === 404) {
                  // Mark as expired in database regardless of plan deletion outcome
                  await env.DB.prepare(`
                    UPDATE checkout_sessions 
                    SET status = 'expired', completed_at = datetime('now')
                    WHERE checkout_id = ?
                  `).bind(checkout.checkout_id).run();
                  deleted++;
                  console.log('ðŸ—‘ï¸ Expired checkout deleted:', checkout.checkout_id, planDeleted ? 'and plan cleaned up' : '');
                } else {
                  failed++;
                }
              } catch (e) {
                failed++;
                console.error('Failed to delete checkout:', checkout.checkout_id, e);
              }
            }
            
            return json({
              success: true,
              deleted: deleted,
              failed: failed,
              message: `Cleaned up ${deleted} expired checkouts`
            });
          } catch (e) {
            console.error('Cleanup error:', e);
            return json({ error: e.message }, 500);
          }
        }

        if (method === 'GET' && path.startsWith('/api/product/')) {
          const id = path.split('/').pop();
          let row;
          if (isNaN(Number(id))) {
            row = await env.DB.prepare('SELECT * FROM products WHERE slug = ?').bind(id).first();
          } else {
            row = await env.DB.prepare('SELECT * FROM products WHERE id = ?').bind(Number(id)).first();
          }
          if (!row) return json({ error: 'Product not found' }, 404);
          
          let addons = [];
          try {
            addons = JSON.parse(row.addons_json || '[]');
          } catch(e) {
            console.error('Failed to parse addons_json for product', row.id, ':', e.message);
          }
          
          const stats = await env.DB.prepare(
            'SELECT COUNT(*) as cnt, AVG(rating) as avg FROM reviews WHERE product_id = ? AND status = ?'
          ).bind(row.id, 'approved').first();
          
          // Fetch reviews for rich results schema (directly use review's own video URLs)
          const reviewsResult = await env.DB.prepare(
            `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url 
             FROM reviews 
             LEFT JOIN orders ON reviews.order_id = orders.order_id 
             WHERE reviews.product_id = ? AND reviews.status = ? 
             ORDER BY reviews.created_at DESC`
          ).bind(row.id, 'approved').all();

          // Convert created_at to ISO 8601 format with Z suffix for UTC
          const reviews = (reviewsResult.results || []).map(review => {
            if (review.created_at && typeof review.created_at === 'string') {
              review.created_at = review.created_at.replace(' ', 'T') + 'Z';
            }
            if (review.updated_at && typeof review.updated_at === 'string') {
              review.updated_at = review.updated_at.replace(' ', 'T') + 'Z';
            }
            return review;
          });
          
          return json({
            product: {
              ...row,
              addons,
              review_count: stats?.cnt || 0,
              rating_average: stats?.avg ? Math.round(stats.avg * 10) / 10 : 5.0,
              reviews: reviews
            },
            addons
          });
        }

        if (method === 'POST' && path === '/api/product/save') {
          const body = await req.json();
          const title = (body.title || '').trim();
          if (!title) return json({ error: 'Title required' }, 400);
          
          const slug = (body.slug || '').trim() || title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          const addonsJson = JSON.stringify(body.addons || []);
          
          if (body.id) {
            // Prepare gallery_images as JSON string if it's an array
            const galleryJson = Array.isArray(body.gallery_images) 
              ? JSON.stringify(body.gallery_images) 
              : (body.gallery_images || '[]');
            
            await env.DB.prepare(`
              UPDATE products SET title=?, slug=?, description=?, normal_price=?, sale_price=?,
              instant_delivery=?, normal_delivery_text=?, thumbnail_url=?, video_url=?,
              gallery_images=?, addons_json=?, seo_title=?, seo_description=?, seo_keywords=?, seo_canonical=?,
              whop_plan=?, whop_price_map=?, whop_product_id=? WHERE id=?
            `).bind(
              title, slug, body.description || '', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,
              body.instant_delivery ? 1 : 0, body.normal_delivery_text || '',
              body.thumbnail_url || '', body.video_url || '', galleryJson, addonsJson,
              body.seo_title || '', body.seo_description || '', body.seo_keywords || '', body.seo_canonical || '',
              body.whop_plan || '', body.whop_price_map || '', body.whop_product_id || '', Number(body.id)
            ).run();
            return json({ success: true, id: body.id, slug, url: `/product-${body.id}/${encodeURIComponent(slug)}` });
          }
          
          // Prepare gallery_images as JSON string if it's an array
          const galleryJson = Array.isArray(body.gallery_images) 
            ? JSON.stringify(body.gallery_images) 
            : (body.gallery_images || '[]');
          
          const r = await env.DB.prepare(`
            INSERT INTO products (title, slug, description, normal_price, sale_price,
            instant_delivery, normal_delivery_text, thumbnail_url, video_url,
            gallery_images, addons_json, seo_title, seo_description, seo_keywords, seo_canonical,
            whop_plan, whop_price_map, whop_product_id, status, sort_order)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'active', 0)
          `).bind(
            title, slug, body.description || '', Number(body.normal_price) || 0, body.sale_price ? Number(body.sale_price) : null,
            body.instant_delivery ? 1 : 0, body.normal_delivery_text || '',
            body.thumbnail_url || '', body.video_url || '', galleryJson, addonsJson,
            body.seo_title || '', body.seo_description || '', body.seo_keywords || '', body.seo_canonical || '',
            body.whop_plan || '', body.whop_price_map || '', body.whop_product_id || ''
          ).run();
          const newId = r.meta?.last_row_id;
          return json({ success: true, id: newId, slug, url: `/product-${newId}/${encodeURIComponent(slug)}` });
        }

        if (method === 'DELETE' && path === '/api/product/delete') {
          const id = url.searchParams.get('id');
          if (!id) return json({ error: 'ID required' }, 400);
          await env.DB.prepare('DELETE FROM products WHERE id = ?').bind(Number(id)).run();
          return json({ success: true });
        }

        // ----- PRODUCTS LIST (admin) -----
        // Return all products regardless of status.  Used by the admin UI to
        // manage published and draft products.  Includes the status column to
        // drive publish/unpublish toggles.
        if (method === 'GET' && path === '/api/products/list') {
          const r = await env.DB.prepare(
            'SELECT id, title, slug, normal_price, sale_price, thumbnail_url, normal_delivery_text, status FROM products ORDER BY id DESC'
          ).all();
          return json({ products: r.results || [] });
        }

        // ----- PRODUCTS STATUS UPDATE -----
        // Update the status of a product (active for published, draft for draft).
        // Accepts JSON with `id` and `status`.  Status must be 'active' or 'draft'.
        if (method === 'POST' && path === '/api/products/status') {
          const body = await req.json().catch(() => ({}));
          const id = body.id;
          const status = (body.status || '').trim().toLowerCase();
          if (!id || !status) {
            return json({ error: 'id and status required' }, 400);
          }
          if (status !== 'active' && status !== 'draft') {
            return json({ error: 'invalid status' }, 400);
          }
          await env.DB.prepare('UPDATE products SET status = ? WHERE id = ?').bind(status, Number(id)).run();
          return json({ success: true });
        }

        // ----- PRODUCTS DUPLICATE -----
        // Duplicate an existing product.  Accepts JSON with `id`.  Copies
        // all fields and inserts a new product with slug suffixed by '-copy'
        // and status set to 'draft'.  Ensures slug uniqueness by adding
        // numerical suffixes when needed.  Returns the new product id and slug.
        if (method === 'POST' && path === '/api/products/duplicate') {
          const body = await req.json().catch(() => ({}));
          const id = body.id;
          if (!id) {
            return json({ error: 'id required' }, 400);
          }
          const row = await env.DB.prepare('SELECT * FROM products WHERE id = ?').bind(Number(id)).first();
          if (!row) {
            return json({ error: 'Product not found' }, 404);
          }
          const baseSlug = row.slug || row.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          // Determine unique new slug
          let newSlug = baseSlug + '-copy';
          let idx = 1;
          let exists = await env.DB.prepare('SELECT slug FROM products WHERE slug = ?').bind(newSlug).first();
          while (exists) {
            newSlug = `${baseSlug}-copy${idx}`;
            idx++;
            exists = await env.DB.prepare('SELECT slug FROM products WHERE slug = ?').bind(newSlug).first();
          }
          // Copy all relevant fields into a new product row
          const r = await env.DB.prepare(
            `INSERT INTO products (
              title, slug, description, normal_price, sale_price,
              instant_delivery, normal_delivery_text, thumbnail_url, video_url,
              addons_json, seo_title, seo_description, seo_keywords, seo_canonical,
              whop_plan, whop_price_map, status, sort_order
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
          ).bind(
            (row.title || '') + ' Copy',
            newSlug,
            row.description || '',
            row.normal_price || 0,
            row.sale_price || null,
            row.instant_delivery || 0,
            row.normal_delivery_text || '',
            row.thumbnail_url || '',
            row.video_url || '',
            row.addons_json || '[]',
            row.seo_title || '',
            row.seo_description || '',
            row.seo_keywords || '',
            row.seo_canonical || '',
            row.whop_plan || '',
            row.whop_price_map || '',
            'draft',
            0
          ).run();
          return json({ success: true, id: r.meta?.last_row_id, slug: newSlug });
        }

        // ----- ORDERS -----
        if (method === 'GET' && path === '/api/orders') {
          const r = await env.DB.prepare('SELECT * FROM orders ORDER BY id DESC').all();
          const orders = (r.results || []).map(row => {
            let email = '', amount = null, addons = [];
            try {
              if (row.encrypted_data && row.encrypted_data[0] === '{') {
                const d = JSON.parse(row.encrypted_data);
                email = d.email || '';
                amount = d.amount;
                addons = d.addons || [];
              }
            } catch(e) {
              console.error('Failed to parse order encrypted_data for order:', row.order_id, e.message);
            }
            return { ...row, email, amount, addons };
          });
          return json({ orders });
        }

        if (method === 'POST' && (path === '/api/order/create' || path === '/submit-order')) {
          const body = await req.json();
          if (!body.productId) return json({ error: 'productId required' }, 400);
          
          const orderId = body.orderId || crypto.randomUUID().split('-')[0].toUpperCase();
          const data = JSON.stringify({
            email: body.email,
            amount: body.amount,
            productId: body.productId,
            addons: body.addons || []
          });
          
          await env.DB.prepare(
            'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)'
          ).bind(orderId, Number(body.productId), data, 'PAID', Number(body.deliveryTime) || 60).run();
          
          return json({ success: true, orderId });
        }

        if (method === 'GET' && path.startsWith('/api/order/buyer/')) {
           const orderId = path.split('/').pop();
           const row = await env.DB.prepare(
             'SELECT o.*, p.title as product_title, p.thumbnail_url as product_thumbnail FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?'
           ).bind(orderId).first();

           if (!row) return json({ error: 'Order not found' }, 404);

           // Check if review already exists for this order
           const reviewCheck = await env.DB.prepare(
             'SELECT id FROM reviews WHERE order_id = ? LIMIT 1'
           ).bind(orderId).first();
           const hasReview = !!reviewCheck;

           let addons = [], email = '', amount = null;
           try {
             if (row.encrypted_data && row.encrypted_data[0] === '{') {
               const d = JSON.parse(row.encrypted_data);
               addons = d.addons || [];
               email = d.email || '';
               amount = d.amount;
             }
           } catch(e) {
             console.error('Failed to parse order encrypted_data for buyer order:', orderId, e.message);
           }

           // Convert SQLite datetime to ISO 8601 format with Z suffix for UTC
           const orderData = { ...row, addons, email, amount, has_review: hasReview };
           if (orderData.created_at && typeof orderData.created_at === 'string') {
             // SQLite format: YYYY-MM-DD HH:MM:SS -> ISO 8601: YYYY-MM-DDTHH:MM:SSZ
             orderData.created_at = orderData.created_at.replace(' ', 'T') + 'Z';
           }

           return json({ order: orderData });
         }

        if (method === 'DELETE' && path === '/api/order/delete') {
          const id = url.searchParams.get('id');
          await env.DB.prepare('DELETE FROM orders WHERE id = ?').bind(Number(id)).run();
          return json({ success: true });
        }

        // Update order (status, delivery time, etc.)
        if (method === 'POST' && path === '/api/order/update') {
          const body = await req.json();
          const orderId = body.orderId;
          
          if (!orderId) return json({ error: 'orderId required' }, 400);
          
          const updates = [];
          const values = [];
          
          if (body.status !== undefined) {
            updates.push('status = ?');
            values.push(body.status);
          }
          if (body.delivery_time_minutes !== undefined) {
            updates.push('delivery_time_minutes = ?');
            values.push(Number(body.delivery_time_minutes));
          }
          
          if (updates.length === 0) {
            return json({ error: 'No fields to update' }, 400);
          }
          
          values.push(orderId);
          await env.DB.prepare(`UPDATE orders SET ${updates.join(', ')} WHERE order_id = ?`).bind(...values).run();
          return json({ success: true });
        }

        // Create order manually (admin)
        if (method === 'POST' && path === '/api/order/create') {
          const body = await req.json();
          
          if (!body.productId || !body.email) {
            return json({ error: 'productId and email required' }, 400);
          }
          
          // Generate unique order ID
          const orderId = 'MO' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 6).toUpperCase();
          
          // Store order data
          const encryptedData = JSON.stringify({
            email: body.email,
            amount: body.amount || 0,
            addons: body.notes ? [{ field: 'Admin Notes', value: body.notes }] : [],
            manualOrder: true
          });
          
          await env.DB.prepare(
            'INSERT INTO orders (order_id, product_id, encrypted_data, status, delivery_time_minutes) VALUES (?, ?, ?, ?, ?)'
          ).bind(
            orderId,
            Number(body.productId),
            encryptedData,
            body.status || 'paid',
            Number(body.deliveryTime) || 60
          ).run();
          
          return json({ success: true, orderId });
        }

        if (method === 'POST' && path === '/api/order/deliver') {
                  const body = await req.json();
                  if (!body.orderId || !body.videoUrl) return json({ error: 'orderId and videoUrl required' }, 400);

                  // Get order data before updating
                  const orderResult = await env.DB.prepare(
                    'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?'
                  ).bind(body.orderId).first();

                  // Prepare additional metadata for delivered videos (Archive.org + subtitles, etc)
                  const deliveredVideoMetadata = JSON.stringify({
                    embedUrl: body.embedUrl,
                    itemId: body.itemId,
                    subtitlesUrl: body.subtitlesUrl,
                    tracks: Array.isArray(body.tracks) ? body.tracks : undefined,
                    deliveredAt: new Date().toISOString()
                  });

                  await env.DB.prepare(
                    'UPDATE orders SET delivered_video_url=?, delivered_thumbnail_url=?, status=?, delivered_at=CURRENT_TIMESTAMP, delivered_video_metadata=? WHERE order_id=?'
                  ).bind(body.videoUrl, body.thumbnailUrl || null, 'delivered', deliveredVideoMetadata, body.orderId).run();
          
          // Trigger email webhook if configured
          try {
            const googleScriptUrl = await getGoogleScriptUrl(env);
            if (googleScriptUrl && orderResult) {
              // Extract email from encrypted data
              let customerEmail = '';
              try {
                const decrypted = JSON.parse(orderResult.encrypted_data);
                customerEmail = decrypted.email || '';
              } catch (e) {
                console.warn('Could not decrypt order data for email');
              }
              
              // Send delivery notification webhook
              await fetch(googleScriptUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  event: 'order.delivered',
                  order: {
                    order_id: body.orderId,
                    product_title: orderResult.product_title || 'Your Order',
                    email: customerEmail,
                    delivered_video_url: body.videoUrl,
                    status: 'delivered'
                  }
                })
              }).catch(err => console.error('Failed to send delivery webhook:', err));
            }
          } catch (err) {
            console.error('Error triggering delivery webhook:', err);
          }
          
          return json({ success: true });
        }

        if (method === 'POST' && path === '/api/order/revision') {
          const body = await req.json();
          if (!body.orderId) return json({ error: 'orderId required' }, 400);
          
          // Get order data before updating
          const orderResult = await env.DB.prepare(
            'SELECT orders.*, products.title as product_title FROM orders LEFT JOIN products ON orders.product_id = products.id WHERE orders.order_id = ?'
          ).bind(body.orderId).first();
          
          await env.DB.prepare(
            'UPDATE orders SET revision_requested=1, revision_count=revision_count+1, status=? WHERE order_id=?'
          ).bind('revision', body.orderId).run();
          
          // Trigger revision notification webhook if configured
          try {
            const googleScriptUrl = await getGoogleScriptUrl(env);
            if (googleScriptUrl && orderResult) {
              // Extract email from encrypted data
              let customerEmail = '';
              try {
                const decrypted = JSON.parse(orderResult.encrypted_data);
                customerEmail = decrypted.email || '';
              } catch (e) {
                console.warn('Could not decrypt order data for email');
              }
              
              // Send revision notification webhook
              await fetch(googleScriptUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  event: 'order.revision_requested',
                  order: {
                    order_id: body.orderId,
                    product_title: orderResult.product_title || 'Your Order',
                    email: customerEmail,
                    revision_reason: body.reason || 'No reason provided',
                    revision_count: (orderResult.revision_count || 0) + 1,
                    status: 'revision'
                  }
                })
              }).catch(err => console.error('Failed to send revision webhook:', err));
            }
          } catch (err) {
            console.error('Error triggering revision webhook:', err);
          }
          
          return json({ success: true });
        }

        if (method === 'POST' && path === '/api/order/portfolio') {
          const body = await req.json();
          await env.DB.prepare(
            'UPDATE orders SET portfolio_enabled=? WHERE order_id=?'
          ).bind(body.portfolioEnabled ? 1 : 0, body.orderId).run();
          return json({ success: true });
        }

        if (method === 'POST' && path === '/api/order/archive-link') {
          const body = await req.json();
          await env.DB.prepare('UPDATE orders SET archive_url=? WHERE order_id=?').bind(body.archiveUrl, body.orderId).run();
          return json({ success: true });
        }

        // ----- REVIEWS -----
        if (method === 'GET' && path === '/api/reviews') {
          // Support filtering by productId(s), ids and rating via query parameters.
          const params = url.searchParams;
          const rating = params.get('rating');
          const productId = params.get('productId');
          const productIds = params.get('productIds');
          const ids = params.get('ids');
          let sql = 'SELECT r.*, p.title as product_title FROM reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.status = ?';
          /**
           * Bind values can be strings or numbers.  TypeScript incorrectly infers
           * this array as `string[]` because the first value is a string, which causes
           * type errors when numbers are pushed.  Annotate the type explicitly to
           * avoid type errors in the Cloudflare editor.
           * @type {(string|number)[]}
           */
          const binds = ['approved'];
          // Filter by rating
          if (rating) {
            sql += ' AND r.rating = ?';
            binds.push(Number(rating));
          }
          // Filter by single product
          if (productId) {
            sql += ' AND r.product_id = ?';
            binds.push(Number(productId));
          }
          // Filter by multiple products
          if (productIds) {
            const idsArr = productIds.split(',').map(id => parseInt(id, 10)).filter(n => !isNaN(n));
            if (idsArr.length > 0) {
              sql += ` AND r.product_id IN (${idsArr.map(() => '?').join(',')})`;
              binds.push(...idsArr);
            }
          }
          // Filter by specific review IDs
          if (ids) {
            const idsArr2 = ids.split(',').map(id => parseInt(id, 10)).filter(n => !isNaN(n));
            if (idsArr2.length > 0) {
              sql += ` AND r.id IN (${idsArr2.map(() => '?').join(',')})`;
              binds.push(...idsArr2);
            }
          }
          sql += ' ORDER BY r.created_at DESC';
          const stmt = await env.DB.prepare(sql);
          const r = await stmt.bind(...binds).all();

          // Convert created_at to ISO 8601 format with Z suffix for UTC
          const reviews = (r.results || []).map(review => {
            if (review.created_at && typeof review.created_at === 'string') {
              review.created_at = review.created_at.replace(' ', 'T') + 'Z';
            }
            return review;
          });

          return json({ reviews });
        }

        if (method === 'POST' && path === '/api/reviews/add') {
          const body = await req.json();
          if (!body.productId || !body.rating) return json({ error: 'productId and rating required' }, 400);
          
          await env.DB.prepare(
            'INSERT INTO reviews (product_id, author_name, rating, comment, status, order_id, show_on_product) VALUES (?, ?, ?, ?, ?, ?, ?)'
          ).bind(Number(body.productId), body.author || 'Customer', Number(body.rating), body.comment || '', 'approved', body.orderId || null, body.showOnProduct !== undefined ? (body.showOnProduct ? 1 : 0) : 1).run();
          
          return json({ success: true });
        }

        if (method === 'GET' && path.startsWith('/api/reviews/')) {
           const productId = path.split('/').pop();
           const r = await env.DB.prepare(
             `SELECT reviews.*, orders.delivered_video_url, orders.delivered_thumbnail_url 
              FROM reviews 
              LEFT JOIN orders ON reviews.order_id = orders.order_id 
              WHERE reviews.product_id = ? AND reviews.status = ? 
              ORDER BY reviews.created_at DESC`
           ).bind(Number(productId), 'approved').all();

           // Convert created_at to ISO 8601 format with Z suffix for UTC
           const reviews = (r.results || []).map(review => {
             if (review.created_at && typeof review.created_at === 'string') {
               review.created_at = review.created_at.replace(' ', 'T') + 'Z';
             }
             return review;
           });

           return json({ reviews });
         }

        if (method === 'POST' && path === '/api/reviews/update') {
          const body = await req.json();
          const id = Number(body.id);
          
          // Build dynamic update query based on provided fields
          const updates = [];
          const values = [];
          
          if (body.status !== undefined) {
            updates.push('status = ?');
            values.push(body.status);
          }
          if (body.author_name !== undefined) {
            updates.push('author_name = ?');
            values.push(body.author_name);
          }
          if (body.rating !== undefined) {
            updates.push('rating = ?');
            values.push(Number(body.rating));
          }
          if (body.comment !== undefined) {
            updates.push('comment = ?');
            values.push(body.comment);
          }
          if (body.show_on_product !== undefined) {
            updates.push('show_on_product = ?');
            values.push(Number(body.show_on_product));
          }
          
          if (updates.length === 0) {
            return json({ error: 'No fields to update' }, 400);
          }
          
          values.push(id);
          await env.DB.prepare(`UPDATE reviews SET ${updates.join(', ')} WHERE id = ?`).bind(...values).run();
          return json({ success: true });
        }


        // REMOVED: Review migration endpoint no longer needed with JOIN-based fetching
        // Migration endpoint removed as reviews now fetch delivery URLs dynamically from orders table


        if (method === 'DELETE' && path === '/api/reviews/delete') {
          const id = url.searchParams.get('id');
          await env.DB.prepare('DELETE FROM reviews WHERE id = ?').bind(Number(id)).run();
          return json({ success: true });
        }

        // ----- SETTINGS -----
        if (method === 'GET' && path === '/api/settings/whop') {
          const row = await env.DB.prepare('SELECT value FROM settings WHERE key = ?').bind('whop').first();
          let settings = {};
          try { if (row?.value) settings = JSON.parse(row.value); } catch(e) {}
          return json({ settings });
        }

        if (method === 'POST' && path === '/api/settings/whop') {
          const body = await req.json();
          await env.DB.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)').bind('whop', JSON.stringify(body)).run();
          return json({ success: true });
        }


        // ----- PAGES -----
        if (method === 'GET' && path === '/api/pages') {
           const r = await env.DB.prepare('SELECT id, slug, title, status, created_at, updated_at FROM pages ORDER BY id DESC').all();

           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC
           const pages = (r.results || []).map(page => {
             if (page.created_at && typeof page.created_at === 'string') {
               page.created_at = page.created_at.replace(' ', 'T') + 'Z';
             }
             if (page.updated_at && typeof page.updated_at === 'string') {
               page.updated_at = page.updated_at.replace(' ', 'T') + 'Z';
             }
             return page;
           });

           return json({ pages });
         }

        if (method === 'GET' && path.startsWith('/api/page/')) {
           const slug = path.split('/').pop();
           const row = await env.DB.prepare('SELECT * FROM pages WHERE slug = ?').bind(slug).first();
           if (!row) return json({ error: 'Page not found' }, 404);

           // Convert created_at and updated_at to ISO 8601 format with Z suffix for UTC
           if (row.created_at && typeof row.created_at === 'string') {
             row.created_at = row.created_at.replace(' ', 'T') + 'Z';
           }
           if (row.updated_at && typeof row.updated_at === 'string') {
             row.updated_at = row.updated_at.replace(' ', 'T') + 'Z';
           }

           return json({ page: row });
         }

        if (method === 'POST' && path === '/api/page/save') {
          const body = await req.json();
          if (!body.slug || !body.title) return json({ error: 'slug and title required' }, 400);
          
          if (body.id) {
            await env.DB.prepare(
              'UPDATE pages SET slug=?, title=?, content=?, meta_description=?, status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?'
            ).bind(body.slug, body.title, body.content || '', body.meta_description || '', body.status || 'published', Number(body.id)).run();
            return json({ success: true, id: body.id });
          }
          
          const r = await env.DB.prepare(
            'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)'
          ).bind(body.slug, body.title, body.content || '', body.meta_description || '', body.status || 'published').run();
          return json({ success: true, id: r.meta?.last_row_id });
        }

        if (method === 'DELETE' && path === '/api/page/delete') {
          const id = url.searchParams.get('id');
          await env.DB.prepare('DELETE FROM pages WHERE id = ?').bind(Number(id)).run();
          return json({ success: true });
        }

        // ----- R2 UPLOAD -----
        if (method === 'POST' && path === '/api/upload/temp-file') {
          try {
            if (!env.R2_BUCKET) {
              console.error('R2_BUCKET not configured');
              return json({ error: 'R2 storage not configured' }, 500);
            }

            const sessionId = url.searchParams.get('sessionId');
            const filename = url.searchParams.get('filename');

            if (!sessionId || !filename) {
              console.error('Missing sessionId or filename');
              return json({ error: 'sessionId and filename required' }, 400);
            }

            console.log('Uploading file:', filename, 'for session:', sessionId);

            const buf = await req.arrayBuffer();

            // Validate file size (max 500MB for videos, 10MB for other files)
            const isVideo = filename.toLowerCase().match(/\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/);
            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024; // 500MB for videos, 10MB for others
            const maxSizeLabel = isVideo ? '500MB' : '10MB';
            
            if (buf.byteLength > maxSize) {
              console.error('File too large:', buf.byteLength, 'bytes (max', maxSizeLabel, ')');
              return json({
                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? 'videos' : 'files'}.`,
                fileSize: buf.byteLength,
                maxSize: maxSize,
                fileType: isVideo ? 'video' : 'file'
              }, 400);
            }

            if (!buf || buf.byteLength === 0) {
              console.error('Empty file buffer');
              return json({ error: 'Empty file - please select a valid file' }, 400);
            }

            console.log('File size:', (buf.byteLength / 1024 / 1024).toFixed(2), 'MB');

            const key = `temp/${sessionId}/${filename}`;

            await env.R2_BUCKET.put(key, buf, {
              httpMetadata: { contentType: req.headers.get('content-type') || 'application/octet-stream' }
            });

            console.log('File uploaded successfully:', key);

            return json({ success: true, tempUrl: `r2://${key}` });
          } catch (err) {
            console.error('Upload error:', err);
            return json({
              error: 'Upload failed: ' + err.message,
              details: err.stack
            }, 500);
          }
        }

        if (method === 'GET' && path === '/api/r2/file') {
          if (!env.R2_BUCKET) return json({ error: 'R2 not configured' }, 500);
          
          const key = url.searchParams.get('key');
          if (!key) return json({ error: 'key required' }, 400);
          
          const obj = await env.R2_BUCKET.get(key);
          if (!obj) return json({ error: 'File not found' }, 404);
          
          return new Response(obj.body, {
            headers: {
              'Content-Type': obj.httpMetadata?.contentType || 'application/octet-stream',
              'Cache-Control': 'public, max-age=3600'
            }
          });
        }

        // ----- DELIVERY VIDEO UPLOAD -----
        // Two-stage upload process:
        // 1. Upload to R2 temp bucket for verification
        // 2. Upload to Archive.org for public access
        // 3. Verify both uploads succeeded before returning URL
        if (method === 'POST' && path === '/api/upload/customer-file') {
          try {
            if (!env.R2_BUCKET) {
              console.error('R2_BUCKET not configured');
              return json({ error: 'R2 storage not configured' }, 500);
            }

            if (!env.ARCHIVE_ACCESS_KEY || !env.ARCHIVE_SECRET_KEY) {
              console.error('Archive.org credentials not configured');
              return json({ error: 'Archive.org credentials not configured' }, 500);
            }

            const itemId = (url.searchParams.get('itemId') || '').replace(/[^a-zA-Z0-9_.-]/g, '-');
            const filename = (url.searchParams.get('filename') || '').replace(/[^a-zA-Z0-9_.-]/g, '-');
            const originalFilename = url.searchParams.get('originalFilename');

            if (!itemId || !filename) {
              console.error('Missing itemId or filename');
              return json({ error: 'itemId and filename required' }, 400);
            }

            console.log('Starting two-stage upload:', filename, 'Item:', itemId);

            const buf = await req.arrayBuffer();

            // Validate file size (max 500MB for videos, 10MB for other files)
            const videoExtensions = /\.(mp4|mov|avi|mkv|webm|m4v|flv|wmv)$/i;
            const isVideo = videoExtensions.test(filename);
            const maxSize = isVideo ? 500 * 1024 * 1024 : 10 * 1024 * 1024;
            const maxSizeLabel = isVideo ? '500MB' : '10MB';
            
            if (buf.byteLength > maxSize) {
              console.error('File too large:', buf.byteLength, 'bytes (max', maxSizeLabel, ')');
              return json({
                error: `File too large. Maximum file size is ${maxSizeLabel} for ${isVideo ? 'videos' : 'files'}.`,
                fileSize: buf.byteLength,
                maxSize: maxSize,
                fileType: isVideo ? 'video' : 'file'
              }, 400);
            }

            if (buf.byteLength === 0) {
              console.error('Empty file');
              return json({ error: 'Empty file - please select a valid file' }, 400);
            }

            console.log('File size:', (buf.byteLength / 1024 / 1024).toFixed(2), 'MB');

            // Force video MIME type for video files
            const contentType = isVideo 
              ? (getMimeTypeFromFilename(filename) || 'video/mp4')
              : resolveContentType(req, filename);
            const isVideoUpload = isVideo;

            // STAGE 1: Upload to R2 temp bucket for verification
            console.log('STAGE 1: Uploading to R2 temp bucket...');
            const r2TempKey = `temp/${itemId}/${filename}`;
            try {
              await env.R2_BUCKET.put(r2TempKey, buf, {
                httpMetadata: { contentType: contentType }
              });
              console.log('R2 temp upload successful:', r2TempKey);
            } catch (r2Err) {
              console.error('R2 temp upload failed:', r2Err);
              return json({
                error: 'Failed to upload to temp storage: ' + r2Err.message,
                stage: 'r2-temp',
                details: r2Err.stack
              }, 500);
            }

            // Verify R2 file exists
            console.log('Verifying R2 temp upload...');
            let r2File;
            try {
              r2File = await env.R2_BUCKET.get(r2TempKey);
              if (!r2File) {
                throw new Error('File not found in R2 after upload');
              }
              console.log('R2 verification successful');
            } catch (verifyErr) {
              console.error('R2 verification failed:', verifyErr);
              return json({
                error: 'R2 upload verification failed: ' + verifyErr.message,
                stage: 'r2-verify',
                details: verifyErr.stack
              }, 500);
            }

            // Get order details for Archive.org metadata
            const orderIdFromQuery = url.searchParams.get('orderId');
            let resolvedOrderId = orderIdFromQuery;
            if (!resolvedOrderId) {
              const match = itemId.match(/^delivery_(.+?)_\d+$/);
              if (match) {
                resolvedOrderId = match[1];
              }
            }

            let archiveDescription = '';
            if (resolvedOrderId) {
              try {
                const orderRow = await env.DB.prepare(
                  'SELECT o.order_id, p.title AS product_title, p.description AS product_description FROM orders o LEFT JOIN products p ON o.product_id = p.id WHERE o.order_id = ?'
                ).bind(resolvedOrderId).first();

                if (orderRow) {
                  const productTitle = orderRow.product_title || '';
                  const productDescription = orderRow.product_description || '';

                  if (productDescription) {
                    archiveDescription = productTitle
                      ? `${productTitle} - ${productDescription}`
                      : productDescription;
                  } else {
                    archiveDescription = `Order #${orderRow.order_id} - ${productTitle || 'Video Delivery'}`;
                  }
                } else {
                  archiveDescription = `Order #${resolvedOrderId} video delivery`;
                }
              } catch (dbErr) {
                console.warn('Could not fetch order details:', dbErr);
                archiveDescription = `Order #${resolvedOrderId} video delivery`;
              }
            } else {
              archiveDescription = `${isVideoUpload ? 'Video' : 'File'} uploaded via order delivery system`;
            }

            const archiveHeaders = {
              Authorization: `LOW ${env.ARCHIVE_ACCESS_KEY}:${env.ARCHIVE_SECRET_KEY}`,
              'Content-Type': contentType,
              'x-archive-auto-make-bucket': '1',
              'x-archive-meta-mediatype': isVideoUpload ? 'movies' : 'data',
              'x-archive-meta-collection': isVideoUpload ? 'opensource_movies' : 'opensource',
              'x-archive-meta-title': normalizeArchiveMetaValue(originalFilename || filename),
              'x-archive-meta-description': normalizeArchiveMetaValue(archiveDescription),
              'x-archive-meta-subject': 'video; delivery',
              'x-archive-meta-language': 'eng'
            };

            console.log('Archive.org Upload Metadata:', {
              isVideo: isVideo,
              isVideoUpload: isVideoUpload,
              contentType: contentType,
              mediatype: archiveHeaders['x-archive-meta-mediatype'],
              filename: filename,
              itemId: itemId
            });

            // STAGE 2: Upload to Archive.org
            console.log('STAGE 2: Uploading to Archive.org...');
            const archiveUrl = `https://s3.us.archive.org/${itemId}/${filename}`;
            let archiveResp;
            try {
              archiveResp = await fetch(archiveUrl, {
                method: 'PUT',
                headers: archiveHeaders,
                body: buf
              });

              if (!archiveResp.ok) {
                const errorText = await archiveResp.text().catch(() => 'Unknown error');
                console.error('Archive.org upload failed:', archiveResp.status, errorText);
                return json({
                  error: 'Archive.org upload failed',
                  status: archiveResp.status,
                  details: errorText,
                  stage: 'archive-upload',
                  r2Uploaded: true
                }, 502);
              }
              console.log('Archive.org upload successful, status:', archiveResp.status);
            } catch (archiveErr) {
              console.error('Archive.org upload network error:', archiveErr);
              return json({
                error: 'Failed to connect to Archive.org: ' + archiveErr.message,
                stage: 'archive-connect',
                details: archiveErr.message,
                r2Uploaded: true
              }, 502);
            }

            // STAGE 3: Wait for Archive.org to index the file
            console.log('STAGE 3: Waiting for Archive.org indexing...');
            await new Promise(resolve => setTimeout(resolve, 3000));

            // STAGE 4: Verify Archive.org file is accessible
            console.log('STAGE 4: Verifying Archive.org file...');
            const downloadUrl = `https://archive.org/download/${itemId}/${filename}`;
            const embedUrl = `https://archive.org/details/${itemId}`;
            
            let verifyAttempts = 0;
            const maxVerifyAttempts = 3;
            let archiveVerified = false;

            while (verifyAttempts < maxVerifyAttempts && !archiveVerified) {
              verifyAttempts++;
              try {
                const verifyResp = await fetch(downloadUrl, { method: 'HEAD' });
                if (verifyResp.ok) {
                  console.log('Archive.org file verified at attempt', verifyAttempts);
                  archiveVerified = true;
                  break;
                } else if (verifyResp.status === 404 && verifyAttempts < maxVerifyAttempts) {
                  console.log(`Archive.org file not yet available (attempt ${verifyAttempts}/${maxVerifyAttempts}), waiting...`);
                  await new Promise(resolve => setTimeout(resolve, 2000));
                } else {
                  console.warn(`Archive.org verification returned status ${verifyResp.status}`);
                  break;
                }
              } catch (verifyErr) {
                console.warn(`Archive.org verification attempt ${verifyAttempts} failed:`, verifyErr.message);
                if (verifyAttempts < maxVerifyAttempts) {
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
              }
            }

            if (!archiveVerified) {
              console.warn('Archive.org file could not be verified, but upload was successful');
            }

            console.log('Upload complete - both R2 and Archive.org successful');
            return json({ 
              success: true, 
              url: downloadUrl,
              embedUrl: embedUrl,
              itemId: itemId,
              filename: filename,
              r2Verified: true,
              archiveVerified: archiveVerified,
              isVideo: isVideoUpload
            });

          } catch (err) {
            console.error('Customer file upload error:', err);
            return json({
              error: 'Upload failed: ' + err.message,
              details: err.stack,
              stage: 'unknown'
            }, 500);
          }
        }

        // ----- ORDER ENCRYPTED FILE UPLOAD -----
        // This endpoint allows the admin UI to upload a file for a specific order.
        // The file will be stored in the configured R2 bucket and the order record
        // can be updated with a link to the uploaded file. This mirrors the
        // expectation of the admin/orders.js frontâ€‘end which calls
        // `/api/order/upload-encrypted-file`.
        if (method === 'POST' && path === '/api/order/upload-encrypted-file') {
          if (!env.R2_BUCKET) {
            return json({ error: 'R2 not configured' }, 500);
          }
          const orderId = url.searchParams.get('orderId');
          const itemId = url.searchParams.get('itemId');
          const filename = url.searchParams.get('filename');
          if (!orderId || !itemId || !filename) {
            return json({ error: 'orderId, itemId and filename required' }, 400);
          }
          // Read the request body into a buffer
          const fileBuf = await req.arrayBuffer();
          const key = `orders/${orderId}/${itemId}/${filename}`;
          await env.R2_BUCKET.put(key, fileBuf, {
            httpMetadata: { contentType: req.headers.get('content-type') || 'application/octet-stream' }
          });
          // You could update the orders table with the uploaded file key or URL here.
          // We return the R2 key so the caller can take further action if needed.
          return json({ success: true, r2Key: key });
        }

        // ----- PAGE BUILDER SAVE (plural) -----
        // The page builder UI posts to /api/pages/save with a JSON body containing a
        // `name` (used as slug/title) and `html` (the full HTML document). Because the
        // existing API only exposes singular `/api/page/save`, we implement this
        // convenience endpoint here. If a page with the same slug already exists,
        // it is updated instead of inserted. The HTML is stored verbatim in the
        // pages table's content column.
        if (method === 'POST' && path === '/api/pages/save') {
          const body = await req.json();
          const name = (body.name || '').trim();
          const html = (body.html || '').trim();
          if (!name || !html) {
            return json({ error: 'name and html required' }, 400);
          }
          // Sanitize the slug: lowerâ€‘case and replace nonâ€‘alphanumeric characters with dashes
          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          // Check if page already exists
          const existing = await env.DB.prepare('SELECT id FROM pages WHERE slug = ?').bind(slug).first();
          if (existing) {
            await env.DB.prepare(
              'UPDATE pages SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?'
            ).bind(name, html, existing.id).run();
          } else {
            await env.DB.prepare(
              'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)'
            ).bind(slug, name, html, '', 'published').run();
          }
          return json({ success: true, slug });
        }

        // ----- PAGES LIST (plural) -----
        // Returns a list of pages stored in the pages table, formatted for the
        // admin UI. Each entry includes a `name` (slug), `url` (path to the
        // generated static file), `uploaded` timestamp, and estimated `size`
        // (length of the HTML content). This endpoint exists to support
        // admin/pages.html which expects `/api/pages/list`.
        if (method === 'GET' && path === '/api/pages/list') {
          // Return all pages with their publish status. The admin UI uses this to
          // display published/draft pages and provide actions.  Selecting the
          // status column allows distinguishing between published and draft.
          const r = await env.DB.prepare(
            'SELECT slug, title, content, created_at, status FROM pages ORDER BY id DESC'
          ).all();
          const pages = (r.results || []).map(p => {
            const size = p.content ? p.content.length : 0;
            // Convert created_at to ISO 8601 format with Z suffix for UTC
            let createdAt = p.created_at;
            if (createdAt && typeof createdAt === 'string') {
              createdAt = createdAt.replace(' ', 'T') + 'Z';
            }
            return {
              name: p.slug,
              slug: p.slug,
              title: p.title,
              url: `/${p.slug}.html`,
              uploaded: createdAt,
              size: size,
              status: p.status || 'published'
            };
          });
          return json({ success: true, pages });
        }

        // ----- PAGES DELETE (plural) -----
        // Deletes a page by slug/name. Accepts a JSON body with a `name` field.
        // Returns success if the page was removed. This mirrors the admin UI
        // expectation that deletion happens via POST to `/api/pages/delete`.
        if (method === 'POST' && path === '/api/pages/delete') {
          const body = await req.json().catch(() => ({}));
          const name = (body.name || '').trim();
          if (!name) {
            return json({ error: 'name required' }, 400);
          }
          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          await env.DB.prepare('DELETE FROM pages WHERE slug = ?').bind(slug).run();
          return json({ success: true });
        }

        // ----- PAGES STATUS UPDATE -----
        // Update the publish status of a page. Accepts JSON with `name` (slug)
        // and `status` ('published' or 'draft'). Updates the status column
        // accordingly. Returns an error if the page does not exist.
        if (method === 'POST' && path === '/api/pages/status') {
          const body = await req.json().catch(() => ({}));
          const name = (body.name || '').trim();
          const status = (body.status || '').trim().toLowerCase();
          if (!name || !status) {
            return json({ error: 'name and status required' }, 400);
          }
          if (status !== 'published' && status !== 'draft') {
            return json({ error: 'invalid status' }, 400);
          }
          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          const existing = await env.DB.prepare('SELECT id FROM pages WHERE slug = ?').bind(slug).first();
          if (!existing) {
            return json({ error: 'Page not found' }, 404);
          }
          await env.DB.prepare('UPDATE pages SET status = ? WHERE slug = ?').bind(status, slug).run();
          return json({ success: true });
        }

        // ----- PAGES DUPLICATE -----
        // Duplicate an existing page into a draft. Accepts JSON with `name`
        // (slug of the existing page). Copies title, content and meta description,
        // derives a new slug by appending '-copy' and ensures uniqueness.
        if (method === 'POST' && path === '/api/pages/duplicate') {
          const body = await req.json().catch(() => ({}));
          const name = (body.name || '').trim();
          if (!name) {
            return json({ error: 'name required' }, 400);
          }
          const baseSlug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          const row = await env.DB.prepare('SELECT title, content, meta_description FROM pages WHERE slug = ?').bind(baseSlug).first();
          if (!row) {
            return json({ error: 'Page not found' }, 404);
          }
          // Determine new slug by adding '-copy' and ensuring uniqueness
          let newSlug = baseSlug + '-copy';
          let idx = 1;
          let exists = await env.DB.prepare('SELECT slug FROM pages WHERE slug = ?').bind(newSlug).first();
          while (exists) {
            newSlug = `${baseSlug}-copy${idx}`;
            idx++;
            exists = await env.DB.prepare('SELECT slug FROM pages WHERE slug = ?').bind(newSlug).first();
          }
          const newTitle = (row.title || baseSlug) + ' Copy';
          const metaDesc = row.meta_description || '';
          await env.DB.prepare(
            'INSERT INTO pages (slug, title, content, meta_description, status) VALUES (?, ?, ?, ?, ?)'
          ).bind(newSlug, newTitle, row.content || '', metaDesc, 'draft').run();
          return json({ success: true, slug: newSlug });
        }

        // ----- PAGE BUILDER LOAD (plural) -----
        // Fetch and parse a saved landing page for editing in the builder. The
        // builder expects separate `html` (the body content) and `css` (style) fields.
        if (method === 'GET' && path === '/api/pages/load') {
          const name = url.searchParams.get('name');
          if (!name) {
            return json({ error: 'name required' }, 400);
          }
          const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
          const row = await env.DB.prepare('SELECT content FROM pages WHERE slug = ?').bind(slug).first();
          if (!row) {
            return json({ error: 'Page not found' }, 404);
          }
          let full = row.content || '';
          let css = '';
          let htmlBody = '';
          try {
            // Extract CSS between <style> tags
            const styleMatch = full.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
            if (styleMatch) {
              css = styleMatch[1];
            }
            // Extract body content between <body> tags
            const bodyMatch = full.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
            htmlBody = bodyMatch ? bodyMatch[1] : full;
          } catch (e) {
            htmlBody = full;
          }
          return json({ success: true, html: htmlBody.trim(), css: css.trim() });
        }

        // ----- WEBHOOK -----
        if (method === 'POST' && path === '/api/whop/webhook') {
          const body = await req.text();
          console.log('Webhook received:', body.substring(0, 200));
          return new Response('OK', { status: 200 });
        }

        return json({ error: 'API endpoint not found', path, method }, 404);
      }

      // ===== SECURE DOWNLOAD =====
      if (path.startsWith('/download/')) {
        const orderId = path.split('/').pop();
        const order = await env.DB.prepare(
          'SELECT archive_url, delivered_video_url FROM orders WHERE order_id = ?'
        ).bind(orderId).first();

        const sourceUrl = (order?.delivered_video_url || order?.archive_url || '').toString().trim();

        if (!sourceUrl) {
          return new Response('Download link expired or not found', { status: 404 });
        }

        const lowered = sourceUrl.toLowerCase();
        const openOnly =
          lowered.includes('youtube.com') ||
          lowered.includes('youtu.be') ||
          lowered.includes('vimeo.com') ||
          lowered.includes('iframe.mediadelivery.net/embed/') ||
          lowered.includes('video.bunnycdn.com/play/') ||
          (lowered.includes('archive.org/details/') && !lowered.includes('/download/'));

        if (openOnly) {
          return Response.redirect(sourceUrl, 302);
        }

        const fileResp = await fetch(sourceUrl);
        if (!fileResp.ok) {
          return new Response('File not available', { status: 404 });
        }

        const srcUrl = new URL(sourceUrl, url.origin);
        let filename = srcUrl.pathname.split('/').pop() || 'video.mp4';
        try {
          filename = decodeURIComponent(filename);
        } catch (_) {}
        filename = filename.replace(/"/g, '');

        const contentTypeHeader = (fileResp.headers.get('content-type') || '').split(';')[0].trim();
        const contentType = contentTypeHeader || getMimeTypeFromFilename(filename) || 'application/octet-stream';

        const headers = new Headers({ ...CORS });
        headers.set('Content-Type', contentType);
        headers.set('Content-Disposition', `attachment; filename="${filename}"`);

        const contentLength = fileResp.headers.get('content-length');
        if (contentLength) {
          headers.set('Content-Length', contentLength);
        }

        return new Response(fileResp.body, {
          status: 200,
          headers
        });
      }

      // ===== ADMIN SPA ROUTING =====
      // All /admin/* routes (except API endpoints) serve the unified dashboard.html
      // This enables the Single Page Application (SPA) structure for the admin panel
      if (path.startsWith('/admin/') && !path.startsWith('/api/')) {
        // Special handling for standalone pages that remain separate
        if (path.endsWith('/page-builder.html') || 
            path.endsWith('/landing-builder.html') ||
            path.endsWith('/product-form.html')) {
          // These pages are served directly as they are complex standalone apps
          // Let them fall through to the asset serving logic below
        } else if (path === '/admin/' || path === '/admin' || path.endsWith('/dashboard.html')) {
          // Serve the main dashboard.html for root admin path
          if (env.ASSETS) {
            const assetResp = await env.ASSETS.fetch(new Request(new URL('/admin/dashboard.html', req.url)));
            const headers = new Headers(assetResp.headers);
            headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');
            headers.set('Pragma', 'no-cache');
            headers.set('X-Worker-Version', VERSION);
            return new Response(assetResp.body, { status: assetResp.status, headers });
          }
        } else if (path.endsWith('.html')) {
          // For any other /admin/*.html requests, redirect to dashboard.html
          // This ensures all old fragmented pages load as the unified dashboard
          if (env.ASSETS) {
            const assetResp = await env.ASSETS.fetch(new Request(new URL('/admin/dashboard.html', req.url)));
            const headers = new Headers(assetResp.headers);
            headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');
            headers.set('Pragma', 'no-cache');
            headers.set('X-Worker-Version', VERSION);
            return new Response(assetResp.body, { status: assetResp.status, headers });
          }
        }
      }

      // ===== DYNAMIC PAGES =====
      // Serve saved landing pages from the pages table. If the request path ends
      // with `.html` and a corresponding page exists in the database, return its
      // HTML content. This allows pages saved via the page builder to be
      // accessed at `/{slug}.html`.
      if (path.endsWith('.html') && !path.includes('/admin/')) {
        const slug = path.slice(1).replace(/\.html$/, '');
        try {
          const row = await env.DB.prepare('SELECT content FROM pages WHERE slug = ? AND status = ?').bind(slug, 'published').first();
          if (row && row.content) {
            return new Response(row.content, {
              headers: { 'Content-Type': 'text/html; charset=utf-8' }
            });
          }
        } catch (e) {
          // continue to static assets
        }
      }

      // ===== STATIC ASSETS WITH SERVER-SIDE SCHEMA INJECTION =====
      if (env.ASSETS) {
        /*
         * Serve static assets from the bound ASSETS namespace.  We wrap the
         * returned response to add headers that prevent stale caching on the
         * Cloudflare edge and include a custom version header.  Without these
         * headers it is possible for older builds to persist at the edge or in
         * the browser cache.  See https://developers.cloudflare.com/workers/
         * for guidance on controlling caching behavior.
         */
        // Support pretty product URLs: /product/<slug>
        let assetReq = req;
        let assetPath = path;
        let schemaProductId = null;

        // Canonical product URLs: /product-<id>/<slug>
        // Render without redirecting (page JS reads the id from the querystring).
        if ((method === 'GET' || method === 'HEAD')) {
          const canonicalMatch = assetPath.match(/^\/product-(\d+)\/(.+)$/);
          if (canonicalMatch) {
            const pid = Number(canonicalMatch[1]);
            if (!Number.isNaN(pid)) {
              schemaProductId = pid;
              const rewritten = new URL(req.url);
              rewritten.pathname = '/_product_template.tpl';
              rewritten.searchParams.set('id', String(schemaProductId));
              assetReq = new Request(rewritten.toString(), req);
              assetPath = '/_product_template.tpl';
            }
          }
        }

        const assetResp = await env.ASSETS.fetch(assetReq);
        
        // For HTML pages with schema placeholders, inject server-side schemas
        const contentType = assetResp.headers.get('content-type') || '';
        // The product template is stored as a .tpl asset to avoid Clean URL redirects.
        // ASSETS may serve unknown extensions as application/octet-stream, which makes
        // browsers download it instead of rendering. Treat the template as HTML.
        const isHTML = contentType.includes('text/html') || assetPath === '/_product_template.tpl';
        const isSuccess = assetResp.status === 200;
        
        if (isHTML && isSuccess) {
          try {
            const baseUrl = url.origin;
            let html = await assetResp.text();
            
            // Product detail page - inject individual product schema
            if (assetPath === '/_product_template.tpl' || assetPath === '/product.html' || assetPath === '/product') {
              const productId = schemaProductId ? String(schemaProductId) : url.searchParams.get('id');
              if (productId && env.DB) {
                await initDB(env);
                const product = await env.DB.prepare(`
                  SELECT p.*, 
                    COUNT(r.id) as review_count, 
                    AVG(r.rating) as rating_average
                  FROM products p
                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = 'approved'
                  WHERE p.id = ?
                  GROUP BY p.id
                `).bind(Number(productId)).first();
                
                if (product) {
                  // Fetch individual reviews for schema
                  const reviewsResult = await env.DB.prepare(`
                    SELECT * FROM reviews
                    WHERE product_id = ? AND status = 'approved'
                    ORDER BY created_at DESC
                    LIMIT 5
                  `).bind(Number(productId)).all();
                  let reviews = reviewsResult.results || [];

                  // Convert created_at to ISO 8601 format with Z suffix for UTC
                  reviews = reviews.map(review => {
                    if (review.created_at && typeof review.created_at === 'string') {
                      review.created_at = review.created_at.replace(' ', 'T') + 'Z';
                    }
                    return review;
                  });

                  const schemaJson = generateProductSchema(product, baseUrl, reviews);
                  html = injectSchemaIntoHTML(html, 'product-schema', schemaJson);
                }
              }
            }
            // Product listing pages - inject collection schema
            else if (path === '/index.html' || path === '/' || 
                     path === '/products-grid.html' ||
                     path === '/all-products' || path === '/all-products.html') {
              if (env.DB) {
                await initDB(env);
                const result = await env.DB.prepare(`
                  SELECT p.id, p.title, p.slug, p.description, 
                    p.thumbnail_url, p.normal_price, p.sale_price,
                    COUNT(r.id) as review_count, 
                    AVG(r.rating) as rating_average
                  FROM products p
                  LEFT JOIN reviews r ON p.id = r.product_id AND r.status = 'approved'
                  WHERE p.status = 'active'
                  GROUP BY p.id
                  ORDER BY p.sort_order ASC, p.id DESC
                  LIMIT 50
                `).all();
                
                const products = result.results || [];
                if (products.length > 0) {
                  const schemaJson = generateCollectionSchema(products, baseUrl);
                  html = injectSchemaIntoHTML(html, 'collection-schema', schemaJson);
                }
              }
            }
            
            const headers = new Headers(assetResp.headers);
            headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');
            headers.set('Pragma', 'no-cache');
            headers.set('X-Worker-Version', VERSION);
            headers.set('Content-Type', 'text/html; charset=utf-8');
            headers.set('Content-Disposition', 'inline');
            
            return new Response(html, {
              status: assetResp.status,
              headers
            });
          } catch (err) {
            console.error('Schema injection error:', err);
            // Fall through to default asset serving on error
          }
        }
        
        // For non-HTML assets or on error, serve normally
        const headers = new Headers(assetResp.headers);
        headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');
        headers.set('Pragma', 'no-cache');
        headers.set('X-Worker-Version', VERSION);
        // Safety: if the product template ever falls through here (e.g. schema injection error),
        // ensure the browser renders it instead of downloading.
        if (assetPath === '/_product_template.tpl') {
          headers.set('Content-Type', 'text/html; charset=utf-8');
          headers.set('Content-Disposition', 'inline');
        }
        return new Response(assetResp.body, { status: assetResp.status, headers });
      }

      return new Response('Worker is running', { headers: { 'Content-Type': 'text/plain' } });

    } catch (err) {
      console.error('Worker error:', err);
      return json({ error: err.message, stack: err.stack }, 500);
    }
  },

  // Scheduled handler for Cloudflare Cron Triggers
  // This runs automatically based on cron schedule in wrangler.toml
  async scheduled(event, env, ctx) {
    console.log('ðŸ•’ Scheduled cleanup running...');
    
    try {
      // Initialize database
      await initDB(env);
      
      if (!env.WHOP_API_KEY) {
        console.error('WHOP_API_KEY not configured, skipping cleanup');
        return;
      }
      
      // Get expired checkouts
      const expiredCheckouts = await env.DB.prepare(`
        SELECT checkout_id, product_id, expires_at
        FROM checkout_sessions
        WHERE status = 'pending' 
        AND datetime(expires_at) < datetime('now')
        ORDER BY created_at ASC
        LIMIT 50
      `).all();
      
      let deleted = 0;
      let failed = 0;
      
      for (const checkout of (expiredCheckouts.results || [])) {
        try {
          // Delete from Whop
          const deleteResponse = await fetch(`https://api.whop.com/api/v2/checkout_sessions/${checkout.checkout_id}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${env.WHOP_API_KEY}`
            }
          });
          
          if (deleteResponse.ok || deleteResponse.status === 404) {
            // Mark as expired in database
            await env.DB.prepare(`
              UPDATE checkout_sessions 
              SET status = 'expired', completed_at = datetime('now')
              WHERE checkout_id = ?
            `).bind(checkout.checkout_id).run();
            
            deleted++;
            console.log('ðŸ—‘ï¸ Expired checkout deleted:', checkout.checkout_id);
          } else {
            failed++;
            console.error('Failed to delete checkout:', checkout.checkout_id, deleteResponse.status);
          }
        } catch (e) {
          failed++;
          console.error('Error deleting checkout:', checkout.checkout_id, e.message);
        }
      }
      
      console.log(`âœ… Cleanup complete: ${deleted} deleted, ${failed} failed`);
    } catch (err) {
      console.error('Scheduled cleanup error:', err);
    }
  }
};
